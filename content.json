{"pages":[],"posts":[{"title":"1069 关押罪犯  ","text":"题目描述 Description S 城现有两座监狱，一共关押着N 名罪犯，编号分别为1~N。他们之间的关系自然也极 不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨 气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之 间的积怨越多。如果两名怨气值为c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并 造成影响力为c 的冲突事件。 每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表， 然后上报到S 城Z 市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力， 如果影响很坏，他就会考虑撤换警察局长。 在详细考察了N 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在 两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只 要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。那 么，应如何分配罪犯，才能使Z 市长看到的那个冲突事件的影响力最小？这个最小值是少？ 输入描述 Input Description 第一行为两个正整数N 和M，分别表示罪犯的数目以及存在仇恨的罪犯对数。 接下来的M 行每行为三个正整数aj，bj，cj，表示aj 号和bj 号罪犯之间存在仇恨，其怨气值为cj。数据保证，且每对罪犯组合只出现一次。 输出描述 Output Description 共1 行，为Z 市长看到的那个冲突事件的影响力。如果本年内监狱 中未发生任何冲突事件，请输出0。 样例输入 Sample Input 4 6 1 4 2534 2 3 3512 1 2 28351 1 3 6618 2 4 1805 3 4 12884 样例输出 Sample Output 3512 数据范围及提示 Data Size &amp; Hint 罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件 影响力是3512（由2 号和3 号罪犯引发）。其他任何分法都不会比这个分法更优。 【数据范围】 对于30%的数据有N≤ 15。 对于70%的数据有N≤ 2000，M≤ 50000。 对于100%的数据有N≤ 20000，M≤ 100000。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define fi first#define se second#define sz sizeconst int maxn=2e4+10;int color[maxn],n,m;vector&lt;pair&lt;int,int&gt; &gt;G[maxn];int a,b,tmp;int l,r;/*4 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884*/int dfs(int root,int c,int len){ color[root]=c; for(int i=0;i&lt;G[root].sz();++i) { if(G[root][i].se&lt;=len)continue; int to=G[root][i].fi; if(!color[to]&amp;&amp;!dfs(to,-c,len))return false; else if(color[to]==c)return false; } return true;}bool Match(int mid){ int ans=0; memset(color,0,sizeof(color)); for(int i=1;i&lt;=n;++i) { if(!color[i])if(!dfs(i,1,mid))return false; } return true;}signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;n&gt;&gt;m; rep(i,1,m) { cin&gt;&gt;a&gt;&gt;b&gt;&gt;tmp; r=max(tmp,r); G[a].pb(mk(b,tmp)); G[b].pb(mk(a,tmp)); } while(l!=r){ int mid=(l+r)&gt;&gt;1; if(!Match(mid))l=mid+1; else r=mid; } cout&lt;&lt;l&lt;&lt;endl; return 0;}","link":"/2019/08/1069%20%E5%85%B3%E6%8A%BC%E7%BD%AA%E7%8A%AF%20/"},{"title":"1202: [HNOI2005]狡猾的商人","text":"1202: [HNOI2005]狡猾的商人Time Limit: 10 Sec Memory Limit: 162 MBSubmit: 5394 Solved: 2680[Submit][Status][Discuss] Description刁姹接到一个任务，为税务部门调查一位商人的账本，看看账本是不是伪造的。账本上记录了n个月以来的收入情况，其中第i 个月的收入额为Ai(i=1,2,3…n-1,n)， 。当 Ai大于0时表示这个月盈利Ai 元，当 Ai小于0时表示这个月亏损Ai 元。所谓一段时间内的总收入，就是这段时间内每个月的收入额的总和。 刁姹的任务是秘密进行的，为了调查商人的账本，她只好跑到商人那里打工。她趁商人不在时去偷看账本，可是她无法将账本偷出来，每次偷看账本时她都只能看某段时间内账本上记录的收入情况，并且她只能记住这段时间内的总收入。 现在，刁姹总共偷看了m次账本，当然也就记住了m段时间内的总收入，你的任务是根据记住的这些信息来判断账本是不是假的。 Input第一行为一个正整数w，其中w &lt; 100，表示有w组数据，即w个账本，需要你判断。每组数据的第一行为两个正整数n和m，其中n &lt; 100，m &lt; 1000，分别表示对应的账本记录了多少个月的收入情况以及偷看了多少次账本。接下来的m行表示刁姹偷看m次账本后记住的m条信息，每条信息占一行，有三个整数s，t和v，表示从第s个月到第t个月（包含第t个月）的总收入为v，这里假设s总是小于等于t。 Output包含w行,每行是true或false,其中第i行为true当且仅当第i组数据，即第i个账本不是假的；第i行为false当且仅当第i组数据，即第i个账本是假的。 Sample Input2 3 3 1 2 10 1 3 -5 3 3 -15 5 3 1 5 100 3 5 50 1 2 51 Sample Outputtrue false Code(dfs+对偶图):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define int long long const int maxn = 200;int vis[maxn], d[maxn];struct edge { int aim, v;};vector&lt;edge&gt;G[maxn];int dfs(int u, int dis){ vis[u] = true; d[u] = dis; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i].aim, c = G[u][i].v; if (!vis[v]) { if (!dfs(v, dis + c))return false; } else { /*cerr &lt;&lt; \"debug \" &lt;&lt; u &lt;&lt; \" \" &lt;&lt; v &lt;&lt; endl; cerr &lt;&lt; \" \" &lt;&lt; i &lt;&lt; \" \" &lt;&lt; G[u].size() &lt;&lt; endl; cerr &lt;&lt; \"world \" &lt;&lt; dis + c &lt;&lt; \" \" &lt;&lt; d[v] &lt;&lt; endl;*/ if (dis + c == d[v])continue; else return false; } } return true;} int n, m;signed main() { ios::sync_with_stdio(false); cin.tie(NULL), cout.tie(NULL); int t; cin &gt;&gt; t; while (t--) { set&lt;pair&lt;int, int&gt;&gt;st; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n + 1; ++i)G[i].clear(); for (int i = 0; i &lt; 150; ++i)d[i] = vis[i] = 0; bool c = true; for (int i = 1; i &lt;= m; ++i) { int s, t, v; cin &gt;&gt; s &gt;&gt; t &gt;&gt; v; G[s].push_back(edge{ t + 1,v }); G[t + 1].push_back(edge{ s,-v }); if (st.count(make_pair(s, t)))c = false; else st.insert(make_pair(s, t)); } if (!c) { cout &lt;&lt; \"false\" &lt;&lt; endl; continue; } bool flag = true; for (int i = 1; i &lt;= n + 1; ++i) { if (!vis[i]) flag = dfs(i, 0); if (!flag) { break; } } if (flag)cout &lt;&lt; \"true\" &lt;&lt; endl; else cout &lt;&lt; \"false\" &lt;&lt; endl; } return 0;} 带权并查集1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int sum[110],fa[110];int findfa(int x) { if(x!=fa[x]) { int tt=fa[x]; fa[x]=findfa(fa[x]); sum[x]+=sum[tt]; } return fa[x];}int main() { int T;scanf(\"%d\",&amp;T); while(T--) { int n,m;scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0;i&lt;=n;i++) fa[i]=i,sum[i]=0; bool bk=true; for(int i=1;i&lt;=m;i++) { int st,ed,x; scanf(\"%d%d%d\",&amp;st,&amp;ed,&amp;x);st--;//st到ed的和应该是sum[ed]-sum[st-1] int xx=findfa(st),yy=findfa(ed); if(xx!=yy) { fa[yy]=xx; sum[yy]=x+sum[st]-sum[ed]; //这个画个图即可明白 } else if(sum[ed]-sum[st]!=x) bk=false; } if(bk==false) printf(\"false\\n\"); else printf(\"true\\n\"); } return 0;}","link":"/2019/08/1202-HNOI2005/"},{"title":" 1213G Path Queries","text":"codeforces 1213G Path QueriesTutorialLet’s carry the value resres that means the answer for the current set of edges. Initially it is 00. Let’s sort all edges by their weight and all queries by their weight also (both in non-decreasing order). Let’s merge components of the tree using DSU (disjoint set union). We need to carry sizes of components also (it is easy if we use DSU). Then let’s iterate over all queries in order of non-decreasing their weights. If the current query has weight cwcw then let’s merge all components connected by edges with weight wi≤cwwi≤cw. When we merge two components with sizes s1s1 and s2s2, the answer changes like that: res:=res−(s12)−(s22)+(s1+s22)res:=res−(s12)−(s22)+(s1+s22). The value (x2)(x2) equals to x(x−1)2x(x−1)2. It is so because we subtract all old paths corresponding to these components and add all new paths in the obtained component. So the answer for the current query will be resresafter all required merges.、 Time complexity: O(nlogn+mlogm)O(nlog⁡n+mlog⁡m). 大佬题解：把询问离线，对于每个询问，我们把比他的要求小的边全部加进树中。 那么答案就是所有连通块的贡献，每个连通块的贡献是sz*(sz-1)/2 那么我们按询问的要求值从小到大排序，然后每次尝试加边，并用并查集维护连通块大小 Code：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long#define int long longconst int maxn=2e5+10;int fa[maxn],Ans[maxn],num[maxn];struct qu{ int id; int len; int operator&lt;(const qu&amp;rhs){ return len&lt;rhs.len; }}q[maxn];// bool cmpq(const qu&amp;lhs,const qu&amp;rhs){// return lhs.len&lt;rhs.len;// }struct edge{ int a,b,l; bool operator&lt;(const edge&amp;rhs){ return l&lt;rhs.a; }}edges[maxn];bool cmpe(const edge&amp;lhs,const edge&amp;rhs){ return lhs.l&lt;rhs.l;}ll ans;int getfa(int cur){ return fa[cur]==cur?cur:fa[cur]=getfa(fa[cur]);}signed main(){ ios::sync_with_stdio(NULL); cin.tie(0); int n,m; cin&gt;&gt;n&gt;&gt;m; rep(i,1,n-1)cin&gt;&gt;edges[i].a&gt;&gt;edges[i].b&gt;&gt;edges[i].l; sort(edges+1,edges+n,cmpe); rep(i,1,m){cin&gt;&gt;q[i].len;q[i].id=i;} sort(q+1,q+1+m); int pos=1; rep(i,1,n)fa[i]=i,num[i]=1; rep(i,1,m){ while(pos&lt;n&amp;&amp;edges[pos].l&lt;=q[i].len){ int _fa=getfa(edges[pos].a); int _fb=getfa(edges[pos].b); ans+=num[_fa]*num[_fb]; num[_fa]+=num[_fb]; fa[_fb]=_fa; ++pos; } Ans[q[i].id]=ans; } for(int i=1;i&lt;=m;++i) cout&lt;&lt;Ans[i]&lt;&lt;\" \"; cout&lt;&lt;endl; return 0;}","link":"/2019/08/1213G-Path-Queries/"},{"title":"1257: [CQOI2007]余数之和","text":"1257: [CQOI2007]余数之和Time Limit: 5 Sec Memory Limit: 128 MBSubmit: 7387 Solved: 3561[Submit][Status][Discuss] Description给出正整数n和k，计算$j(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n$的值 其中$k mod i$表示$k$除以$i$的余数。 例如$j(5, 3)=3 mod 1 + 3 mod 2 + 3 mod 3 + 3 mod 4 + 3 mod 5=0+1+0+3+3=7$ Input输入仅一行，包含两个整数n, k。 1&lt;=n ,k&lt;=10^9 Output输出仅一行，即j(n, k)。 Sample Input5 3 Sample Output7 大佬讲解: https://www.cnblogs.com/0xfffe/p/9648943.html Code:123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longint n,k;ll ans=0;signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); //freopen(\"../in.txt\", \"r\", stdin); //freopen(\"../out.txt\", \"w\", stdout); cin&gt;&gt;n&gt;&gt;k; ans=n*k; for(int l=1,r;l&lt;=n;l=r+1){ if(k/l)r=min(r,k/(k/l)); else r=n; ans-=(k/l)*(r-l+1)*(l+r)*(l+r)/2; } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2019/08/1257-CQOI2007/"},{"title":"Alice’s Stamps","text":"http://acm.hdu.edu.cn/showproblem.php?pid=6249 Alice’s StampsTime Limit: 6000/3000 MS (Java/Others) Memory Limit: 65536/65536 K (Java/Others)Total Submission(s): 1691 Accepted Submission(s): 594 Problem Description Alice likes to collect stamps. She is now at the post office buying some new stamps.There are N different kinds of stamps that exist in the world; they are numbered 1 through N. However, stamps are not sold individually; they must be purchased in sets. There are M different stamp sets available; the ith set contains the stamps numbered Li through Ri. The same stamp might appear in more than one set, and it is possible that one or more stamps are not available in any of the sets.All of the sets cost the same amount; because Alice has a limited budget, she can buy at most K different sets. What is the maximum number of different kinds of stamps that Alice can get? Input The input starts with one line containing one integer T, the number of test cases.T test cases follow.Each test case begins with a line containing three integers: N, M, and K: the number of different kinds of stamps available, the number of stamp sets available, and the maximum number of stamp sets that Alice can buy.M lines follow; the ithoftheselinesrepresentsthei^{th} stamp set and contains two integers, Li and Ri, which represent the inclusive range of the numbers of the stamps available in that set.1≤T≤1001≤K≤M1≤N,M≤20001≤Li≤Ri≤N Output For each test case, output one line containing “Case #x: y”, where x is the test case number (starting from 1) and y is the maximum number of different kinds of stamp that Alice could get. Sample Input 1234567825 3 23 41 11 3100 2 11 5090 100 Sample Output 1234567Case #1: 4Case #2: 50HintIn sample case #1, Alice could buy the first and the third stamp sets, which contain the first four kindsof stamp. Note that she gets two copies of stamp 3, but only the number of different kinds of stampsmatters, not the number of stamps of each kind.In sample case #2, Alice could buy the first stamp set, which contains 50 different kinds of stamps. Source 2017中国大学生程序设计竞赛-总决赛-重现赛（感谢哈工大） Recommend liuyiding 转载的大佬的思路和代码：【链接】 acm.hdu.edu.cn/showproblem.php?pid=6249 【题意】 给你m个区间，要求你选出k个区间，使得区间并的覆盖范围最大 1≤T≤1001≤K≤M1≤N,M≤20001≤Li≤Ri≤N 【思路】 一开始我们得出错误的dp转移： 先按右端点排序，dp[i][j]表示前i个区间集合，当前已经选了j个的最大的覆盖范围，但是显然需要再枚举是哪个右端点转移过来的。显然是O(n^3)的复杂度显然不行，但是我们错误地记录了转移到的最大的贡献来自于哪个右端点，其实这样是错误的。哎，思维不够严谨。 正确的做法是：改变dp状态设计。可以观察到，n的范围只有2000，那么这个条件肯定是要用的。我们设计dp[i][j]表示当前位于值为i的点，并且选了j个区间的最大dp值，显然，对于一个点，我们会选择能覆盖这个点的最远的区间右端点，维护一下这个，对于每个点，选与不选转移即可 Code:12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e3 + 5;int L[maxn], R[maxn];int dp[maxn][maxn];int up[maxn];int main() { int t; scanf(\"%d\", &amp;t); int ca = 0; while (t--) { memset(dp, 0, sizeof(dp)); memset(up, 0, sizeof(up)); int n, m, k; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); for (int j = x; j &lt;= y; j++) { up[j] = max(up[j], y); } } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= k; j++) { dp[i][j] = max(dp[i][j], dp[i - 1][j]); if (up[i]) { dp[up[i]][j] = max(dp[up[i]][j], dp[i - 1][j-1] + up[i] - i + 1); } } } printf(\"Case #%d: %d\\n\", ++ca, dp[n][k]); }} 版权声明：本文为CSDN博主「lzk_1049668876」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/running_acmer/article/details/83150375","link":"/2019/08/Alice%C3%AD%C2%BBs-Stamps/"},{"title":"All-one Matrices","text":"链接：https://ac.nowcoder.com/acm/contest/888/A来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 524288K，其他语言1048576K 64bit IO Format: %lld 题目描述 Gromah and LZR entered the great tomb, the first thing they see is a matrix of size n×mn\\times mn×m, and the elements in the matrix are all 00_{}0 or 11_{}1. LZR finds a note board saying “An all-one matrix is defined as the matrix whose elements are all 11_{}1, you should determine the number of all-one submatrices of the given matrix that are not completely included by any other all-one submatrices”. Meanwhile, Gromah also finds a password lock, obviously the password should be the number mentioned in the note board! Please help them determine the password and enter the next level. 输入描述:1The first line contains two positive integers n,mn,m_{}n,m, denoting the size of given matrix.Following nn_{}n lines each contains a string with length mm_{}m, whose elements are all 00_{}0 or 11_{}1, denoting the given matrix.1≤n,m≤30001\\le n,m \\le 30001≤n,m≤3000 输出描述:1Print a non-negative integer, denoting the answer. 示例1 输入复制 12343 4011111100101 输出复制 15 说明1The 5 matrices are (1,2)−(1,4), (1,2)−(2,3), (1,2)−(3,2), (2,1)−(2,3), (3,4)−(3,4)(1,2)-(1,4), \\; (1,2)-(2,3), \\; (1,2)-(3,2), \\; (2,1)-(2,3), \\; (3,4)-(3,4)_{}(1,2)−(1,4),(1,2)−(2,3),(1,2)−(3,2),(2,1)−(2,3),(3,4)−(3,4). 题解： 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=3010;int n,m,Up[maxn][maxn],Left[maxn][maxn];ll ans;struct node{ int l,r,judge;}s[maxn];char mp[maxn][maxn];signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin&gt;&gt;n&gt;&gt;m; rep(i,1,n) rep(j,1,m) cin&gt;&gt;mp[i][j]; rep(i,1,n) rep(j,1,m){ Up[i][j]=mp[i][j]=='0'?0:Up[i-1][j]+1; Left[i][j]=mp[i][j]=='0'?0:Left[i][j-1]+1; } rep(i,1,n){ rep(j,1,m)s[j].l=s[j].r=0,s[j].judge=true; stack&lt;int&gt;st; rep(j,1,m){ while(!st.empty()&amp;&amp;Up[i][st.top()]&gt;=Up[i][j]){ int cur=st.top(); st.pop(); s[cur].r=j; s[cur].judge=!(Up[i][cur]==Up[i][j]); } s[j].l=st.empty()?0:st.top(); st.push(j); } while(!st.empty()){ int cur=st.top(); st.pop(); s[cur].r=m+1; s[cur].l=st.empty()?0:st.top(); } rep(j,1,m){ if(s[j].judge&amp;&amp;mp[i][j]=='1'){ if(Left[i+1][s[j].r-1]&lt;s[j].r-s[j].l-1){ ans++; } } } } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2019/08/All-one-Matrices/"},{"title":"Assemble","text":"Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longstruct item{ int price,quality; item(int a,int b):price(a),quality(b){}; item():price(0),quality(0){}; bool operator&lt;(const item&amp;rhs)const{ return quality==rhs.quality?price&lt;rhs.price:quality&lt;rhs.quality; } bool operator&lt;(const int cur)const{ return quality&lt;cur; }};const int maxn=1100;item items[maxn][maxn];int pos[maxn];int b,n,id;map&lt;string,int&gt;mp;set&lt;string&gt; s;int check(int cur){ ll ans=0; rep(i,1,id){ auto inx=lower_bound(items[i]+1,items[i]+pos[i]+1,cur); if(inx==items[i]+pos[i]+1)return false; int Min=(*inx).price; while(inx!=items[i]+pos[i]+1){ Min=min(Min,(*inx).price); ++inx; } ans+=Min; } return ans&lt;=b;}signed main(){ ios::sync_with_stdio(NULL); cin.tie(nullptr),cout.tie(nullptr); int t; cin&gt;&gt;t; rep(_,1,t){ s.clear(),mp.clear(); cin&gt;&gt;n&gt;&gt;b; id=0; rep(i,0,n)pos[i]=0; string sa,sb; rep(i,1,n){ cin&gt;&gt;sa&gt;&gt;sb; int inx=0; if(s.count(sa))inx=mp[sa]; else{ s.insert(sa); mp.insert(mk(sa,++id)); inx=id; } int price,qua; cin&gt;&gt;price&gt;&gt;qua; items[inx][++pos[inx]]=item(price,qua); } rep(i,1,id)sort(items[i]+1,items[i]+pos[i]+1); int l=0,r=1e9; int ans=l; while(l&lt;r){ int mid=(l+r)&gt;&gt;1; if(check(mid)){ ans=mid; l=mid+1; } else r=mid; } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2019/08/Assemble/"},{"title":"Blank","text":"Problem DescriptionThere are$ N $blanks arranged in a row. The blanks are numbered $1,2,…,N $from left to right.Tom is filling each blank with one number in ${0,1,2,3}$. According to his thought, the following M conditions must all be satisfied. The ith condition is:There are exactly$ xi$ different numbers among blanks $∈[li,ri]$.In how many ways can the blanks be filled to satisfy all the conditions? Find the answer modulo $998244353$. InputThe first line of the input contains an integer $T(1≤T≤15)$, denoting the number of test cases.In each test case, there are two integers$ n(1≤n≤100) $and $m(0≤m≤100)$ in the first line, denoting the number of blanks and the number of conditions.For the following m lines, each line contains three integers l,r and x, denoting a condition$(1≤l≤r≤n, 1≤x≤4)$. OutputFor each testcase, output a single line containing an integer, denoting the number of ways to paint the blanks satisfying all the conditions modulo $998244353$. Sample Input 123421 04 11 3 3 Sample Outpu12496 题解：定义 $dp[i][j][k][t]$ 代表填完前 t 个位置后，${0,1,2,3} $这 4 个数字最后一次出现的位置，排序后为 $i,j,k,t(i &lt; j &lt; k &lt; t)$ 的方案数目，则按照第 $t+1$ 位的数字的四种选择，可以得到四种转移。对于限制可以按照限制区间的右端点分类，求出$dp[i][j][k][t]$ 后，找到所有以 t 为区间右端点的限制条件，如果当前状态不满足所有限制条件则不合法，不再向后转移。总时间复杂度 $O(n^4 )$。滚动一维，空间复杂度 $O(n^3)$ 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; piir;const int N = 100 + 5;int n, m, ans;int dp[2][N][N][N];vector &lt;piir&gt; lims[N];inline void Mod(int &amp;x) { static int mod = 998244353;//1e9 + 7; if (x &gt;= mod) x -= mod;}int main() { int Case, ans, l, r, x; int i, j, k, t, p; for (scanf(\"%d\", &amp;Case); Case --; ) { ans = 0; scanf(\"%d %d\", &amp;n, &amp;m); for (i = 1; i &lt;= n; i ++) lims[i].clear(); for (i = 0; i &lt; m; i ++) { scanf(\"%d %d %d\", &amp;l, &amp;r, &amp;x); lims[r].push_back(piir(l, x)); } dp[0][0][0][0] = 1; //n的数据范围是1-n，按顺序遍历结尾 for (i = p = 1; i &lt;= n; i ++, p ^= 1) { //数组初始化，滚动数组把当前状态置为0 for (j = 0; j &lt;= i; j ++) for (k = 0; k &lt;= j; k ++) for (t = 0; t &lt;= k; t ++) dp[p][j][k][t] = 0; for (j = 0; j &lt; i; j ++) for (k = 0; k &lt;= j; k ++) for (t = 0; t &lt;= k; t ++) { //状态转移方程 Mod(dp[p][j][k][t] += dp[p ^ 1][j][k][t]); Mod(dp[p][i - 1][k][t] += dp[p ^ 1][j][k][t]); Mod(dp[p][i - 1][j][t] += dp[p ^ 1][j][k][t]); Mod(dp[p][i - 1][j][k] += dp[p ^ 1][j][k][t]); } for (j = 0; j &lt; i; j ++) for (k = 0; k &lt;= j; k ++) for (t = 0; t &lt;= k; t ++) for (piir tmp : lims[i]) if (1 + (j &gt;= tmp.first) + (k &gt;= tmp.first) + (t &gt;= tmp.first) != tmp.second) dp[p][j][k][t] = 0; } for (i = 0, p = n &amp; 1; i &lt; n; i ++) for (j = 0; j &lt;= i; j ++) for (k = 0; k &lt;= j; k ++) Mod(ans += dp[p][i][j][k]); printf(\"%d\\n\", ans); } return 0;} 理解：用二维$dp$数组滚动，分别代表当前状态和前一个状态，$p$代表当前状态，$p\\oplus1$代表前一状态。下一次循环中，$p\\oplus=1$，现在的当前的状态变为下一状态的前一个状态。 代码遍历$1-n$，根据当前，也就是i点的选择进行下一次的状态 转移。${0,1,2,3} $这四个数字中最后一个数字出现的位置一定是当前位置，因为当前位置我们一定要放置数字的，所以我们在进行动态规划的状态转移中，这个当前位置我们就可以不写。$dp[p][j][k][t]$代表除了当前位置外，另外三个数字的最后出现位置。$$Mod(dp[p][j][k][t] += dp[p \\oplus 1][j][k][t]);\\ Mod(dp[p][i - 1][k][t] += dp[p \\oplus 1][j][k][t]);\\ Mod(dp[p][i - 1][j][t] += dp[p \\oplus 1][j][k][t]);\\ Mod(dp[p][i - 1][j][k] += dp[p \\oplus 1][j][k][t]);$$分别看这四个方程： 当前位置选的数字是上一个状态选的数字，状态转移的时候我们就不需要这个数字。 当前数字选的位置上一个位置是j，那么j此时就不需要记录，但是上一个状态不需要记录的数字此时就需要记录了，上一个状态的最后一个，是当前状态的前一个，也就是$i-1$ 和2同理 和3同理 所以判断当前状态是否合理时，放在r位置的数字是肯定在范围内的，也就是首先需要加上的1","link":"/2019/07/Blank/"},{"title":"Buses","text":"Little boy Gerald studies at school which is quite far from his house. That’s why he has to go there by bus every day. The way from home to school is represented by a segment of a straight line; the segment contains exactly n+1bus stops. All of them are numbered with integers from 0 to n in the order in which they follow from Gerald’s home. The bus stop by Gerald’s home has number 0 and the bus stop by the school has number n. There are m buses running between the house and the school: the i-th bus goes from stop s**i to t**i (s**i&lt;t**i), visiting all the intermediate stops in the order in which they follow on the segment. Besides, Gerald’s no idiot and he wouldn’t get off the bus until it is still possible to ride on it closer to the school (obviously, getting off would be completely pointless). In other words, Gerald can get on the i-th bus on any stop numbered from s**i to t**i-1 inclusive, but he can get off the i-th bus only on the bus stop t**i. Gerald can’t walk between the bus stops and he also can’t move in the direction from the school to the house. Gerald wants to know how many ways he has to get from home to school. Tell him this number. Two ways are considered different if Gerald crosses some segment between the stops on different buses. As the number of ways can be too much, find the remainder of a division of this number by 1000000007 (109+7). Input The first line contains two space-separated integers: n and m (1≤n≤109,0≤m≤105). Then follow m lines each containing two integers s**i,t**i. They are the numbers of starting stops and end stops of the buses (0≤s**i&lt;t*i≤*n). Output Print the only number − the number of ways to get to the school modulo 1000000007 (109+7). Examples Input 12 20 11 2 Output 11 Input 13 20 11 2 Output 10 Input 15 50 10 20 30 40 5 Output 116 Note The first test has the only variant to get to school: first on bus number one to the bus stop number one; then on bus number two to the bus stop number two. In the second test no bus goes to the third bus stop, where the school is positioned. Thus, the correct answer is 0. In the third test Gerald can either get or not on any of the first four buses to get closer to the school. Thus, the correct answer is 24=16. code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define sz size#define ll long longconst int maxn = 1e5 + 7;const int mod = 1e9 + 7;struct bus { int l, r; bool operator&lt;(const bus&amp; rhs)const { return r &lt; rhs.r; }}a[maxn];struct node { int l, r; ll sum;}tr[maxn &lt;&lt; 2];void build(int rot, int l, int r) { tr[rot].l = l, tr[rot].r = r; if (l == r) { tr[rot].sum = (l == 0 ? 1 : 0); return; } int mid = (l + r) &gt;&gt; 1; build(rot &lt;&lt; 1, l, mid); build(rot &lt;&lt; 1 | 1, mid + 1, r); tr[rot].sum = tr[rot &lt;&lt; 1].sum + tr[rot &lt;&lt; 1 | 1].sum;}ll QuareSum(int rot, int L, int R) { int l = tr[rot].l, r = tr[rot].r; if (l == L &amp;&amp; r == R) { return tr[rot].sum % mod; } int mid = (l + r) &gt;&gt; 1; if (R &lt;= mid)return QuareSum(rot &lt;&lt; 1, L, R); else if (L &gt; mid)return QuareSum(rot &lt;&lt; 1 | 1, L, R); else return (QuareSum(rot &lt;&lt; 1, L, mid) + QuareSum(rot &lt;&lt; 1 | 1, mid + 1, R)) % mod;}void Insertr(int rot, int aim, ll v) { int l = tr[rot].l, r = tr[rot].r; if (l == aim &amp;&amp; r == aim) { tr[rot].sum = (tr[rot].sum + v) % mod; //cerr &lt;&lt; \"insert \" &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; \" \" &lt;&lt; tr[rot].sum &lt;&lt; \" \" &lt;&lt; aim &lt;&lt; endl; return; } int mid = (l + r) &gt;&gt; 1; if (aim &lt;= mid)Insertr(rot &lt;&lt; 1, aim, v); else Insertr(rot &lt;&lt; 1 | 1, aim, v); tr[rot].sum = (tr[rot &lt;&lt; 1].sum + tr[rot &lt;&lt; 1 | 1].sum) % mod;}int n, m, Max;vector&lt;int&gt;v;int getid(int cur) { return lower_bound(v.begin(), v.end(), cur) - v.begin(); }signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m; v.push_back(n); v.push_back(0); rep(i, 1, m) { cin &gt;&gt; a[i].l &gt;&gt; a[i].r; v.push_back(a[i].l); v.push_back(a[i].r); v.push_back(a[i].r - 1); } sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); build(1, 0, v.size() - 1); sort(a + 1, a + 1 + m); rep(i, 1, m) { int l = a[i].l, r = a[i].r; ll cur = QuareSum(1, getid(l), getid(r - 1)); Insertr(1, getid(r), cur); } ll ans = QuareSum(1, getid(n), getid(n)); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/08/Buses/"},{"title":"CDMA","text":"链接：https://ac.nowcoder.com/acm/contest/888/C来源：牛客网 题目描述 Gromah and LZR have entered the third level. There is a blank grid of size m×mm\\times mm×m, and above the grid is a word “CDMA”. In CDMA Technology, a Technology about computer network, every network node should be appointed a unique binary sequence with a fixed and the same length. Moreover, if we regard 00_{}0−1-1_{}−111_{}1+1+1_{}+1s,ts,t_{}s,ts,ts,t_{}s,t00_{}0 The inner product of two sequences s,ts,t_{}s,t with the same length nn_{}n equals to ∑i=1nsiti\\sum_{i=1}^{n} s_it_i∑i=1nsiti. So, the key to the next level is to construct a grid of size m×mm\\times mm×m, whose elements are all −1-1_{}−1 or 11_{}1, and for any two different rows, the inner product of them should be exactly 00_{}0. In this problem, it is guaranteed that mm_{}m22_{}2mm_{}m 输入描述:1Only one positive integer mm_{}m in one line.m∈{2k ∣ k=1,2,⋯ ,10}m \\in \\{2^k \\; | \\;k = 1, 2, \\cdots, 10\\}m∈{2k∣k=1,2,⋯,10} 输出描述:1Print mm_{}m lines, each contains a sequence with length mm_{}m, whose elements should be all −1-1_{}−1 or 11_{}1 satisfying that for any two different rows, the inner product of them equals 00_{}0.You may print multiple blank spaces between two numbers or at the end of each line, and you may print any number of blank characters at the end of whole output file. 示例1 输入复制 12 输出复制 121 11 -1 说明1The inner product of the two rows is 1×(−1)+1×1=01\\times(-1) + 1\\times 1 = 01×(−1)+1×1=0. 题解： Code:123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt; using namespace std; const int maxn=1100; int mp[maxn][maxn],m; int main(){ cin&gt;&gt;m; mp[1][1]=1,mp[1][2]=-1; mp[2][1]=1,mp[2][2]=1; for(int i=4;i&lt;=m;i*=2) { int l=i/2; for(int j=1;j&lt;=i/2;++j) for(int k=1;k&lt;=i/2;++k) { mp[j][k+l]=mp[j][k]; mp[j+l][k]=mp[j][k]; mp[j+l][k+l]=-mp[j][k]; } } for(int i=1;i&lt;=m;++i) { for(int j=1;j&lt;=m;++j) cout&lt;&lt;mp[i][j]&lt;&lt;\" \"; cout&lt;&lt;endl; } return 0; }","link":"/2019/08/CDMA/"},{"title":"CF-D-Beautiful-numbers","text":"D. Beautiful numbers 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;list&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;algorithm&gt;//#define LL __int64#define LL long long#define eps 1e-12#define PI acos(-1.0)using namespace std;const int INF = 0x3f3f3f3f;const int maxn = 4010;const int max_lcm = 2520;#define hash hasheeeeLL gcd(LL a, LL b){ if(b == 0) return a; return gcd(b,a%b);}LL lcm(LL a, LL b){ return a/gcd(a,b)*b;}int dig[25];LL dp[25][50][2525];int hash[2525]; LL dfs(int len, int prelcm, int prenum, int up){ if(len == 0) { return prenum%prelcm == 0; } if(!up &amp;&amp; dp[len][hash[prelcm]][prenum] != -1) return dp[len][hash[prelcm]][prenum]; int n = up ? dig[len] : 9; LL res = 0; for(int i = 0; i &lt;= n; i++) { int nownum = (prenum*10+i)%max_lcm; int nowlcm = prelcm; if(i) nowlcm = lcm(prelcm,i); res += dfs(len-1,nowlcm,nownum,up&amp;&amp;i==n); } if(!up) dp[len][hash[prelcm]][prenum] = res; return res;} LL cal(LL num){ int len = 0; while(num) { dig[++len] = num%10; num /= 10; } return dfs(len,1,0,1);} int main(){ int test; LL a,b; int cnt = 0; for(int i = 1; i &lt;= 2520; i++) //离散化 { if(max_lcm % i == 0) hash[i] = ++cnt; } scanf(\"%d\",&amp;test); memset(dp,-1,sizeof(dp)); for(int item = 1; item &lt;= test; item++) { scanf(\"%I64d %I64d\",&amp;a,&amp;b); printf(\"%I64d\\n\",cal(b) - cal(a-1)); } return 0;}","link":"/2019/07/CF-D-Beautiful-numbers/"},{"title":"CF1228","text":"CF1228 Distinct Digits 12345678910111213141516171819202122232425262728293031323334353637/** * author: MySakure * created: 30.09.2019 09:58:38 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longint a[100];int check(int u){ rep(i,0,10)a[i]=0; while(u){ a[u%10]++; u/=10; } rep(i,0,9)if(a[i]&gt;=2)return false; return true;}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); int l,r; cin&gt;&gt;l&gt;&gt;r; rep(i,l,r){ if(check(i)){ cout&lt;&lt;i&lt;&lt;endl; return 0; } } cout&lt;&lt;-1&lt;&lt;endl; return 0;} Filling the Grid 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * author: MySakure * created: 30.09.2019 10:05:01 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int mod=1e9+7;const int maxn=1e3+10;int v[maxn][maxn];int a[maxn],b[maxn],n,m;#define int long longsigned main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n&gt;&gt;m; rep(i,1,n)cin&gt;&gt;a[i]; rep(i,1,m)cin&gt;&gt;b[i]; rep(i,1,n){ rep(j,1,m){ if(j&lt;=a[i]||i&lt;=b[j])v[i][j]=1; } } for(int i=1;i&lt;=n;++i){ int pos=0; while(v[i][pos+1]==1)++pos; if(pos!=a[i]){ cout&lt;&lt;0&lt;&lt;endl; return 0; } } for(int i=1;i&lt;=m;++i){ int pos=0; while(v[pos+1][i]==1)pos++; if(pos!=b[i]){ cout&lt;&lt;0&lt;&lt;endl; return false; } } ll ans=1; // cerr&lt;&lt;\"debug \"&lt;&lt;endl; // for(int i=1;i&lt;=n;++i){ // for(int j=1;j&lt;=m;++j) // cout&lt;&lt;v[i][j]; // cout&lt;&lt;endl; // } for(int i=2;i&lt;=n;++i) for(int j=2;j&lt;=m;++j){ if(i&gt;b[j]+1&amp;&amp;j&gt;a[i]+1){ ans*=2; ans%=mod; } } cout&lt;&lt;ans&lt;&lt;endl; return 0;} Primes and Multiplication 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * author: MySakure * created: 30.09.2019 10:34:09 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll unsigned long long#define int unsigned long longconst int mod=1e9+7;ll x,n;int g[100];unsigned long long quickmod(unsigned long long a,unsigned long long b,unsigned long long m){ unsigned long long ans = 1; while(b)//用一个循环从右到左便利b的所有二进制位 { if(b&amp;1)//判断此时b[i]的二进制位是否为1 { ans = (ans*a)%m;//乘到结果上，这里a是a^(2^i)%m b--;//把该为变0 } b/=2; a = a*a%m; } return ans;}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;x&gt;&gt;n; int id=0; for(int i=2;i&lt;=sqrt(x)+0.5;++i){ if(x%i==0)g[++id]=i; while(x%i==0)x/=i; } if(x!=1)g[++id]=x; ll ans=1; for(int i=1;i&lt;=id;++i){ ll cur=g[i]; while(cur&lt;=n){ ans*=quickmod(cur%mod,n/cur-(n/cur&lt;g[i]?0:n/(cur*g[i])),mod); ans%=mod; //cerr&lt;&lt;\"hehe \"&lt;&lt;cur&lt;&lt;\" \"&lt;&lt;quickmod(cur,n/cur-(n/cur&lt;g[i]?0:n/(cur*g[i])),mod)&lt;&lt;endl; //cerr&lt;&lt;\"debug \"&lt;&lt;cur&lt;&lt;\" \"&lt;&lt;ans&lt;&lt;endl; if(n/g[i]&lt;cur)break; cur*=g[i]; } } cout&lt;&lt;ans&lt;&lt;endl; return 0;} Complete Tripartite 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * author: MySakure * created: 30.09.2019 09:56:07 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=1e5+10;set&lt;pair&lt;int,int&gt;&gt;s;int ans[maxn];int l[3*maxn],r[3*maxn];int id;ll cnt[10];signed main() { ios::sync_with_stdio(false); cin.tie(NULL); int n,m; cin&gt;&gt;n&gt;&gt;m; int x,y; if(m){ cin&gt;&gt;x&gt;&gt;y; l[++id]=x; r[id]=y; s.insert(mk(x,y)); s.insert(mk(y,x)); } rep(i,2,m){ int a,b; cin&gt;&gt;a&gt;&gt;b; l[++id]=a; r[id]=b; s.insert(mk(a,b)); s.insert(mk(b,a)); } if(m==0){ cout&lt;&lt;-1&lt;&lt;endl; return 0; } ans[x]=1,ans[y]=2; for(int i=1;i&lt;=n;++i){ if(ans[i])continue; bool flag1=s.count(mk(x,i)); bool flag2=s.count(mk(y,i)); if(flag1&amp;&amp;flag2)ans[i]=3; else if(flag1)ans[i]=2; else ans[i]=1; } for(int i=1;i&lt;=m;++i){ if(ans[l[i]]==ans[r[i]]){ cout&lt;&lt;-1&lt;&lt;endl; return 0; } } for(int i=1;i&lt;=n;++i)cnt[ans[i]]++; if(cnt[1]*cnt[2]+cnt[1]*cnt[3]+cnt[2]*cnt[3]!=m||!(cnt[1]&amp;&amp;cnt[2]&amp;&amp;cnt[3])){ cout&lt;&lt;-1&lt;&lt;endl; return 0; } for(int i=1;i&lt;=n;++i) cout&lt;&lt;ans[i]&lt;&lt;\" \"; cout&lt;&lt;endl; return 0;}","link":"/2019/10/CF1228/"},{"title":"CF1234","text":"CF1234 A Equalize Prices Again 1234567891011121314151617181920212223242526272829/** * author: MySakure * created: 01.10.2019 22:44:47 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longint q,n,s,tmp;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;q; while(q--){ cin&gt;&gt;n; s=0; rep(i,1,n){ cin&gt;&gt;tmp; s+=tmp; } cout&lt;&lt;(s+n-1)/n&lt;&lt;endl; } return 0;} B1 Social Network (easy version) 12345678910111213141516171819202122232425262728293031323334/** * author: MySakure * created: 01.10.2019 22:54:49 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=2e5+10;int a[maxn];set&lt;int&gt;s;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); int n,k,l=int(2e5),r=int(2e5); cin&gt;&gt;n&gt;&gt;k; rep(i,1,n){ int tmp; cin&gt;&gt;tmp; if(s.count(tmp))continue; a[--l]=tmp; s.insert(tmp); if(r-l&gt;k)s.erase(a[--r]); } cout&lt;&lt;r-l&lt;&lt;endl; rep(i,l,r-1)cout&lt;&lt;a[i]&lt;&lt;\" \"; cout&lt;&lt;endl; return 0;} B2 Social Network (hard version) 12345678910111213141516171819202122232425262728293031323334/** * author: MySakure * created: 01.10.2019 22:54:49 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=2e5+10;int a[maxn];set&lt;int&gt;s;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); int n,k,l=int(2e5),r=int(2e5); cin&gt;&gt;n&gt;&gt;k; rep(i,1,n){ int tmp; cin&gt;&gt;tmp; if(s.count(tmp))continue; a[--l]=tmp; s.insert(tmp); if(r-l&gt;k)s.erase(a[--r]); } cout&lt;&lt;r-l&lt;&lt;endl; rep(i,l,r-1)cout&lt;&lt;a[i]&lt;&lt;\" \"; cout&lt;&lt;endl; return 0;} C Pipes 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * author: MySakure * created: 01.10.2019 23:02:20 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longint q;const int maxn=2e5+10;int dp[3][maxn],n;char a[2][maxn];int dfs(int x,int y,int up){ //cerr&lt;&lt;\"debug \"&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;\" \"&lt;&lt;up&lt;&lt;endl; if(x==0&amp;&amp;y==n){ if(up==n){ if(a[0][n]&gt;'2')return true; else return false; } return a[0][n]&lt;='2'; } if(y==n+1)return false; dp[x][y]=1; if(a[x][y]&lt;='2'){ return dfs(x,y+1,y); } if(up==y){ return dfs(x,y+1,y); } return dfs(!x,y,y);}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;q; while(q--){ cin&gt;&gt;n; rep(i,1,n)cin&gt;&gt;a[1][i]; rep(i,1,n)cin&gt;&gt;a[0][i]; if(dfs(1,1,0))cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; } return 0;} D Distinct Characters Queries 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * author: MySakure * created: 01.10.2019 23:36:18 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long const int maxn=1e5+10;string s;int res[30],ans;struct node{ int l,r; int cnt[27]; node(){ rep(i,0,16)cnt[i]=0; }};node t[maxn&lt;&lt;2];int n,pos,l,r,c,q;void pushdown(int u){ rep(i,0,26)t[u].cnt[i]=t[u&lt;&lt;1].cnt[i]+t[u&lt;&lt;1|1].cnt[i];}void build(int u,int l,int r){ t[u].l=l,t[u].r=r; if(l==r){ t[u].cnt[s[l-1]-'a']++; return; } int mid=(l+r)&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r); pushdown(u);}void update(int u,int pos,char aim){ int l=t[u].l,r=t[u].r; if(l==r){ rep(i,0,26)t[u].cnt[i]=0; t[u].cnt[aim-'a']++; return; } int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)update(u&lt;&lt;1,pos,aim); else update(u&lt;&lt;1|1,pos,aim); pushdown(u);}void quere(int u,int L,int R){ int l=t[u].l,r=t[u].r; if(l==L&amp;&amp;R==r){ rep(i,0,26)res[i]+=t[u].cnt[i]; return; } int mid=(l+r)&gt;&gt;1; if(R&lt;=mid)quere(u&lt;&lt;1,L,R); else if(L&gt;mid)quere(u&lt;&lt;1|1,L,R); else { quere(u&lt;&lt;1,L,mid); quere(u&lt;&lt;1|1,mid+1,R); }}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;s; int n=s.size(); build(1,1,n); cin&gt;&gt;q; while(q--){ int cmd; cin&gt;&gt;cmd; if(cmd==1){ char aim; cin&gt;&gt;pos&gt;&gt;aim; update(1,pos,aim); } else{ //cerr&lt;&lt;\"debug\"&lt;&lt;q&lt;&lt;endl; rep(i,0,26)res[i]=0; cin&gt;&gt;l&gt;&gt;r; //cerr&lt;&lt;\"quere start\"&lt;&lt;endl; quere(1,l,r); ans=0; rep(i,0,26)ans+=(res[i]!=0); cout&lt;&lt;ans&lt;&lt;'\\n'; } } return 0;} E Special Permutations 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * author: MySakure * created: 02.10.2019 10:26:36 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long#define int long longconst int maxn=2e5+10;int q[maxn],ans,n,m,res[maxn],cnt[maxn];struct node{ int lazy,s; int l,r;}t[maxn&lt;&lt;2];void build(int u,int l,int r){ t[u].l=l,t[u].r=r; if(l==r)return; int mid=(l+r)&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r);}void pushdown(int u){ t[u&lt;&lt;1].lazy+=t[u].lazy,t[u&lt;&lt;1].s+=t[u].lazy; t[u&lt;&lt;1|1].lazy+=t[u].lazy,t[u&lt;&lt;1|1].s+=t[u].lazy; t[u].lazy=0;}void update(int u,int L,int R){ int l=t[u].l,r=t[u].r; if(l==L&amp;&amp;r==R){ t[u].s+=1; t[u].lazy+=1; return; } pushdown(u); int mid=(l+r)&gt;&gt;1; if(R&lt;=mid)update(u&lt;&lt;1,L,R); else if(L&gt;mid)update(u&lt;&lt;1|1,L,R); else{ update(u&lt;&lt;1,L,mid); update(u&lt;&lt;1|1,mid+1,R); }}int query(int u,int pos){ int l=t[u].l,r=t[u].r; if(l==r)return t[u].s; pushdown(u); int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)return query(u&lt;&lt;1,pos); else return query(u&lt;&lt;1|1,pos);}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n&gt;&gt;m; build(1,1,n); rep(i,1,m)cin&gt;&gt;q[i]; rep(i,1,m){ if(i==1)res[q[i]]+=abs(q[i]-q[1+i]); else if(i==m)res[q[i]]+=abs(q[i]-q[i-1]); else res[q[i]]+=abs(q[i]-q[i+1])+abs(q[i]-q[i-1]); } rep(i,1,m){ if(q[i]&gt;q[i-1])cnt[q[i]]+=q[i-1]; if(q[i]&lt;q[i-1])cnt[q[i]]+=q[i-1]-1; if(q[i]&gt;q[i+1])cnt[q[i]]+=q[i+1]; if(q[i]&lt;q[i+1])cnt[q[i]]+=q[i+1]-1; } rep(i,2,m){ ans+=abs(q[i]-q[i-1]); int l=min(q[i],q[i-1]),r=max(q[i],q[i-1]); if(r-l&gt;1){ update(1,l+1,r-1); } } cout&lt;&lt;ans&lt;&lt;\" \"; rep(i,2,n){ int tmp=ans; tmp-=query(1,i); //cerr&lt;&lt;\"debug \"&lt;&lt;tmp&lt;&lt;\" \"&lt;&lt;res[i]&lt;&lt;\" \"&lt;&lt;cnt[i]&lt;&lt;endl; tmp-=res[i]; tmp+=cnt[i]; cout&lt;&lt;tmp&lt;&lt;\" \"; } cout&lt;&lt;endl; return 0;}","link":"/2019/10/CF1234/"},{"title":"Codeforces Round #584","text":"#584 E1,E2,F,G1,G2,H 未补 A. Paint the Numbers暴力 1234567891011121314151617181920212223242526272829303132/** * author: MySakure * created: 14.09.2019 20:59:58 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long const int maxn=110;int a[maxn],vis[maxn],ans;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); int n; cin&gt;&gt;n; rep(i,1,n)cin&gt;&gt;a[i]; sort(a+1,a+1+n); rep(i,1,n){ if(vis[i])continue; ans++;vis[i]=true; for(int j=i;j&lt;=n;++j) if(a[j]%a[i]==0)vis[j]=true; } cout&lt;&lt;ans&lt;&lt;endl; return 0;} B. Koala and Lights枚举开灯后的$10000$分钟，枚举统计暴力 12345678910111213141516171819202122232425262728293031323334353637383940/** * author: MySakure * created: 14.09.2019 21:00:03 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long const int maxn=110;int s[maxn],a[maxn],b[maxn];signed main() { ios::sync_with_stdio(false); cin.tie(NULL); int n; cin&gt;&gt;n; int ans=0; rep(i,1,n){ char tmp; cin&gt;&gt;tmp; s[i]=tmp-'0'; if(s[i])ans++; } rep(i,1,n){ cin&gt;&gt;a[i]&gt;&gt;b[i]; } for(int i=1;i&lt;=10000;++i){ int curans=0; for(int j=1;j&lt;=n;++j){ if(i&gt;=b[j]&amp;&amp;(i-b[j])%a[j]==0)s[j]=!s[j]; if(s[j])curans++; } ans=max(ans,curans); } cout&lt;&lt;ans&lt;&lt;endl; return 0;} C. Paint the Digitsemmm,这题当时比赛的时候没调动，疯狂细节错。赛后调出来 针对当前数进行讨论，如果右边有比当前数小的，那么当前数肯定是2，如果左边有比当前数大的，那么当前数肯定是1.这样针对每个数讨论一遍，这样一遍只能确定某些颜色。 然后从后往前疯狂维护判断上述没确定颜色的地方的颜色（具体代码），是真滴难搞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * author: MySakure * created: 14.09.2019 21:00:09 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long const int maxn=2e5+10;vector&lt;int&gt;v1,v2;int t,n,a[maxn],mark[maxn];int dpb[maxn][3];int check(){ int l1=v1.size(),l2=v2.size(); for(int i=0;i&lt;l1-1;++i){ if(v1[i]&gt;v1[i+1])return false; } if(!v1.empty()&amp;&amp;!v2.empty()&amp;&amp;v1[l1-1]&gt;v2[0])return false; for(int i=0;i&lt;l2-1;++i){ if(v2[i]&gt;v2[i+1])return false; } return true;}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; rep(i,1,n){ char tmp; cin&gt;&gt;tmp; a[i]=tmp-'0'; } rep(i,1,n)mark[i]=0; int Min=a[n]; for(int i=n;i&gt;=1;--i){ if(a[i]&gt;Min)mark[i]=2; Min=min(Min,a[i]); } bool flag=true; int Max=a[1]; for(int i=1;i&lt;=n;++i){ if(Max&gt;a[i]){ if(mark[i]==2){ flag=false; break; } mark[i]=1; } Max=max(Max,a[i]); } if(!flag){ cout&lt;&lt;'-'&lt;&lt;endl; continue; } dpb[n+1][1]=10,dpb[n+1][2]=10; for(int i=n;i&gt;=1;--i){ dpb[i][1]=dpb[i+1][1],dpb[i][2]=dpb[i+1][2]; if(mark[i]==1){ if(a[i]&gt;dpb[i][1]){ flag=false; break; } else dpb[i][1]=a[i]; } if(mark[i]==2){ if(a[i]&gt;dpb[i][2]){ flag=false; break; } else dpb[i][2]=a[i]; } } if(!flag){ cout&lt;&lt;'-'&lt;&lt;endl; continue; } int Max1=0,Min2=10; v1.clear(),v2.clear(); for(int i=1;i&lt;=n;++i){ if(mark[i]==1){ v1.push_back(a[i]); Max1=a[i]; } else if(mark[i]==2){ v2.push_back(a[i]); Min2=min(Min2,a[i]); } else{ if(a[i]&gt;=Max1&amp;&amp;a[i]&lt;=dpb[i][1]&amp;&amp;a[i]&lt;=Min2){ v1.push_back(a[i]); mark[i]=1; } else { v2.push_back(a[i]); mark[i]=2; } } } if(check()){ for(int i=1;i&lt;=n;++i) cout&lt;&lt;mark[i]; cout&lt;&lt;endl; } else cout&lt;&lt;'-'&lt;&lt;endl; } return 0;} D. Cow and Snacks并查集，emm，不好解释 1234567891011121314151617181920212223242526272829303132/** * author: MySakure * created: 15.09.2019 07:40:37 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=1e5+10;int fa[maxn],n,k;int get(int u){return fa[u]==u?u:fa[u]=get(fa[u]);}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n&gt;&gt;k; rep(i,1,n)fa[i]=i; int ans=0; rep(i,1,k){ int a,b; cin&gt;&gt;a&gt;&gt;b; int af=get(a),bf=get(b); if(af==bf)ans++; else fa[af]=bf; } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2019/09/Codeforces-Round-584/"},{"title":"Codeforces Round #585 (Div. 2)","text":"Codeforces Round #585 (Div. 2) E F 待补 A. Yellow Cards简单思维题 1234567891011121314151617181920212223242526272829303132/** * author: MySakure * created: 15.09.2019 18:29:01 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longint a1,a2,k1,k2,n;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;a1&gt;&gt;a2&gt;&gt;k1&gt;&gt;k2&gt;&gt;n; if(k1&lt;k2){ swap(k1,k2); swap(a1,a2); } int Min,Max; if(n&lt;=a2*k2)Max=n/k2; else Max=a2+(n-a2*k2)/k1; n-=a1*(k1-1)+a2*(k2-1); Min=max(0,n); cout&lt;&lt;Min&lt;&lt;\" \"&lt;&lt;Max&lt;&lt;endl; return 0;} B. The Number of Products$dp[i][0]$代表以第$i$结尾的正数有多少个，$dp[i][1]$代表以第$i$结尾的负数有多少个。 1234567891011121314151617181920212223242526272829303132333435/** * author: MySakure * created: 15.09.2019 18:49:19 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=2e5+10;ll a[maxn],n,ans[2],dp[maxn][2];signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n; rep(i,1,n)cin&gt;&gt;a[i]; rep(i,1,n){ if(a[i]&gt;0){ dp[i][0]+=dp[i-1][0]+1; dp[i][1]+=dp[i-1][1]; } else{ dp[i][0]+=dp[i-1][1]; dp[i][1]+=dp[i-1][0]+1; } ans[0]+=dp[i][0]; ans[1]+=dp[i][1]; } cout&lt;&lt;ans[1]&lt;&lt;\" \"&lt;&lt;ans[0]&lt;&lt;endl; return 0;} C. Swap Letters$a b$肯定是和$a b$换，$b a$肯定是和$b a$换，这样可以保证一次交换可以纠正两个位置。当$a b$个数不是偶数时，如果有答案，那么$b a$肯定也是奇数，所以需要两次交换纠正这两个位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * author: MySakure * created: 15.09.2019 18:54:56 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=2e5+10;char a[maxn],b[maxn];int n,res;vector&lt;int&gt;ansa,ansb;int ans;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n; rep(i,1,n){ cin&gt;&gt;a[i]; res+=(a[i]=='a'); } rep(i,1,n){ cin&gt;&gt;b[i]; res+=(b[i]=='a'); } if(res&amp;1){ cout&lt;&lt;-1&lt;&lt;endl; return 0; } int numab=0,numba=0; for(int i=1;i&lt;=n;++i){ if(a[i]=='a'&amp;&amp;b[i]=='b'){ ansa.push_back(i); numab++; } if(a[i]=='b'&amp;&amp;b[i]=='a'){ numba++; ansb.push_back(i); } } ans+=numab/2; ans+=numba/2; if(numab&amp;1){ ans+=2; } cout&lt;&lt;ans&lt;&lt;endl; for(int i=1;i&lt;int(ansa.size());i+=2){ cout&lt;&lt;ansa[i-1]&lt;&lt;\" \"&lt;&lt;ansa[i]&lt;&lt;endl; } for(int i=1;i&lt;int(ansb.size());i+=2){ cout&lt;&lt;ansb[i-1]&lt;&lt;\" \"&lt;&lt;ansb[i]&lt;&lt;endl; } if(numab&amp;1){ cout&lt;&lt;ansa.back()&lt;&lt;\" \"&lt;&lt;ansa.back()&lt;&lt;endl; cout&lt;&lt;ansa.back()&lt;&lt;\" \"&lt;&lt;ansb.back()&lt;&lt;endl; } return 0;} D. Ticket Gameemmm,这个东西有点玄学，有点想法然后猜结论就过了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * author: MySakure * created: 15.09.2019 19:41:49 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=2e5+10;char a[maxn];int n,res1,res2,s1,s2;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n; rep(i,1,n)cin&gt;&gt;a[i]; rep(i,1,n/2){ res1+=(a[i]=='?'); if(a[i]&lt;='9'&amp;&amp;a[i]&gt;='0')s1+=a[i]-'0'; } rep(i,n/2+1,n){ res2+=(a[i]=='?'); if(a[i]&lt;='9'&amp;&amp;a[i]&gt;='0')s2+=a[i]-'0'; } if(res1==res2){ if(s1==s2){ cout&lt;&lt;\"Bicarp\"&lt;&lt;endl; } else cout&lt;&lt;\"Monocarp\"&lt;&lt;endl; return 0; } if(s1==s2){ cout&lt;&lt;\"Monocarp\"&lt;&lt;endl; return 0; } if((s1&lt;s2&amp;&amp;res1&lt;res2)||(s1&gt;s2&amp;&amp;res1&gt;res2)){ cout&lt;&lt;\"Monocarp\"&lt;&lt;endl; return 0; } int d=abs(s1-s2),num=abs(res1-res2); //cerr&lt;&lt;\"debug \"&lt;&lt;d&lt;&lt;\" \"&lt;&lt;num&lt;&lt;endl; if((num/2)*9==d)cout&lt;&lt;\"Bicarp\"&lt;&lt;endl; else cout&lt;&lt;\"Monocarp\"&lt;&lt;endl; return 0;}","link":"/2019/09/Codeforces-Round-585-Div-2/"},{"title":"Codeforces Round #598 (Div. 3)","text":"我会做的几道题目里，思维难度都很低，但是好像。。。代码有点难调啊 Payment Without Change 1234567891011121314151617181920212223242526/** * author: MySakure * created: 04.11.2019 22:00:19 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint q;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;q; int a,b,c,d; while(q--){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; if(a*c&gt;=d){ if(b&gt;=d%c)cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; } else{ if(b&gt;=d-a*c)cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; } } return 0;} Minimize the Permutation 1234567891011121314151617181920212223242526272829303132333435363738394041/** * author: MySakure * created: 04.11.2019 22:06:44 **/#include&lt;bits/stdc++.h&gt;using namespace std;int t;const int maxn=110;int a[maxn],res[maxn];signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;t; while(t--){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;++i)res[i]=0; int l=1,r=1,cur=1; while(l&lt;n){ while(res[cur])++cur; res[cur]=1; if(a[l]==cur){ ++l;++r; continue; } while(a[r]!=cur){ res[a[r]]=1; ++r; } for(int i=r;i&gt;l;--i)a[i]=a[i-1]; a[l]=cur; l=r; res[a[l]]=0; } for(int i=1;i&lt;=n;++i)cout&lt;&lt;a[i]&lt;&lt;\" \"; cout&lt;&lt;'\\n'; } return 0;} Platforms Jumping 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * author: MySakure * created: 05.11.2019 08:58:13 **/#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e3+10;int res[maxn],n,m,d,s[maxn];signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n&gt;&gt;m&gt;&gt;d; for(int i=1;i&lt;=m;++i){ cin&gt;&gt;res[i]; s[i]=s[i-1]+res[i]; } if(s[m]&gt;n||s[m]+2+(m+1)*(d-1)&lt;n+2){ cout&lt;&lt;\"NO\"&lt;&lt;'\\n'; return 0; } cout&lt;&lt;\"YES\"&lt;&lt;endl; int pos=n+1,cnt=m; //cout&lt;&lt;\"hello \"&lt;&lt;s[cnt-1]+cnt*(d-1)&lt;&lt;endl; while(cnt&gt;0&amp;&amp;s[cnt-1]+cnt*(d-1)+1&gt;=pos-res[cnt]){ pos-=res[cnt--]; } for(int i=1;i&lt;cnt;++i){ for(int i=1;i&lt;=d-1;++i) cout&lt;&lt;0&lt;&lt;\" \"; for(int j=1;j&lt;=res[i];++j) cout&lt;&lt;i&lt;&lt;\" \"; } //cout&lt;&lt;\"debug \"&lt;&lt;pos&lt;&lt;\" \"&lt;&lt;cnt&lt;&lt;endl; for(int i=1;i&lt;=(pos-s[cnt]-(cnt==0?0:(cnt-1)*(d-1))-1)/2;++i) cout&lt;&lt;0&lt;&lt;\" \"; for(int i=1;i&lt;=res[cnt];++i)cout&lt;&lt;cnt&lt;&lt;\" \"; for(int i=1;i&lt;=(pos-s[cnt]-(cnt==0?0:(cnt-1)*(d-1)))/2;++i) cout&lt;&lt;0&lt;&lt;\" \"; for(int i=cnt+1;i&lt;=m;++i){ for(int j=1;j&lt;=res[i];++j) cout&lt;&lt;i&lt;&lt;\" \"; } cout&lt;&lt;'\\n'; return 0;} Binary String Minimizing 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * author: MySakure * created: 04.11.2019 22:43:32 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=1e6+10;#define int long longll t,n,k;int a[maxn],dp[maxn],vis[maxn],res[maxn],id;char tmp;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;tmp; a[i]=tmp-'0'; } for(int i=1;i&lt;=n;++i)vis[i]=0; a[n+1]=dp[n+1]=-1; for(int i=n;i&gt;=0;--i) dp[i]=a[i+1]==0?i+1:dp[i+1]; int inx=0,cnt=0; bool flag=false; while(dp[inx]!=-1&amp;&amp;k){ inx=dp[inx]; if(k&gt;=inx-cnt-1){ vis[inx]=1; k-=(inx-cnt-1); ++cnt; } else { flag=true; break; } } for(int i=1;i&lt;=cnt;++i)cout&lt;&lt;0; id=0; for(int i=1;i&lt;=n;++i)if(!vis[i])res[++id]=a[i]; if(!flag){ for(int i=1;i&lt;=id;++i)cout&lt;&lt;res[i]; cout&lt;&lt;'\\n'; continue; } int pos=1; while(res[pos]!=0)++pos; swap(res[pos],res[pos-k]); for(int i=1;i&lt;=id;++i)cout&lt;&lt;res[i]; cout&lt;&lt;\"\\n\"; } return 0;}","link":"/2019/11/Codeforces-Round-598-Div-3/"},{"title":"Coloring Edges","text":"D. Coloring Edges You are given a directed graph with nn vertices and mm directed edges without self-loops or multiple edges. Let’s denote the kk-coloring of a digraph as following: you color each edge in one of kk colors. The kk-coloring is good if and only if there no cycle formed by edges of same color. Find a good kk-coloring of given digraph with minimum possible kk. Input The first line contains two integers nn and mm (2≤n≤50002≤n≤5000, 1≤m≤50001≤m≤5000) — the number of vertices and edges in the digraph, respectively. Next mm lines contain description of edges — one per line. Each edge is a pair of integers uu and vv (1≤u,v≤n1≤u,v≤n, u≠vu≠v) — there is directed edge from uu to vv in the graph. It is guaranteed that each ordered pair (u,v)(u,v) appears in the list of edges at most once. Output In the first line print single integer kk — the number of used colors in a good kk-coloring of given graph. In the second line print mm integers c1,c2,…,cmc1,c2,…,cm (1≤ci≤k1≤ci≤k), where cici is a color of the ii-th edge (in order as they are given in the input). If there are multiple answers print any of them (you still have to minimize kk). Examples input Copy 1234564 51 21 33 42 41 4 output Copy 1211 1 1 1 1 input Copy 12343 31 22 33 1 output Copy 1221 1 2 思路： 有向图成为一个环时，总会存在一个下标小的点指向下标大的点的路和一条下标大的指向下标小的点的路，只要把这两条路的颜色染色为不同就可以了。(抄袭的某大佬思路，源地址找不到了)，所以就变成了简单的判断是否存在环的问题。如果存在环的话，就把小指向大的路染为1，大点指向小点的路染为2就可以了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=5e3+7;vector&lt;int&gt;g[maxn];int n,m;int vis[maxn];int x[maxn],y[maxn];int dfs(int u){ if(vis[u]==-1)return true; if(vis[u])return false; vis[u]=-1; for(int i=0;i&lt;int(g[u].size());++i){ int v=g[u][i]; if(dfs(v))return true; } vis[u]=1; return false;}signed main(){ ios::sync_with_stdio(NULL); cin.tie(nullptr); //freopen(\"in\", \"r\", stdin); //freopen(\"out.txt\", \"w\", stdout); cin&gt;&gt;n&gt;&gt;m; rep(i,1,m){ int a,b; cin&gt;&gt;a&gt;&gt;b; x[i]=a,y[i]=b; g[a].push_back(b); } for(int i=1;i&lt;=n;++i){ if(vis[i])continue; if(dfs(i)){ cout&lt;&lt;2&lt;&lt;endl; for(int i=1;i&lt;=m;++i)cout&lt;&lt;int(x[i]&gt;y[i])+1&lt;&lt;\" \"; cout&lt;&lt;endl; return 0; } } cout&lt;&lt;1&lt;&lt;endl; rep(i,1,m){ cout&lt;&lt;1&lt;&lt;\" \"; } cout&lt;&lt;endl; return 0;}","link":"/2019/09/Coloring%20Edges/"},{"title":"Comet OJ - 2019国庆欢乐赛","text":"Comet OJ - 2019国庆欢乐赛 A 如果四边形右上角严格位于第一象限，那么第一象限必定有两部分。如果左上角严格位于第二象限，那么第二象限必定有两部分，同理可得。 1234567891011121314151617181920212223242526272829303132333435363738/** * author: MySakure * created: 01.10.2019 19:02:47 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longint t;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;t; while(t--){ int a,b,c,d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; int ans=0; if(c&gt;0&amp;&amp;d&gt;0)ans+=2; else ans+=1; if(a&lt;0&amp;&amp;d&gt;0)ans+=2; else ans+=1; if(a&lt;0&amp;&amp;b&lt;0)ans+=2; else ans+=1; if(c&gt;0&amp;&amp;b&lt;0)ans+=2; else ans+=1; cout&lt;&lt;ans&lt;&lt;endl; } return 0;} B 用四个小的去消耗大的。如果不能消耗完，那么结果显而易见。如果消耗完了，那么一个存在一个合适的策略使四个小的内部消耗达到最优策略。 123456789101112131415161718192021222324252627/** * author: MySakure * created: 01.10.2019 19:07:52 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longll a[10];signed main() { ios::sync_with_stdio(false); cin.tie(NULL); rep(i,1,5)cin&gt;&gt;a[i]; sort(a+1,a+1+5); reverse(a+1,a+6); if(a[2]+a[3]+a[4]+a[5]&lt;=a[1]){ cout&lt;&lt;a[2]+a[3]+a[4]+a[5]&lt;&lt;endl; return 0; } cout&lt;&lt;(a[2]+a[3]+a[4]+a[5]-a[1])/2+a[1]&lt;&lt;endl; return 0;} C 前缀和，有几个已经开始的，减去彻底结束的，就是答案。 我一开始竟然用莫队，也是疯了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn = 2e5+10;inline int read(){ int x=0,f=1;char ch=getchar(); while(ch&gt;'9'||ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}vector&lt;int&gt;v;int getid(int cur){return lower_bound(v.begin(),v.end(),cur)-v.begin()+1;}int c[maxn&lt;&lt;3][2],a[maxn],b[maxn];ll pos[maxn],Ans;ll ans,n,m;struct query{ int l,r,id;}Q[maxn];bool cmp(query a,query b){ if(pos[a.l]==pos[b.l]) return a.r&lt;b.r; return pos[a.l]&lt;pos[b.l];}int main(){ n=read(),m=read(); for(int i=1;i&lt;=n;++i){ a[i]=read(),b[i]=read(); v.push_back(a[i]),v.push_back(b[i]); } for(int i=1;i&lt;=m;i++) { Q[i].l=read(); Q[i].r=read(); v.push_back(Q[i].l),v.push_back(Q[i].r); Q[i].id = i; } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); for(int i=1;i&lt;=m;i++)Q[i].l=getid(Q[i].l),Q[i].r=getid(Q[i].r); for(int i=1;i&lt;=n;++i)c[getid(b[i])][1]++,c[getid(a[i])][0]++; int R=v.size(); for(int i=1;i&lt;=R;++i){ c[i][0]+=c[i-1][0]; c[i][1]+=c[i-1][1]; } for(int i=1;i&lt;=m;++i){ ans+=c[Q[i].r][0]-c[Q[i].l-1][1]; } cout&lt;&lt;ans&lt;&lt;endl; return 0;} E 莫名的我看着就像一张无向图。 在一个关系图中，增加一个关系只能有几种可能： 加在两个有奇数个朋友的中，有奇数个数的朋友-2。有奇数朋友的人的个数的奇偶性不变 加在一个有奇数朋友的人和一个有偶数朋友的人中，奇数变偶数，偶数变奇数。有奇数朋友的人的个数的奇偶性不变 加在两个有偶数朋友的人中，有奇数个数的朋友+2。有奇数朋友的人的个数的奇偶性不变 由于一开始有奇数朋友的人的个数为0，所以最后一定是偶数，k是奇数时不可能的。 加关系是困难的，于是考虑在一个完全图中减边。 一条边如果利用的好，可以更改两个人的奇偶属性。完全图里，如果一开始每个人是奇数个好友，考虑删边变为偶数。反之亦然。 1234567891011121314151617181920212223242526272829/** * author: MySakure * created: 01.10.2019 20:30:11 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longint t;ll n,k;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;t; while(t--){ cin&gt;&gt;n&gt;&gt;k; if(k&gt;n||k%2==1){ cout&lt;&lt;\"renrendoushijwj\"&lt;&lt;endl; continue; } if(n&amp;1)cout&lt;&lt;n*(n-1)/2-k/2&lt;&lt;endl; else cout&lt;&lt;n*(n-1)/2-(n-k)/2&lt;&lt;endl; } return 0;}","link":"/2019/10/Comet-OJ-2019/"},{"title":"D. Shortest Cycle","text":"D. Shortest Cycle time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output You are given nn integer numbers a1,a2,…,ana1,a2,…,an. Consider graph on nn nodes, in which nodes ii, jj (i≠ji≠j) are connected if and only if, aiaiAND aj≠0aj≠0, where AND denotes the bitwise AND operation. Find the length of the shortest cycle in this graph or determine that it doesn’t have cycles at all. Input The first line contains one integer nn (1≤n≤105)(1≤n≤105) — number of numbers. The second line contains nn integer numbers a1,a2,…,ana1,a2,…,an (0≤ai≤10180≤ai≤1018). Output If the graph doesn’t have any cycles, output −1−1. Else output the length of the shortest cycle. Examples input Copy 1243 6 28 9 output Copy 14 input Copy 1255 12 9 16 48 output Copy 13 input Copy 1241 2 4 8 output Copy 1-1 Note In the first example, the shortest cycle is (9,3,6,28)(9,3,6,28). In the second example, the shortest cycle is (5,12,9)(5,12,9). The graph has no cycles in the third example. 1205B - Shortest Cycle官方题解：The most important thing in this task is to notice that if any bit is contained at least $3$ numbers, then they will form a cycle of length $3$, and the answer is $3$. Suppose now that each bit is in no more than two numbers. It follows that each bit can be shared by at most one pair of numbers. From here we get that in the graph there are no more than 6060 edges. Then in it you can find the shortest cycle in $O(m2)$: for each edge between the vertices $u$ and $v$ we will try to remove it and find the shortest distance between the vertices $u$, $v$ in the resulting graph. If each time uu and $v$ turned out to be in different components, then there is no cycle in the graph, otherwise its length is 11 + the minimal of the distances found. Asymptotics$O(n \\log{18}+60^2)$ 理解：无环的情况下，每个二进制位最多可以在所有数字中出现两次，如果出现第三次，那么就一定会形成一个长度为$3$的环。二进制位一共六十位左右。在数字不会出现环的情况下，最多的数字个数不会出现二进制位的个数$*2$个（0要特判，除外） 。在数字个数超过一定范围的情况下，一定会出现大小为$3$的环，并且这个个数绝对不会超过两百。利用Floyd求解最小环的知识 Code:1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long const int inf=1e9;const int maxn=1e5+10;const int maxm=500;ll mp[maxm][maxm],dis[maxm][maxm],n;ll a[maxn],ans=inf;signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin&gt;&gt;n; rep(i,1,n)cin&gt;&gt;a[i]; sort(a+1,a+1+n); reverse(a+1,a+1+n); n=min(n,300*1ll); rep(i,1,n) rep(j,1,n) if(a[i]&amp;a[j])mp[i][j]=dis[i][j]=1; else mp[i][j]=dis[i][j]=inf; rep(k,1,n){ rep(i,1,k-1) rep(j,i+1,k-1) ans=min(ans,dis[i][j]+mp[i][k]+mp[k][j]); rep(i,1,n) rep(j,1,n) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); } cout&lt;&lt;(ans&gt;=inf?-1:ans)&lt;&lt;endl; return 0;} 无向图最小环求解方法： 以下内容摘自：Floyd求解最小环 OI Wiki 暴力解法¶设 $u$和$v$ 之间有一条边长为 $w$的边，$dis(u,v)$ 表示删除$u$ 和$v$ 之间的连边之后，$u$ 和$v$ 之间的最短路。 那么最小环是$dis(u,v)+w$ 。 总时间复杂度$O(n^2m)$ 。 Dijkstra¶枚举所有边，每一次求删除一条边之后对这条边的起点跑一次 $Dijkstra$，道理同上。 时间复杂度$O(m(n+m)\\lg{n})$ 。 Floyd¶记原图中$u,v$ 之间边的边权为$val(u,v)$ 。 我们注意到 Floyd 算法有一个性质：在最外层循环到点$k$ 时（尚未开始第$k$ 次循环），最短路数组 $dis$ 中， $dis_{u,v}$ 表示的是从 $u$到 $v$ 且仅经过编号在$[1,k)$ 区间中的点的最短路。 由最小环的定义可知其至少有三个顶点，设其中编号最大的顶点为 $w$ ，环上与$w$ 相邻两侧的两个点为 $u,v$ ，则在最外层循环枚举到$k=w$ 时，该环的长度即为 $dis_{u,v}+val(v,w)+val(w,u)$ 。 故在循环时对于每个 $k$枚举满足$i&lt;k,j&lt;k$ 的 $(i,j)$ ，更新答案即可。 时间复杂度：$O(n^3)$ 下面给出 C++ 的参考实现：1234567891011121314151617int val[maxn + 1][maxn + 1]; // 原图的邻接矩阵inline int floyd(const int &amp;n) { static int dis[maxn + 1][maxn + 1]; // 最短路矩阵 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) dis[i][j] = val[i][j]; // 初始化最短路矩阵 int ans = inf; for (int k = 1; k &lt;= n; ++k) { for (int i = 1; i &lt; k; ++i) for (int j = 1; j &lt; i; ++j) ans = std::min(ans, dis[i][j] + val[i][k] + val[k][j]); // 更新答案 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) dis[i][j] = std::min( dis[i][j], dis[i][k] + dis[k][j]); // 正常的 floyd 更新最短路矩阵 } return ans;}","link":"/2019/08/D-Shortest-Cycle/"},{"title":"D1 - Kirk and a Binary String (easy version)","text":"https://codeforces.com/contest/1204/problem/D2 大佬题解题解从后向前，保证后面的解都是合法的情况下如果当前位置的数字是 $0$那么，他一定是后面以他为起点的区间的 $LIS$ 的一部分，这就要求 $T$ 的对应位置必须为 $0$, 否则 $LIS$ 长度必然减少 如果当前位置的数字为 $1$考虑，以他为起点的所有区间对于那些 $LIS$ 包含它的区间，就是说 $LIS$ 的首项为 $1$ 的区间，他变为$0$，对这些区间的 $LIS$ 没有影响（他们的 $LIS$ 长度为 $1$ 的个数）对于那些 $LIS$ 不包含他的区间，就是说 $LIS$ 的首项为 $0$ 的区间，他变为 $0$，对这些区间的 $LIS$ 会改变 换句话说，若想将 $1$ 变为$ 0 $，必须保证后面所有的区间的 $LIS$ 长度必须和 $1$ 的个数相等！！！ 所以，从后向前统计$ 0$ 和 $1$ 的数量，当 $1$ 的个数大于等于 $0$ 的个数时，才可以修改 Code：123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longstring s;int cnt=0;signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin&gt;&gt;s; for(int i=s.size()-1;i&gt;=0;--i){ if(s[i]=='0')cnt++; else if(cnt)cnt--; else s[i]='0'; } cout&lt;&lt;s&lt;&lt;endl; return 0;}","link":"/2019/08/D1-Kirk-and-a-Binary-String-easy-version/"},{"title":"D2 - RGB Substring (hard version)","text":"https://codeforces.com/contest/1196/problem/D2 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std; const int maxn=2e5+10;int dp[3];char a[maxn],st[3]={'B','R','G'};int n,k,q,ans;void Flush(int i,int v){ if(a[i]!=st[i%3])dp[0]+=v; if(a[i]!=st[(i%3+1)%3])dp[1]+=v; if(a[i]!=st[(i%3+2)%3])dp[2]+=v;}int main(){ ios::sync_with_stdio(NULL); cin.tie(nullptr),cout.tie(nullptr); cin&gt;&gt;q; while(q--){ cin&gt;&gt;n&gt;&gt;k; dp[0]=dp[1]=dp[2]=0; for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i]; for(int i=1;i&lt;=k;++i)Flush(i,1); int r=k+1; ans=min(dp[0],min(dp[1],dp[2])); while(r&lt;=n){ Flush(r,1); Flush(r-k,-1); ++r; ans=min(ans,min(dp[0],min(dp[1],dp[2]))); } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2019/08/D2-RGB-Substring-hard-version/"},{"title":"Educational Codeforces Round 67","text":"Educational Codeforces Round 67(Rated for Div2) A-Stickers and Toys 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long int t,a,b,c;int main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin&gt;&gt;t; while(t--){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; int tmp=b+c-a; cout&lt;&lt;max(b,c)-tmp+1&lt;&lt;endl; } return 0;} B-Letters Shop12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long const int maxn=2e5+10;int n,m,num[maxn][50];char arr[maxn];int c[50];int main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i)cin&gt;&gt;arr[i]; for(int i=n-1;i&gt;=0;--i) for(int j=0;j&lt;=26;++j){ if(j==arr[i+1]-'a')num[i][j]=i+1; else num[i][j]=num[i+1][j]; } cin&gt;&gt;m; while(m--){ string str; cin&gt;&gt;str; for(int i=0;i&lt;=30;++i)c[i]=0; for(int i=0;i&lt;str.size();++i)c[str[i]-'a']++; int ans=0; for(int i=0;i&lt;30;++i){ if(c[i]==0)continue; int inx=0; while(c[i]--)inx=num[inx][i]; ans=max(ans,inx); } cout&lt;&lt;ans&lt;&lt;endl; } return 0;} C-Vasya And Array 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long const int maxn=1e3+10;int v[maxn],fa[maxn],n,m,t,l,r,Ri[maxn],num,na[maxn],nb[maxn];int main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i)fa[i]=i,Ri[i]=i; while(m--){ cin&gt;&gt;t&gt;&gt;l&gt;&gt;r; if(t==0){ na[++num]=l; nb[num]=r; continue; } int tmpl=min(fa[l],l); int tmpr=max(Ri[r],r); for(int i=tmpl;i&lt;=tmpr;++i){ fa[i]=tmpl; Ri[i]=tmpr; } } for(int i=1;i&lt;=num;++i){ if(fa[na[i]]==fa[nb[i]]){ //cerr&lt;&lt;na[i]&lt;&lt;\" \"&lt;&lt;nb[i]&lt;&lt;endl; //cerr&lt;&lt;fa[na[i]]&lt;&lt;\" \"&lt;&lt;fa[nb[i]]&lt;&lt;endl; cout&lt;&lt;\"no\"&lt;&lt;endl; return 0; } } int inx=1500; cout&lt;&lt;\"yes\"&lt;&lt;endl; for(int i=1;i&lt;=n;++i) if(fa[i]==i)cout&lt;&lt;--inx&lt;&lt;\" \"; else cout&lt;&lt;inx&lt;&lt;\" \"; cout&lt;&lt;endl; return 0;}","link":"/2019/07/Educational-Codeforces-Round-67/"},{"title":"Educational Codeforces Round 67Codeforces-Round-572-Div-2","text":"Codeforces Round #572 (Div. 2) A.Keanu Reeves 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std; const int maxn=110;char vec[maxn];int a,b,n;int main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;vec[i]; if(vec[i]=='0')a++; else b++; } if(a!=b){ cout&lt;&lt;\"1\"&lt;&lt;endl; for(int i=1;i&lt;=n;++i) cout&lt;&lt;vec[i]; cout&lt;&lt;endl; return 0; } cout&lt;&lt;2&lt;&lt;endl; cout&lt;&lt;vec[1]&lt;&lt;\" \"; for(int i=2;i&lt;=n;++i) cout&lt;&lt;vec[i]; cout&lt;&lt;endl; return 0;} B. Number Circle123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std; const int maxn=1e5+10;int n,vec[2*maxn],arr[2*maxn];bool cmp(const int &amp;a,const int&amp;b){ return a&lt;b;}int main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i)cin&gt;&gt;arr[i]; sort(arr+1,arr+1+n,cmp); int inxl=maxn,inxr=maxn; vec[maxn]=arr[1]; for(int i=2;i&lt;=n;i+=2){ vec[--inxl]=arr[i]; if(i&lt;n)vec[++inxr]=arr[i+1]; } for(int i=inxl+1;i&lt;inxr;++i)if(vec[i]&gt;=vec[i-1]+vec[i+1]){ cout&lt;&lt;\"NO\"&lt;&lt;endl; return 0; } if(vec[inxr]&gt;=vec[inxr-1]+vec[inxl]||vec[inxl]&gt;=vec[inxr]+vec[inxl+1]){ cout&lt;&lt;\"NO\"&lt;&lt;endl; return 0; } cout&lt;&lt;\"YES\"&lt;&lt;endl; for(int i=inxl;i&lt;=inxr;++i) cout&lt;&lt;vec[i]&lt;&lt;\" \"; cout&lt;&lt;endl; return 0;}C C. Candies!12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std; const int maxn=1e5+10;int n,q,l,r,vec[maxn];int main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;vec[i]; vec[i]+=vec[i-1]; } cin&gt;&gt;q; while(q--){ cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;(vec[r]-vec[l-1])/10&lt;&lt;endl; } return 0;} D1. Add on a Tree123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std; const int maxn=2e5+10;int n,a[maxn],b[maxn],num,vis[maxn],judge[maxn]; int main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;n; for(int i=1;i&lt;n;++i){ cin&gt;&gt;a[i]&gt;&gt;b[i]; vis[a[i]]++,vis[b[i]]++; } for(int i=1;i&lt;=n;++i) if(vis[i]==2){ cout&lt;&lt;\"NO\"&lt;&lt;endl; return 0; } cout&lt;&lt;\"YES\"&lt;&lt;endl; return 0;}","link":"/2019/07/Educational-Codeforces-Round-67Codeforces-Round-572-Div-2/"},{"title":"Flashing Fluorescents","text":"Problem CFlashing FluorescentsYou have n lights, each with its own button, in a line. Pressing a light’s button will toggle thatlight’s state; if the light is on, it will turn off, and if the light is off, it will turn on. The lightschange at 1 second timesteps. You can press a button at any time, but it will not take effect untilthe next timestep. Before each timestep, you may choose to push at most one button (you may alsochoose to not press any button). Pushing a button will affect not just the light in question, but all lights down the line. Morespecifically, if you choose to press the i th button right before the k th timestep, then the (i + m) thlight will toggle on the (k + m) th timestep (with i + m ≤ n). For example, if you press button 5just before time 19, then light 5 will toggle at time 19, light 6 will toggle at time 20, light 7 willtoggle at time 21, and so on. If you push a button that will take effect at the same time as its lightwould have toggled due to an earlier button press, then the two cancel each other out, includingsubsequent toggles.Suppose there are three lights, all of which are off at the start. If you press the first button beforethe first timestep, this will happen in three timesteps:Now, suppose you press the first button before the first timestep, and then the second button be-tween the first and second timesteps. The button press will cancel out the propagation, and thiswill happen (note that the propagation will go no further):Now, suppose you press the first button before the first timestep, and then the third button betweenthe first and second timesteps. All three lights will be on at the second timestep (but not the third):You wish to turn on all the lights. What is the earliest time you could possibly see all of the lightsturned on? Note that if the lights are all on at time t but not at time t + 1 due to this propagation, tis still the correct answer.InputEach input will consist of a single test case. Note that your program may be run multiple timeson different inputs. Each test case will consist of a single string S (1 ≤ |S| ≤ 16). The stringS will contain only the characters 1 and 0, where 1 represents that that light is initially on, and 0represents that that light is initially off. The first character is light 1, the next is light 2, and so on.OutputOutput a single integer, which is the earliest time at which all of the lights are on. 题意 给你一个01串，1表示亮0表示灭，每分钟可以让一盏灯亮，但下一分钟后一盏灯会改变，下下一分钟后后一盏灯会改变，直到N。问你最少几分钟可以让所有灯亮。 题解 答案ans&lt;=n，要构造全1，那么就是给你若干个01字符串，问你异或和为全1，显然是一定能构造出来的。 f[ans][S]代表第ans分钟是否有子集S。 Code: 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;bool f[20][1&lt;&lt;16];char a[20];int main(){ while(scanf(\"%s\",a)!=EOF) { int n=strlen(a),i,j,now=0,S=0; memset(f,0,sizeof f); for(int i=0;i&lt;n;i++)if(a[i]=='0')S|=1&lt;&lt;i; f[0][S]=1; while(!f[now][0]) { for(int S=0;S&lt;1&lt;&lt;n;S++)f[now+1][S]=f[now][S]; for(int i=0;i&lt;n;i++) { int mask=0; for(int j=0;j&lt;now+1&amp;&amp;i+j&lt;n;j++)mask|=1&lt;&lt;(i+j); for(int S=0;S&lt;1&lt;&lt;n;S++)if(f[now][S])f[now+1][S^mask]=1; } now++; } printf(\"%d\\n\",now); } return 0;}","link":"/2019/08/Flashing-Fluorescents/"},{"title":"Forest Program","text":"Forest ProgramCode: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * author: MySakure * created: 28.09.2019 12:23:13 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long//#define int long longconst int mod=998244353;const int maxn=3e5+10;int vis[maxn],sz[maxn],dep[maxn];vector&lt;int&gt;g[maxn];ll num=0,cur=0;inline int read(){ int sgn = 1; int cnt = 0; //sgn表示正负号 cnt表示读取的数字 char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') { //读取非数字的字符，保留负号，忽略其余无关符号 if(ch == '-') sgn = -sgn; ch = getchar(); } while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') { cnt = cnt*10 + (ch-'0'); ch = getchar(); } return sgn*cnt;}long long quickmod(long long a,long long b,long long m){ long long ans = 1; while(b)//用一个循环从右到左便利b的所有二进制位 { if(b&amp;1)//判断此时b[i]的二进制位是否为1 { ans = (ans*a)%m;//乘到结果上，这里a是a^(2^i)%m b--;//把该为变0 } b/=2; a = a*a%m; } return ans;}int dfs(int u,int fa,int deep){ if(vis[u]==1)return 0; if(vis[u]==-1){ cur*=(quickmod(2,deep-dep[u],mod)-1); cur%=mod; num+=deep-dep[u]; return 1; } vis[u]=-1; dep[u]=deep; for(int i=0;i&lt;signed(g[u].size());++i){ int v=g[u][i]; if(v==fa)continue; sz[u]+=dfs(v,u,deep+1); } vis[u]=1; return sz[u]+1;}signed main() { int n,m; scanf(\"%d\",&amp;n); scanf(\"%d\",&amp;m); rep(i,1,n)vis[i]=sz[i]=0; rep(i,1,n)g[i].clear(); rep(i,1,m){ int u,v; scanf(\"%d\",&amp;u); scanf(\"%d\",&amp;v); g[u].push_back(v); g[v].push_back(u); } ll ans=1; rep(i,1,n){ if(vis[i])continue; cur=1,num=0; dfs(i,0,1); cur*=quickmod(2,sz[i]-num,mod)%mod; ans*=cur; ans%=mod; } printf(\"%lld\\n\",ans); return 0;}","link":"/2019/09/Forest-Program/"},{"title":"Galahad","text":"Galahad抄大佬思路： 这个题目的正确姿势是读入全部query，然后将询问按右界排序，然后按数列顺序将数字插入树状数组中，如果该点是query的右界就求和，如果该点的数之前被读入过，就删掉之前读入的位置并将数插入该点中，时间$O(nlogn)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * author: MySakure * created: 14.09.2019 12:31:07 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long const int maxn=5e5+10;ll v[maxn],a[maxn],pos[maxn],ans[maxn],n,m;struct query{ int l,r; int id;}q[maxn];bool cmp(const query&amp;a,const query&amp;b){ return a.r&lt;b.r;}int lowbit(int x){return x&amp;(-x);}void update(int inx,int aim){ while(inx&lt;=n){ v[inx]+=aim; inx+=lowbit(inx); }}ll Query(int inx){ ll ans=0; while(inx){ ans+=v[inx]; inx-=lowbit(inx); } return ans;}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n&gt;&gt;m; rep(i,1,n)cin&gt;&gt;a[i]; rep(i,1,m){ cin&gt;&gt;q[i].l&gt;&gt;q[i].r; q[i].id=i; } sort(q+1,q+1+m,cmp); int id=0,cnt=1; while(cnt&lt;=m){ while(id&lt;q[cnt].r){ ++id; if(pos[a[id]])update(pos[a[id]],-a[id]); update(id,a[id]); pos[a[id]]=id; } ans[q[cnt].id]=Query(q[cnt].r)-Query(q[cnt].l-1); cnt++; } rep(i,1,m)cout&lt;&lt;ans[i]&lt;&lt;'\\n'; return 0;}","link":"/2019/09/Galahad/"},{"title":"Graveyard","text":"https://vjudge.net/problem/UVALive-3708 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long#define len 10000int n,m;signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); while(cin&gt;&gt;n&gt;&gt;m){ double ans=0,a=len*1.0/n,b=len*1.0/(n+m); rep(i,1,n){ double x=(i-1)*a; double y1=int(x/b)*b,y2=y1+b; ans+=min(abs(x-y1),abs(x-y2)); } printf(\"%.6lf\\n\",ans); } return 0;}","link":"/2019/08/Graveyard/"},{"title":"Grazers","text":"Gourmet Grazers multiset维护： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn = 1e5 + 10, inf = 1e9 + 10;int n, m;long long ans=0;struct cow { int p, v;}Cow[maxn], So[maxn];bool cmp1(const cow&amp; lhs, const cow&amp; rhs) { return lhs.v &gt; rhs.v;}signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; Cow[i].p &gt;&gt; Cow[i].v; } sort(Cow + 1, Cow + 1 + n, cmp1); for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; So[i].p &gt;&gt; So[i].v; } sort(So + 1, So + 1 + m, cmp1); int inx = 1; multiset&lt;int&gt;T; for (int i = 1; i &lt;= n; ++i) { while (inx &lt;= m &amp;&amp; So[inx].v &gt;= Cow[i].v) { T.insert(So[inx].p); inx++; } auto p = T.lower_bound(Cow[i].p); if (p == T.end()) { cerr &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; \"-1\" &lt;&lt; endl; return 0; } ans += *p; T.erase(p); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 离散化＋权值线段树： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn = 1e5 + 10, inf = 1e9 + 10;int n, m;long long ans;struct cow { int p, v;}Cow[maxn], So[maxn];bool cmp1(const cow&amp; lhs, const cow&amp; rhs) { return lhs.v &gt; rhs.v;}vector&lt;int&gt;v;struct node { int l, r, n;}Seg[maxn &lt;&lt; 4];void Build(int root, int l, int r) { Seg[root].l = l, Seg[root].r = r, Seg[root].n = 0; if (l == r)return; int mid = (l + r) &gt;&gt; 1; Build(root &lt;&lt; 1, l, mid); Build(root &lt;&lt; 1 | 1, mid + 1, r);}void insert(int root, int aim) { if (Seg[root].l == Seg[root].r) { Seg[root].n++; return; } int mid = (Seg[root].l + Seg[root].r) &gt;&gt; 1; if (aim &lt;= mid)insert(root &lt;&lt; 1, aim); else insert(root &lt;&lt; 1 | 1, aim); Seg[root].n++;}int update(int root, int aim) { if (Seg[root].n == 0)return -1; if (Seg[root].l == Seg[root].r) { Seg[root].n--; return Seg[root].l; } int mid = (Seg[root].l + Seg[root].r) &gt;&gt; 1; int tmp; if (aim &lt;= mid) { tmp = update(root &lt;&lt; 1, aim); if (tmp == -1){ tmp=update(root &lt;&lt; 1 | 1, aim); if(tmp!=-1)Seg[root].n--; return tmp; } else { Seg[root].n--; return tmp; } } tmp=update(root &lt;&lt; 1 | 1, aim); if(tmp!=-1)Seg[root].n--; return tmp;}int getid(int cur) { return lower_bound(v.begin(), v.end(), cur) - v.begin() + 1; }signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; Cow[i].p &gt;&gt; Cow[i].v; v.push_back(Cow[i].p); } sort(Cow + 1, Cow + 1 + n, cmp1); for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; So[i].p &gt;&gt; So[i].v; v.push_back(So[i].p); } sort(So + 1, So + 1 + m, cmp1); sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); Build(1, 1, v.size()); int inx = 1; for (int i = 1; i &lt;= n; ++i) { while (inx &lt;= m &amp;&amp; So[inx].v &gt;= Cow[i].v) { insert(1, getid(So[inx].p)); inx++; } int x = update(1, getid(Cow[i].p)); if (x == -1) { cout &lt;&lt; \"-1\" &lt;&lt; endl; return 0; } int tmp = v[x - 1]; //cerr&lt;&lt;tmp&lt;&lt;endl; ans += tmp; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/07/Grazers/"},{"title":"牛客小白月赛17","text":"待补：H 取球游戏 计数跑一遍动态规划 1234567891011121314151617181920212223242526272829303132333435363738/** * author: MySakure * created: 13.09.2019 21:42:26 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=1e6+10;int n,a[maxn],dp[2][1100],b[maxn],f[maxn];const int mod=1e9+7;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n; rep(i,1,n)cin&gt;&gt;a[i]; dp[0][1000]=1; f[0]=1000,b[n+1]=0; rep(i,1,n)f[i]=min(f[i-1],a[i]==0?1000:a[i]); per(i,n,1)b[i]=max(b[i+1],a[i]); rep(i,1,n){ rep(j,1,1000)dp[i&amp;1][j]=0; int s=0; per(j,f[i-1],b[i]){ (s+=dp[!(i&amp;1)][j])%=mod; if(j&lt;=f[i]&amp;&amp;j&gt;=b[i])dp[i&amp;1][j]=s; } } int ans=0; rep(i,1,1000)(ans+=dp[n&amp;1][i])%=mod; cout&lt;&lt;ans&lt;&lt;endl; return 0;} 区间求和神奇的莫队算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * author: MySakure * created: 13.09.2019 20:55:08 **/#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int a[maxn];int pos[maxn];int cnt[maxn];#define int long longlong long ans[maxn];long long Ans=0;struct node{ int l,r,id;}q[maxn];bool cmp(const node &amp;a,const node &amp;b){ if(pos[a.l]==pos[b.l]) return a.r&lt;b.r; return pos[a.l]&lt;pos[b.l];}int k;void add(int x){ Ans+=cnt[a[x]]*1ll*a[x]; cnt[a[x]]++; Ans+=cnt[a[x]]*1ll*a[x];}void del(int x){ Ans-=cnt[a[x]]*1ll*a[x]; cnt[a[x]]--; Ans-=cnt[a[x]]*1ll*a[x];}signed main(){ ios::sync_with_stdio(false); cin.tie(0); int n,i,m; cin&gt;&gt;n&gt;&gt;m; int sz=sqrt(n); for(i=1;i&lt;=n;i++) { cin&gt;&gt;a[i]; pos[i]=i/sz; } for(i=1;i&lt;=m;i++) { cin&gt;&gt;q[i].l&gt;&gt;q[i].r; if(q[i].l&gt;q[i].r)swap(q[i].l,q[i].r); q[i].id=i; } sort(q+1,q+m+1,cmp); int L=1,R=0; for(i=1;i&lt;=m;i++) { while(L&lt;q[i].l) { del(L); L++; } while(R&gt;q[i].r) { del(R); R--; } while(L&gt;q[i].l) { L--; add(L); } while(R&lt;q[i].r) { R++; add(R); } ans[q[i].id]=Ans; } for(i=1;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;'\\n'; return 0;} 图的遍历出题人题解： 作者：sd197555https://ac.nowcoder.com/discuss/258571?type=101&amp;order=time&amp;pos=&amp;page=1来源：牛客网 首先讨论图有多少个联通块，在这些联通块中，若存在一个包含奇环的联通块，那么将当前的联通块与所有的不包含奇环的联通块相连就行了，答案个数为不包含奇环的联通块个数。 若所有的联通块都不包含奇环，那么可以用若干条边在k个（k为奇数）联通块之间构造一条奇环，然后再把其他的联通块跟当前的奇环相连，答案为联通块的个数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * author: MySakure * created: 14.09.2019 00:11:59 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=1e5+10;int n,m,color[maxn];vector&lt;int&gt;g[maxn];bool flag=false;void dfs(int u,int f,int c){ if(color[u]){ if(color[u]!=c)flag=true; return; } color[u]=c; for(int i=0;i&lt;int(g[u].size());++i) { int v=g[u][i]; if(v==f)continue; dfs(v,u,3-c); }}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n&gt;&gt;m; rep(i,1,m){ int a,b; cin&gt;&gt;a&gt;&gt;b; g[a].push_back(b); g[b].push_back(a); } int ans=0; rep(i,1,n){ if(!color[i]){ ans++; dfs(i,0,1); } } cout&lt;&lt;ans-flag&lt;&lt;endl; return 0;} 小黄鸭神奇的微积分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * author: MySakure * created: 14.09.2019 00:11:59 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=1e5+10;int n,m,color[maxn];vector&lt;int&gt;g[maxn];bool flag=false;void dfs(int u,int f,int c){ if(color[u]){ if(color[u]!=c)flag=true; return; } color[u]=c; for(int i=0;i&lt;int(g[u].size());++i) { int v=g[u][i]; if(v==f)continue; dfs(v,u,3-c); }}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n&gt;&gt;m; rep(i,1,m){ int a,b; cin&gt;&gt;a&gt;&gt;b; g[a].push_back(b); g[b].push_back(a); } int ans=0; rep(i,1,n){ if(!color[i]){ ans++; dfs(i,0,1); } } cout&lt;&lt;ans-flag&lt;&lt;endl; return 0;}","link":"/2019/09/H%20%E5%8F%96%E7%90%83%E6%B8%B8%E6%88%8F/"},{"title":"H subsequence 2","text":"链接：https://ac.nowcoder.com/acm/contest/885/H来源：牛客网 There is a hidden string of length n composed of the first m lowercase English letters. For any two different English letters, we will tell you a subsequence of the hidden string constructed by removing all other letters from the hidden string. For example, if the hidden string is “apple” and the chosen letters are ‘e’ and ‘p’, the resulting subsequence would be “ppe”; if the chosen letters are ‘a’ and ‘x’, the resulting subsequence would be “a”. Now, please recover the hidden string. Output -1 if there are no possible hidden string. Output any one if there are multiple possible hidden strings. 输入描述:1The first line contains two integers n and m.Following are m⋅(m−1)/2m \\cdot (m-1)/2m⋅(m−1)/2 groups of two lines. The first line in each group contains a two-letter string composed of c1, c2, and an integer LEN. The second line contains a string composed of letters c1, c2 with length LEN, indicates the resulting subsequence by removing all other letters except c1 and c2 from the hidden string.* 1≤n≤1041 \\le n \\le 10^41≤n≤104* 2≤m≤102 \\le m \\le 102≤m≤10* 0≤LEN≤n0 \\le LEN \\le n0≤LEN≤n* all unordered pairs of letters in first m small English letters will occur exactly once. 输出描述:1If there is at least one possible hidden string, please output any. Otherwise, output -1. 示例1 输入复制 12345673 3ab 2abbc 2bcca 2ac 输出复制 1abc 说明1First group tells us that there is one 'a' and one 'b' where 'a' is before 'b', the second group tells us there is one 'b' and one 'c' where 'b' is before 'c'. So the only possible answer is &quot;abc&quot; which satisfies the last group as well. 示例2 输入复制 12345673 3cb 3bbcca 2acab 3abb 输出复制 1-1 示例3 输入复制 12345674 3ac 4ccccba 0cb 4cccc 输出复制 1cccc 题解： 标程：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;using namespace std;const int MAX_N = 10000;int n, m;char s[10][10][MAX_N + 5];int len[10][10];void read_input(){ scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 0; i &lt; m * (m - 1) / 2; i++){ char c[4]; int sz; scanf(\"%s%d\", c, &amp;sz); int x = c[0] - 'a'; int y = c[1] - 'a'; if(x &gt; y) { int tmp = x; x = y; y = tmp; } len[x][y] = sz; if(sz) { scanf(\"%s\", s[x][y]); } }}int it[10][10];char an[MAX_N + 5];bool check() { for(int i = 0; i &lt; m; i++) { for(int j = i + 1; j &lt; m; j++) { int now = 0; for(int k = 0; k &lt; n; k++) { if(an[k] == 'a' + i || an[k] == 'a' + j) { if(an[k] != s[i][j][now]) return 0; now++; } } if(now != len[i][j]) return 0; } } return 1;}bool solve() { for(int i = 0; i &lt; n; i++) { bool stop[10] = {}; for(int j = 0; j &lt; m; j++) { for(int k = j + 1; k &lt; m; k++) { if(!s[j][k][it[j][k]]) stop[j] = stop[k] = 1; else if(s[j][k][it[j][k]]=='a'+j)stop[k]=1; else stop[j]=1; } } bool done = false; for(int j = 0; j &lt; m; j++) { if(!stop[j]) { an[i] = 'a' + j; for(int k = 0; k &lt; m; k++) { if(k &lt; j) it[k][j] ++; else if(k &gt; j) it[j][k] ++; } an[i] = 'a' + j; done = true; break; } } if(!done) return 0; } if(!check()) return 0; puts(an); return 1;}int main() { read_input(); if(!solve()) puts(\"-1\"); return 0;} 偷的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 7;int du[N], num[N], numt[N], f[N], c[N * 20];vector&lt;int &gt; p[N], id[N];char s[N]; int main(){ int n, m; scanf(\"%d%d\", &amp;n, &amp;m); int mm = m * (m - 1) / 2; bool flag = true; char op[5]; int len, cnt = 0; memset(numt, -1, sizeof(numt)); for (int i = 1; i &lt;= mm; i++){ scanf(\"%s%d\", op, &amp;len); if (len == 0) continue; scanf(\"%s\", s); num[op[0] - 'a'] = 0; num[op[1] - 'a'] = 0; for (int j = 0; j &lt; len; j++) f[j] = ++num[s[j] - 'a']; if (numt[op[0] - 'a'] != -1 &amp;&amp; numt[op[0] - 'a'] != num[op[0] - 'a']) flag = false; if (numt[op[1] - 'a'] != -1 &amp;&amp; numt[op[1] - 'a'] != num[op[1] - 'a']) flag = false; int x1 = s[0] - 'a', y1; if (numt[x1] == -1) id[x1].push_back(++cnt), c[cnt] = x1, y1 = cnt; else y1 = id[x1][0]; du[y1] ++; p[0].push_back(y1); for (int j = 1; j &lt; len; j++){ int y1, y2, x1 = s[j - 1] - 'a', x2 = s[j] - 'a'; y1 = id[x1][f[j - 1] - 1]; if (numt[x2] == -1) id[x2].push_back(++cnt), c[cnt] = x2, y2 = cnt; else y2 = id[x2][f[j] - 1]; //printf(\"%d %d\\n\", y1, y2); du[y2] ++; p[y1].push_back(y2); } numt[op[0] - 'a'] = num[op[0] - 'a']; numt[op[1] - 'a'] = num[op[1] - 'a']; } queue&lt;int &gt; Q; Q.push(0); vector&lt;int &gt; ans; while (!Q.empty()){ int now = Q.front(); Q.pop(); if (now != 0) ans.push_back(now); for (int v : p[now]){ if (--du[v] == 0){ Q.push(v); } } } if (flag &amp;&amp; (int)ans.size() == n){ for (int x : ans) printf(\"%c\", c[x] + 'a'); } else printf(\"-1\"); return 0;}","link":"/2019/08/H-subsequence-2/"},{"title":"HDU1233","text":"还是畅通工程Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 67170 Accepted Submission(s): 30442 Problem Description 某省调查乡村交通状况，得到的统计表中列出了任意两村庄间的距离。省政府“畅通工程”的目标是使全省任何两个村庄间都可以实现公路交通（但不一定有直接的公路相连，只要能间接通过公路可达即可），并要求铺设的公路总长度为最小。请计算最小的公路总长度。 Input 测试输入包含若干测试用例。每个测试用例的第1行给出村庄数目N ( &lt; 100 )；随后的N(N-1)/2行对应村庄间的距离，每行给出一对正整数，分别是两个村庄的编号，以及此两村庄间的距离。为简单起见，村庄从1到N编号。当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最小的公路总长度。 Sample Input 12345678910111231 2 11 3 22 3 441 2 11 3 41 4 12 3 32 4 23 4 50 Sample Output 123456735HintHint Huge input, scanf is recommended. Source 浙大计算机研究生复试上机考试-2006年 思路：Kruskal不适合稠密图，复杂度是O(ElgE)，Prim一般处理二维表复杂度是O(N^2) CodeTLE的Kruskal:123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint fa[110],n,ans;struct E{ int l,r,d;};E mp[1000010];bool cmp(const E&amp;a,const E&amp;b){ return a.d&lt;b.d;}int find(int cur){ return fa[cur]==cur?cur:fa[cur]=find(fa[cur]);}int main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); while(cin&gt;&gt;n&amp;&amp;n){ int num=(n-1)*n/2; ans=0; for(int i=1;i&lt;=num;++i)fa[i]=i; for(int i=1;i&lt;=num;++i)cin&gt;&gt;mp[i].l&gt;&gt;mp[i].r&gt;&gt;mp[i].d; sort(mp+1,mp+num+1,cmp); for(int i=1;i&lt;=num;++i){ int a=find(mp[i].l),b=find(mp[i].r); if(a==b)continue; fa[a]=b; ans+=mp[i].d; } cout&lt;&lt;ans&lt;&lt;endl; } return 0;} Prim123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int maxn=110;int mp[maxn][maxn],n,num,Min,ans,vis[maxn],d[maxn],cur;int main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); while(cin&gt;&gt;n&amp;&amp;n){ num=n*(n-1)/2; for(int i=1;i&lt;=num;++i){ int tmpa,tmpb,d; cin&gt;&gt;tmpa&gt;&gt;tmpb&gt;&gt;d; mp[tmpa][tmpb]=d,mp[tmpb][tmpa]=d; } //cerr&lt;&lt;\"hello \"&lt;&lt;num&lt;&lt;endl; for(int i=1;i&lt;=n;++i)vis[i]=0; for(int i=2;i&lt;=n;++i)d[i]=mp[1][i]; vis[1]=true,ans=0; for(int i=1;i&lt;n;++i){ Min=1e5+10; for(int j=1;j&lt;=n;++j){ if(vis[j]==0&amp;&amp;d[j]&lt;Min){ Min=d[j]; cur=j; } } //cerr&lt;&lt;\"emmmmm \"&lt;&lt;endl; //cerr&lt;&lt;\"debug \"&lt;&lt;cur&lt;&lt;\" \"&lt;&lt;Min&lt;&lt;endl; ans+=d[cur],vis[cur]=1; for(int j=1;j&lt;=n;++j) { //cerr&lt;&lt;cur&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;d[j]&lt;&lt;\" \"&lt;&lt;d[cur]&lt;&lt;\" \"&lt;&lt;d[cur]+mp[cur][j]&lt;&lt;endl; d[j]=min(d[j],mp[cur][j]); } } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2019/07/HDU1233/"},{"title":"HDU1532","text":"HDU1532 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int maxn=201;int s=1,t,n,m;struct Edge{ int from,to,cap,flow; //Edge(int lhs,int rhs,int cap,int f):from(lhs),to(rhs),cap(cap),flow(f){};};struct Dinic{ int s,t,f; vector&lt;int&gt;G[maxn]; vector&lt;Edge&gt;edges; int dis[maxn],cur[maxn]; bool vis[maxn]; void AddEdges(int lhs,int rhs,int c){ edges.push_back(Edge{lhs,rhs,c,0}); edges.push_back(Edge{rhs,lhs,0,0}); f=edges.size(); G[lhs].push_back(f-2); G[rhs].push_back(f-1); } int bfs(){ //memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;++i) vis[i]=false; queue&lt;int&gt;q; q.push(s); dis[s]=0,vis[s]=1; while(!q.empty()){ int cur=q.front();q.pop(); for(int i=0;i&lt;G[cur].size();++i){ Edge&amp; e=edges[G[cur][i]]; //重要 if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow){ vis[e.to]=true; dis[e.to]=dis[cur]+1; q.push(e.to); } } } return vis[t]; } int dfs(int x,int a){ if(x==t||a==0)return a; int flow=0,f; for(int &amp;i=cur[x];i&lt;G[x].size();++i){ Edge &amp;e=edges[G[x][i]]; if(dis[e.to]==dis[x]+1&amp;&amp;(f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0){ flow+=f; e.flow+=f; edges[G[x][i]^1].flow-=f; a-=f; if(a==0)break; } } return flow; } int MaxFlow(){ this-&gt;s=s,this-&gt;t=t; int ans=0; while(bfs()){ for(int i=0;i&lt;=n;++i) cur[i]=0; ans+=dfs(s,1e9); } return ans; }};Dinic dinic;signed main(){ //ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); while(cin&gt;&gt;m&gt;&gt;n){ dinic.edges.clear(); for(int i=1;i&lt;=n;++i) dinic.G[i].clear(); dinic.t=n,dinic.s=1; while(m--){ int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; dinic.AddEdges(a,b,c); } cout&lt;&lt;dinic.MaxFlow()&lt;&lt;endl; } return 0;}","link":"/2019/07/HDU1532/"},{"title":"HDU1874","text":"HDU1874 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=210;struct Node{ double x,y;}po[maxn];int n,fa[maxn],t;pair&lt;pair&lt;double,double&gt;,double&gt;r[maxn*maxn];long double ans;long double dis(Node a,Node b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}bool cmp(const pair&lt;pair&lt;double,double&gt;,double&gt;&amp;a,const pair&lt;pair&lt;double,double&gt;,double&gt;&amp;b){ return a.second&lt;b.second;}int Fa(int cur){ return cur==fa[cur]?cur:fa[cur]=Fa(fa[cur]);}signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(1); cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) { cin&gt;&gt;po[i].x&gt;&gt;po[i].y; fa[i]=i; } int inx=0,num=0; ans=0; for(int i=1;i&lt;n;++i) for(int j=i+1;j&lt;=n;++j) { long double di=dis(po[i],po[j]); if(di&gt;=10&amp;&amp;di&lt;=1000)r[++inx]=make_pair(make_pair(i,j),di); } sort(r+1,r+1+inx,cmp); for(int i=1;i&lt;=inx;++i){ int a1=Fa(r[i].first.second)+0.5,a2=Fa(r[i].first.first)+0.5; if(a1!=a2){ fa[a1]=a2; ans+=r[i].second; num++; } } if(num!=n-1){ cout&lt;&lt;\"oh!\"&lt;&lt;endl; continue; } cout&lt;&lt;ans*100&lt;&lt;endl; } return 0;}","link":"/2019/07/HDU1874/"},{"title":"HDU2089","text":"不要 62 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int dp[10][2],l,r,st[10];int dfs(int pos,int j,int limit){ if(pos==-1)return 1; //cerr&lt;&lt;\"debug \"&lt;&lt;endl; if(!limit&amp;&amp;dp[pos][j]!=-1)return dp[pos][j]; int up=limit?st[pos]:9,ans=0; for(int i=0;i&lt;=up;++i){ if(i==4||(j&amp;&amp;i==2))continue; ans+=dfs(pos-1,i==6,limit&amp;&amp;i==up); } if(!limit)dp[pos][j]=ans; return ans;}int solve(int cur){ int inx=0; while(cur){st[inx++]=cur%10;cur/=10;} return dfs(inx-1,false,true);}signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); memset(dp,-1,sizeof(dp)); while(cin&gt;&gt;l&gt;&gt;r&amp;&amp;l&amp;&amp;r){ cout&lt;&lt;solve(r)-solve(l-1)&lt;&lt;endl; } return 0;}","link":"/2019/07/HDU2089/"},{"title":"HDU3555","text":"HDU3555 反向思路： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long int st[100],n,dp[100][2],num;int dfs(int pos,int limit,int s){ if(pos==-1)return 1; if(!limit&amp;&amp;dp[pos][s]!=-1)return dp[pos][s]; int up=limit?st[pos]:9,ans=0; for(int i=0;i&lt;=up;++i){ if(s&amp;&amp;i==9)continue; else ans+=dfs(pos-1,limit&amp;&amp;i==up,i==4); } if(!limit)dp[pos][s]=ans; return ans;}int solve(int cur){ int inx=0; while(cur){ st[inx++]=cur%10; cur/=10; } //cerr&lt;&lt;\"debug \"&lt;&lt;inx&lt;&lt;endl; return dfs(inx-1,true,0);}signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;n; memset(dp,-1,sizeof(dp)); while(n--){ cin&gt;&gt;num; cout&lt;&lt;num-solve(num)+1&lt;&lt;endl; } return 0;} 正向思路： 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint t,n,st[100],dp[100][3];int dfs(int pos,int limit,int s){ if(pos==-1)return s==1; if(!limit&amp;&amp;dp[pos][s]!=-1)return dp[pos][s]; int up=limit?st[pos]:9,ans=0; for(int i=0;i&lt;=up;++i) { if(s==1)ans+=dfs(pos-1,limit&amp;&amp;i==up,s); else if(s==0)ans+=dfs(pos-1,limit&amp;&amp;i==up,i==4?2:s); else ans+=dfs(pos-1,limit&amp;&amp;i==up,i==9?1:(i==4?2:0)); } if(!limit)dp[pos][s]=ans; return ans;}int solve(long long cur){ int inx=0; while(cur){st[inx++]=cur%10;cur/=10;} return dfs(inx-1,true,0);}signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;t; memset(dp,-1,sizeof(dp)); while(t--){ cin&gt;&gt;n; cout&lt;&lt;solve(n)&lt;&lt;endl; } return 0;}","link":"/2019/07/HDU3555/"},{"title":"HDU4352","text":"XHXJ’s LIS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;long long dp[25][1&lt;&lt;10][11];///dp[i][j][k]:i为当前进行到的数位，j状态压缩，为10个数字出现过的，其中1的个数就是最长上升子序列，k要求的上升子序列的长度 int K;int getnews(int x,int s) ///更新新的状态{ for(int i=x;i&lt;10;i++) if(s&amp;(1&lt;&lt;i))return (s^(1&lt;&lt;i))|(1&lt;&lt;x); return s|(1&lt;&lt;x);} int getnum(int s) ///得到状态s中1的个数{ int ret=0; while(s) { if(s&amp;1) ret++; s&gt;&gt;=1; } return ret;}int bit[25];long long dfs(int pos,int s,bool e,bool z)//e是是不是上界标记，z是是不是前面的为0标记{ if(pos==-1)return getnum(s)==K; if(!e &amp;&amp;dp[pos][s][K]!=-1)return dp[pos][s][K]; ///核心 long long ans=0; int end=e?bit[pos]:9; for(int i=0;i&lt;=end;i++) ans+=dfs(pos-1,(z&amp;&amp;i==0)?0:getnews(i,s),e&amp;&amp;i==end,z&amp;&amp;(i==0)); if(!e)dp[pos][s][K]=ans; return ans;}long long calc(long long n){ int len=0; while(n) bit[len++]=n%10 , n/=10; return dfs(len-1,0,1,1);}int main(){ //freopen(\"in.txt\",\"r\",stdin); //freopen(\"out.txt\",\"w\",stdout); int T; long long l,r; memset(dp,-1,sizeof(dp)); scanf(\"%d\",&amp;T); int iCase=0; while(T--) { iCase++; scanf(\"%I64d%I64d%d\",&amp;l,&amp;r,&amp;K); printf(\"Case #%d: \",iCase); printf(\"%I64d\\n\",calc(r)-calc(l-1)); } return 0;} /* * HDU 4352 XHXJ's LIS * 问L到R，各位数字组成的严格上升子序列的长度为K的个数。 * 0&lt;L&lt;=R&lt;263-1 and 1&lt;=K&lt;=10 * 注意这里最长上升子序列的定义，和LIS是一样的，不要求是连续的 * 所以用十位二进制表示0~9出现的情况，和O(nlogn)求LIS一样的方法进行更新 * */","link":"/2019/07/HDU4352/"},{"title":"Imbalanced Array","text":"You are given an array a consisting of n elements. The imbalance value of some subsegment of this array is the difference between the maximum and minimum element from this segment. The imbalance value of the array is the sum of imbalance values of all subsegments of this array. For example, the imbalance value of array [1,4,1] is 9, because there are 6 different subsegments of this array: [1] (from index 1 to index 1), imbalance value is 0; [1,4] (from index 1 to index 2), imbalance value is 3; [1,4,1] (from index 1 to index 3), imbalance value is 3; [4] (from index 2 to index 2), imbalance value is 0; [4,1] (from index 2 to index 3), imbalance value is 3; [1] (from index 3 to index 3), imbalance value is 0; You have to determine the imbalance value of the array a. Input The first line contains one integer n (1≤n≤106) − size of the array a. The second line contains n integers a1,a2… a**n (1≤a*i*≤106) − elements of the array. Output Print one integer − the imbalance value of a. Example Input 131 4 1 Output 19 code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define sz size#define ll long longconst int maxn = 1e6 + 10;struct node { int l, r; int Max, Min;}tr[maxn &lt;&lt; 2];int n, a[maxn];void build(int rot, int l, int r) { tr[rot].l = l, tr[rot].r = r; if (l == r) { tr[rot].Max = l; tr[rot].Min = l; return; } int mid = (l + r) &gt;&gt; 1; build(rot &lt;&lt; 1, l, mid); build(rot &lt;&lt; 1 | 1, mid + 1, r); int L_min = tr[rot &lt;&lt; 1].Min, R_min = tr[rot &lt;&lt; 1 | 1].Min; tr[rot].Min = a[L_min] &lt; a[R_min] ? L_min : R_min; int L_max = tr[rot &lt;&lt; 1].Max, R_max = tr[rot &lt;&lt; 1 | 1].Max; tr[rot].Max = a[L_max] &gt; a[R_max] ? L_max : R_max; // tr[rot].Max = max(tr[rot &lt;&lt; 1].Max, tr[rot &lt;&lt; 1 | 1].Max); // tr[rot].Min = min(tr[rot &lt;&lt; 1].Min, tr[rot &lt;&lt; 1 | 1].Min);}int QuareMax(int rot, int L, int R) { int l = tr[rot].l, r = tr[rot].r; if (l == L &amp;&amp; r == R) { return tr[rot].Max; } int mid = (l + r) &gt;&gt; 1; if (R &lt;= mid)return QuareMax(rot &lt;&lt; 1, L, R); else if (L &gt; mid)return QuareMax(rot &lt;&lt; 1 | 1, L, R); else { int ans_l = QuareMax(rot &lt;&lt; 1, L, mid); int ans_r = QuareMax(rot &lt;&lt; 1 | 1, mid + 1, R); return a[ans_l] &gt; a[ans_r] ? ans_l : ans_r; }}int QuareMin(int rot, int L, int R) { int l = tr[rot].l, r = tr[rot].r; if (l == L &amp;&amp; r == R) { return tr[rot].Min; } int mid = (l + r) &gt;&gt; 1; if (R &lt;= mid)return QuareMin(rot &lt;&lt; 1, L, R); else if (L &gt; mid)return QuareMin(rot &lt;&lt; 1 | 1, L, R); else { int ans_l = QuareMin(rot &lt;&lt; 1, L, mid); int ans_r = QuareMin(rot &lt;&lt; 1 | 1, mid + 1, R); return a[ans_l] &lt; a[ans_r] ? ans_l : ans_r; }}ll solve(int l, int r) { if (l &gt;= r)return 0; //cerr &lt;&lt; \"debug \" &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; ll ans=0; int Max = QuareMax(1, l, r); int Min = QuareMin(1, l, r); //cerr &lt;&lt; \"cur Max Min\" &lt;&lt; Max &lt;&lt; \" \" &lt;&lt; Min &lt;&lt; endl; ll Minus = a[Max] - a[Min]; ll L = min(Max, Min), R = max(Max, Min); ans += Minus * ((r - R + 1) * (L - l + 1)); //cerr &lt;&lt; \"ans \" &lt;&lt; ans &lt;&lt; endl; ans+=solve(l, R - 1); ans+=solve(L + 1, r); ans-=solve(L+1,R-1); return ans;}signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin &gt;&gt; n; rep(i, 1, n)cin &gt;&gt; a[i]; build(1, 1, n); //cerr &lt;&lt; a[QuareMax(1, 1, n)] &lt;&lt; endl; cout &lt;&lt; solve(1, n) &lt;&lt; endl; return 0;}","link":"/2019/08/Imbalanced-Array/"},{"title":" Implement a Shell by yourself -- MIT xv6 shell(转载)","text":"转载来自https://blog.csdn.net/cinmyheart/article/details/45122619，仅供个人学习使用 Implement a Shell by yourself – MIT xv6 shell这个其实是作为6.828的一个小课堂作业 … 着重分析构建思想和过程，具体代码实现去github可以找到． https://github.com/jasonleaster/MIT_6_828_assignments_2012/blob/homework1/sh.c ———————————– 大家好，我是分割线 ——————————————————————- 这里主要实现了基础的三类命令 可执行的程序命令重定向命令管道命令实现的”基类” (原谅我用了这个词)就是struct cmd这个结构体就一个成员，用于记录命令的类型． 三类, ‘ ‘ 表示可执行程序 ‘|’ 表示管道命令, ‘&lt;’ 和’&gt;’ 表示重定向类型． 每一个类型分别继承基类，派生出对应的三类结构体 struct execcmd struct redircmd struct pipecmd 1234567891011121314151617181920212223242526#define MAXARGS 10// All commands have at least a type. Have looked at the type, the code// typically casts the *cmd to some specific cmd type.struct cmd { int type; // ' ' (exec), | (pipe), '&lt;' or '&gt;' for redirection};struct execcmd { int type; // ' ' char *argv[MAXARGS]; // arguments to the command to be exec-ed};struct redircmd { int type; // &lt; or &gt; struct cmd *cmd; // the command to be run (e.g., an execcmd) char *file; // the input/output file int mode; // the mode to open the file with int fd; // the file descriptor number to use for the file};struct pipecmd { int type; // | struct cmd *left; // left side of pipe struct cmd *right; // right side of pipe}; 对于可执行命令，主要记录可执行程序的程序名字还有各种选项参数．所以会有 char* argv[MAXARGS] 对于重定向命令，主要记录 cmd 即触发这个重定向的程序比方说 ./a.out &gt; tmp.txt 那么cmd就是记录的./a.out 重定向到那个文件的文件名 char *file指针指向这个文件名． 对于管道， 则主要记录管道左右两侧的命令 void runcmd(struct cmd * cmd); 这个函数是真正驱动调用实现shell的核心．负责调用系统接口函数 execv(), open(), close(), dup(), pipe()等等一系列函数，来完成我们既定的目标． 作业也就是补全这个函数． 这是个递归的函数！很有意思． 你会发现，shell的命令实现居然是递归的哈哈 下面是我画的一个简单的流程图 你会发现，是先处理可执行程序，然后检查输入中是否有管道，如果有，那么递归的调用parsepipe去构建这些可执行程序间的输入输出的关系．直到所有管道被检查完，那么返回parsecmd()，进入到runcmd()开始执行命令． 这里是主函数: 123456789101112131415161718192021intmain(void){ static char buf[100]; int fd, r; // Read and run input commands. while(getcmd(buf, sizeof(buf)) &gt;= 0){ if(buf[0] == 'c' &amp;&amp; buf[1] == 'd' &amp;&amp; buf[2] == ' '){ // Clumsy but will have to do for now. // Chdir has no effect on the parent if run in the child. buf[strlen(buf)-1] = 0; // chop \\n if(chdir(buf+3) &lt; 0) fprintf(stderr, \"cannot cd %s\\n\", buf+3); continue; } if(fork1() == 0) runcmd(parsecmd(buf)); wait(&amp;r); } exit(0);} 调用getcmd()在标准输入读取sizeof(buf)大小的字符，然后，写入到buf中． 那个 if(buf[0] …. )是判断你是不是输入了 cd命令 如果是把buf尾部赋值为0，这样buf看起来就是储存的一个字符串, 然后调用chdir() 更换当buf+3开始的字符串指定的路径． 接着continue继续读取命令啦．．． 如果你不更换路径了 我们就fork1()出一个子进程，parent process就一直等待子进程挂掉．．．等啊等．．等啊等．． 这个时候，子进程就开始调用parsecmd()去分析你输入的命令字符串咯．．． 1234567891011121314struct cmd*parsecmd(char *s){ char *es; struct cmd *cmd; es = s + strlen(s); cmd = parseline(&amp;s, es); peek(&amp;s, es, \"\"); if(s != es){ fprintf(stderr, \"leftovers: %s\\n\", s); exit(-1); } return cmd;} es指针指向字符串的末端，确切的说是空字符处 然后去调用 parseline(&amp;s, es) parseline() 看起来太弱了，就是一层简单的封装．实际核心函数还是parsepipe 1234567891011121314151617181920struct cmd*parseline(char **ps, char *es){ struct cmd *cmd; cmd = parsepipe(ps, es); return cmd;}struct cmd*parsepipe(char **ps, char *es){ struct cmd *cmd; cmd = parseexec(ps, es); if(peek(ps, es, \"|\")){ gettoken(ps, es, 0, 0); cmd = pipecmd(cmd, parsepipe(ps, es)); } return cmd;} 这里要说一说里面关键的几个子函数 123char whitespace[] = \" \\t\\r\\n\\v\";char symbols[] = \"&lt;|&gt;\"; 经常会看到下面这个while循环，作用是啥呢？ s 指向我们输入的命令字符串，strchr通过检查 *s是否是 whilespace里的任意一个字符，如果是其中某个字符，那么我们就要跳过这个字符，知道我们把s移动到指向一个非空格类的字符 12while(s &lt; es &amp;&amp; strchr(whitespace, *s)) s++; 再看另外一个一旦遇到空格字符，或者symbols中的任意一个字符，我们就不再移动指针s 12while(s &lt; es &amp;&amp; !strchr(whitespace, *s) &amp;&amp; !strchr(symbols, *s)) s++; 下面是实现pipe的一部分． 分析： 第一次调用fork1() 产生 child process 1 该进程用于运行 pcmd-&gt;left 指向的进程 第二次调用fork1() 产生 child process 2 该进程用于运行 pcmd-&gt;right 指向的进程 child process 1 由于先 close(1)那么文件描述符1就被空余出来了, 调用dup(p[1])把 child process 1的标准输出(文件描述符默认的是1)和管道的输出关联起来 child process 2的伎俩差不多，只是把进程的标准输入关闭了，把从管道的输入作为进程的标准输入来用． 12345678910111213141516171819202122if(fork1() == 0) { close(1); dup(p[1]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); } if(fork1() == 0) { close(0); dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); } close(p[0]); close(p[1]); wait(); wait(); 我刚差点被自己蠢哭了，睡了三个小时哈哈哈 这里有两个 wait(), 为什么呢？奇怪．． 一点都不奇怪．．必须两个wait()，因为这里有两个子进程，parent process必须等这两个进程都挂了之后再结束． execcmd()返回一个struct cmd()结构体. 同样的*cmd()函数都会返回一个对应的 *结构体 值得特别强调好玩的事情是，你会发现这里 execcmd()返回的是一个 struct cmd* 指针 但是execcmd()函数确实申请的是一个struct execcmd()结构体．那么问题就来了．．怎么会这样． 回过头去观察四种结构体的之间的关系你就会发现，这里巧妙之处就在于，他们的第一个成员都是相同的！ 返回了一个＂基类＂指针． 12345678910111213141516171819202122232425262728293031struct cmd*parseexec(char **ps, char *es){ char *q, *eq; int tok, argc; struct execcmd *cmd; struct cmd *ret; ret = execcmd(); cmd = (struct execcmd*)ret; argc = 0; ret = parseredirs(ret, ps, es); while(!peek(ps, es, \"|\")){ if((tok=gettoken(ps, es, &amp;q, &amp;eq)) == 0) break; if(tok != 'a') { fprintf(stderr, \"syntax error\\n\"); exit(-1); } cmd-&gt;argv[argc] = mkcopy(q, eq); argc++; if(argc &gt;= MAXARGS) { fprintf(stderr, \"too many args\\n\"); exit(-1); } ret = parseredirs(ret, ps, es); } cmd-&gt;argv[argc] = 0; return ret;} 最后的运行效果． 能在本地的文件 ./tmp.txt里找到输出． update: 2015.04.19 原本的程序是不能调用/bin/目录下的程序的，那多无聊哇．．．我该了部分代码．然后还改了那天杀的两个对齐．．．","link":"/2019/11/Implement-a-Shell-by-yourself-MIT-xv6-shell/"},{"title":"Just Repeat","text":"Just RepeatTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others)Total Submission(s): 391 Accepted Submission(s): 66 Problem Description When Cuber QQ was chatting happily in a QQ group one day, he accidentally noticed that there was a counterfeit of him, who stole his avatar and mimicked his tone, and more excessively, had a nickname “Quber CC”, which was sarcastic to him. So Cuber QQ decided to play a little game with this Quber CC, and their bet was, whoever lost the game would have to do something really humiliating in front of everyone in the QQ group. The game is like this. It’s a traditional card game. Cuber QQ will play first. Cuber QQ, and his opponent (Quber CC of course), will each possess a hand of cards. There is no number (or rank if you prefer) on the card, but only color (or suit if you prefer). The players play cards alternatively, each player can only play one card in each turn. An additional rule is that, a player must not play a card with the same color as any card which has been played by his/her opponent, but coincidence with a card played by himself/herself is acceptable. The player who can’t play any card loses. This might due to the fact that he/she has cards but he cannot play any due to the game rules, or he doesn’t have any cards any more. As a game played between civilized people, the game will be played in a completely transparent manner, where Cuber QQ and Quber CC know exactly what’s left in their opponent’s hand. It’s now a game attracting thousands of eyes, and you decided to invent a predictor whose job is to predict “who will win if both players play smart” to excite the audience. Input The first line of the input is a positive integer tThen follows n m p(1≤n,m≤105 p∈{1,2} a1,a2,…,anand, denoting the colors of Cuber QQ’s hand and Quber CC’s hand, respectively. Unfortunately, as it turns out, the input will be the bottleneck in that case. So we introduceFor, there follows two lines, where the first line is b1,b2,…,bm 0≤ai,bi&lt;109For, there follows two lines, which are ,) to generate {bi}Here are some instructions on how to generate, k1,k2,mod 1unsigned long long k1, k2;unsigned long long rng() { unsigned long long k3 = k1, k4 = k2; k1 = k4; k3 ^= k3 &lt;&lt; 23; k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26); return k2 + k4;}// generateread(k1, k2, mod);for (int i = 0; i &lt; n; ++i) a[i] = rng() % mod;read(k1, k2, mod);for (int i = 0; i &lt; m; ++i) b[i] = rng() % mod; n+mfor 5⋅105 n+mfrom all test cases does not exceed. Output For each test case, predict the winner: “Cuber QQ” or “Quber CC”. Sample Input 123456726 7 11 1 4 5 1 41 9 1 9 8 1 010 20 21 2 101 2 10 Sample Output 12Cuber QQQuber CC Source 2019 Multi-University Training Contest 7 Recommend chendu | We have carefully selected several similar problems for you: 6656 6655 6654 6653 6652 题解： Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long#define int long longconst int maxn=1e5+10;unsigned long long k1, k2;int mod;unsigned long long rng() { unsigned long long k3 = k1, k4 = k2; k1 = k4; k3 ^= k3 &lt;&lt; 23; k2 = k3 ^ k4 ^ (k3 &gt;&gt; 17) ^ (k4 &gt;&gt; 26); return k2 + k4;}inline ll read(){ int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}int n,m;int a[maxn],b[maxn];int v[maxn*2];// inline int getid(int cur){return lower_bound(v.begin(),v.end(),cur)-v.begin()+1;}struct node{ int inx,num; bool operator&lt;(const node&amp;rhs){ return num&gt;rhs.num; }}cn[maxn];int vis[2][maxn*2];int p,po;int t;int cnt[2];signed main(){ //os::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); t=read(); while(t--){ n=read(); m=read(); p=read(); po=0; memset(vis,0,sizeof(vis)); rep(i,1,max(n,m))vis[0][i]=vis[1][i]=0; //v.clear(); if(p==2){ // generate cin&gt;&gt;k1&gt;&gt;k2; mod=read(); for (int i = 1; i &lt;= n; ++i) a[i] = rng() % mod; cin&gt;&gt;k1&gt;&gt;k2; mod=read(); for (int i = 1; i &lt;= m; ++i) b[i] = rng() % mod; } else { for (int i = 1; i &lt;= n; ++i)a[i]=read(); for (int i = 1; i &lt;= m; ++i)b[i]=read(); } rep(i,1,n)v[++po]=a[i]; rep(i,1,m)v[++po]=b[i]; sort(v+1,v+1+po); po=unique(v+1,v+1+po)-v-1; rep(i,1,n)a[i]=lower_bound(v+1,v+1+po,a[i])-v; rep(i,1,m)b[i]=lower_bound(v+1,v+1+po,b[i])-v; for(int i=1;i&lt;=n;++i)vis[0][a[i]]++; for(int i=1;i&lt;=m;++i)vis[1][b[i]]++; int pos=0; for(int i=1;i&lt;=po;++i){ if(vis[0][i]&gt;0&amp;&amp;vis[1][i]&gt;0){ cn[++pos].inx=i; cn[pos].num=vis[0][i]+vis[1][i]; } } sort(cn+1,cn+1+pos); cnt[0]=cnt[1]=0; rep(i,1,pos){ cnt[!(i&amp;1)]+=vis[!(i&amp;1)][cn[i].inx]; vis[0][cn[i].inx]=0; vis[1][cn[i].inx]=0; } rep(i,1,n)if(vis[0][a[i]])cnt[0]++; rep(i,1,m)if(vis[1][b[i]])cnt[1]++; if(cnt[0]&gt;cnt[1])puts(\"Cuber QQ\"); else puts(\"Quber CC\"); } return 0;}","link":"/2019/08/Just-Repeat/"},{"title":"Kamil and Making a Stream","text":"https://codeforces.com/contest/1230/problem/E 一个区间的gcd最多有lg个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * author: MySakure * created: 24.09.2019 12:20:34 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=1e5+10;using info=map&lt;ll,int&gt;;ll n,a[maxn],id;ll ans;vector&lt;int&gt;g[maxn];const int mod=1e9+7;void dfs(int u,int fa,info cur){ ans+=a[u]; for(const auto&amp;x:cur){ ans+=__gcd(a[u],x.first)*x.second; ans%=mod; } info nxt; nxt[a[u]]++; for(const auto&amp;x:cur){ nxt[__gcd(a[u],x.first)]+=x.second; } for(int i=0;i&lt;int(g[u].size());++i){ int v=g[u][i]; if(v==fa)continue; dfs(v,u,nxt); }}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n; rep(i,1,n)cin&gt;&gt;a[i]; rep(i,1,n-1){ int a,b; cin&gt;&gt;a&gt;&gt;b; g[a].push_back(b); g[b].push_back(a); } dfs(1,-1,info()); cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2019/10/Kamil-and-Making-a-Stream/"},{"title":"Kth Minimum Clique","text":"Kth Minimum Clique 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;int n,k;bitset&lt;101&gt; mark[101];//保存图int w[101];struct node{ bitset&lt;101&gt; flag; long long v; int p; bool operator&lt;(const node &amp;x)const{ return v&gt;x.v; }};priority_queue&lt;node&gt; que;long long BFS(){ long long ans=0; while (que.size()) { if (que.empty()) break; node fir=que.top();que.pop(); k--; if(k==0){ ans=fir.v; break; } for (int i=fir.p+1;i&lt;=n;i++) { int cnt=fir.flag.count(); if (mark[i].count()&amp;&amp;(fir.flag&amp;mark[i]).count()==cnt) { bitset&lt;101&gt; tmp=fir.flag; tmp[i]=1; que.push({tmp,fir.v+w[i],i}); } } } if (que.empty()){ return -1; } else{ return ans; }}int main(){ scanf(\"%d%d\",&amp;n,&amp;k); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;w[i]); for (int i=1;i&lt;=n;i++) { mark[i]=0; for (int j=1;j&lt;=n;j++) { int x;scanf(\"%1d\",&amp;x); if (x) mark[i][j]=1; } } if (k==1){ puts(\"0\"); return 0; } k--; for (int i=1;i&lt;=n;i++) { node qq; qq.flag=0; qq.flag[i]=1; qq.v=w[i]; qq.p=i; que.push(qq); } printf(\"%lld\\n\",BFS()); return 0;}","link":"/2019/07/Kth-Minimum-Clique/"},{"title":"Light bulbs","text":"Light bulbs摘抄自大佬的差分序列性质： 1、差分序列求前缀和可得原序列 2、将原序列区间[L,R]中的元素全部+1，可以转化操作为差分序列L处+1，R+1处-1 3、按照性质2得到，每次修改原序列一个区间+1，那么每次差分序列修改处增加的和减少的相同 1234567891011121314151617181920212223242526272829303132333435363738/** * author: MySakure * created: 17.09.2019 09:54:42 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=2e3+10;pair&lt;int,int&gt;v[maxn];int id,n,m,_;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;_; rep(t,1,_){ cin&gt;&gt;n&gt;&gt;m; id=0; rep(i,1,m){ int a,b; cin&gt;&gt;a&gt;&gt;b; v[++id]=mk(a,1); v[++id]=mk(b+1,-1); } sort(v+1,v+1+id); int s=0,ans=0; rep(i,1,id){ s+=v[i].second; if(s&amp;1)ans+=v[i+1].first-v[i].first; } cout&lt;&lt;\"Case #\"&lt;&lt;t&lt;&lt;\": \"&lt;&lt;ans&lt;&lt;'\\n'; } return 0;}","link":"/2019/09/Light%20bulbs/"},{"title":"MMSet2","text":"链接：https://ac.nowcoder.com/acm/contest/15/C来源：牛客网 时间限制：C/C++ 3秒，其他语言6秒 空间限制：C/C++ 131072K，其他语言262144K 64bit IO Format: %lld 题目描述 给定一棵n个节点的树，点编号为1…n。 Q次询问，每次询问给定一个点集S，令， 你需要求出。 其中dist(u,v)表示树上路径(u,v)的边数。 输入描述:1第一行一个整数n，接下来n−1行每行两个整数表示树上的一条边。接下来一行一个整数Q，接着Q行，每行第一个数是|S|，剩下|S|个互不相同的数代表这个集合。 输出描述:1输出Q行，每行一个整数表示答案。 示例1 输入复制 1234531 21 312 2 3 输出复制 11 备注:1n≤3×105,|S|≥1,∑|S|≤106 题解：作者：王阿清https://www.nowcoder.com/discuss/148402?type=post&amp;order=time&amp;pos=&amp;page=0来源：牛客网 不难发现答案就是 ![img](https://uploadfiles.nowcoder.com/images/20181218/8030387_1545100078791_BBDA6409747C3825F23430B502E55CE2)。 证明可以这样考虑： 二分答案d,判断是否存在一个点u，使得 f(u)≤d。也就是。即以S中的每个点为圆心，画一个半径为d的圆，这些圆都包括了u。 那么存在这样一个u就表示这些圆都有交。若d&lt;L，直径端点的两个圆无交，若d=L，因为任意两个点的距离 ≤ 直径，因此任意两个点的圆都有交。所以L是d的最小值。 点集直径很好求。当然可以建个虚树DP一下，不过这样就要排序，复杂度带log了。 注意到一个事实：令dia(T)=(a,b)表示T的直径是a,b，那么 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * author: MySakure * created: 25.09.2019 19:10:24 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long#define int long longconst int maxn=3e5+10;int n,dep[maxn],fa[maxn][33],s,m,q[signed(1e6+10)];vector&lt;int&gt;g[maxn];void dfs(int u,int fat,int deep){ fa[u][0]=fat; dep[u]=deep; for(int i=1;i&lt;=30;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=0;i&lt;signed(g[u].size());++i){ int v=g[u][i]; if(v==fat)continue; dfs(v,u,deep+1); }}int get(int u,int pos){ for(int i=0;i&lt;=30;++i){ if(pos&amp;(1&lt;&lt;i))u=fa[u][i]; } return u;}int lca(int a,int b){ if(dep[a]&lt;dep[b])swap(a,b); int x=dep[a]-dep[b]; a=get(a,x); //务必判断 if(a==b)return a; for(int i=29;i&gt;=0;--i){ if(fa[a][i]==fa[b][i])continue; a=fa[a][i]; b=fa[b][i]; } return fa[a][0];}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n; rep(i,1,n-1){ int a,b; cin&gt;&gt;a&gt;&gt;b; g[a].push_back(b); g[b].push_back(a); } //cerr&lt;&lt;\"dfs start\"&lt;&lt;endl; dfs(1,1,1); //cerr&lt;&lt;\"dfs end\"&lt;&lt;endl; cin&gt;&gt;m; while(m--){ cin&gt;&gt;s; int x=0; rep(i,1,s){ cin&gt;&gt;q[i]; if(dep[x]&lt;dep[q[i]])x=q[i]; } //cerr&lt;&lt;\"debug \"&lt;&lt;endl; int ans=0; for(int i=1;i&lt;=s;++i){ ans=max(ans,dep[x]+dep[q[i]]-2*dep[lca(x,q[i])]); } cout&lt;&lt;(ans+1)/2&lt;&lt;endl; } return 0;}","link":"/2019/09/MMSet2/"},{"title":"Marbles","text":"MarblesThe main fact is that the number of colors is less than $20$, which allows us to use exponential solutions. For each pair of colors $(i,j)$, we can calculate $cnt[i][j]$ — the number of swaps required to place all marbles of color ii before all marbles of color $j$ (if we consider only marbles of these two colors). We can store a sorted vector for each color, and calculate this information for a fixed pair with two pointers. Then let’s use subset DP to fix the order of colors. Let $d[mask]$ be the minimum number of operations to correctly order all marbles from the $mask$ of colors. Let’s iterate on the next color we consider — it should be a position in binary representation of $mask$ with 00 in it. We will place all marbles of this color after all marbles we already placed. If we fix a new color ii, let’s calculate the $sum$ (the additional number of swaps we have to make) by iterating on the bit $j$ equal to 11 in the $mask$, and increasing $sum$ by $cnt[j][i]$ for every such bit. The new state of DP can be calculated as $nmask=mask|(1«i)$. So the transition can be implemented as $d[nmask]=min(d[nmask],d[mask]+sum)$. The answer is the minimum number of swaps required to place all the colors, and that is $d[220−1]$ 大佬解释：https://www.cnblogs.com/heyuhhh/p/11530744.html 题意：给出$n$个数，每个数大小不超过$20$。现在可以执行操作：任意交换两个相邻的数。现要求最少的次数使得颜色相同的数在同一块中。 思路： 注意到每个数大小不超过$20$，那么我们可以考虑对权值来状压。 我们首先维护一个$cnt[i,j]$，表示将ii类颜色放在$j$类后面所需最小代价，注意，此时我们只考虑$i,j$两种颜色，不考虑其余的颜色。 之后我们枚举状态ss，表示某些颜色被分为一块的最小代价。之后枚举一个新的颜色ii加进去，假设$j1,j2,⋯,jm$的颜色已经分成一块了，代价就加上$∑mk=1cnt[i,jk]$，最后取$min$即可。 做法就说完了，感觉并不是很难。我觉得这个题巧妙的地方就是预处理的这个$cnt$数组。预处理的时候只考虑了两个数，为什么？这其实就相当于将$n^2$个关系一一拆开，假设$i,j$中间还有一个颜色$k$，我们一开始考虑时不会算上$k$，$k$的贡献我们会在最后算上。因为无论哪一次交换，都被包含在这$n^2$个关系中。虽然中间结果可能不正确，最后一定会覆盖到正确的情况，就类似于曼哈顿距离拆绝对值进行枚举，虽然中间结果不一定是正确的，但最终答案肯定能够覆盖到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * author: MySakure * created: 17.09.2019 14:22:40 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=30;const int maxm=4e5+10;const int up=(1&lt;&lt;20)-1;ll n,m,cnt[maxn][maxn],sz[maxn],v[maxn][maxm];ll ans[1&lt;&lt;20];signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n; rep(i,1,n){ int tmp; cin&gt;&gt;tmp; v[tmp][++sz[tmp]]=i; } rep(i,1,20) rep(j,1,20){ if(i==j)continue; int pos1=1,pos2=1; while(pos2&lt;=sz[j]){ if(pos1&gt;sz[i]||v[i][pos1]&gt;v[j][pos2])cnt[i][j]+=pos1-1,pos2++; else pos1++; } } rep(i,1,(1&lt;&lt;20)-1)ans[i]=1e18; for(int i=0;i&lt;((1&lt;&lt;20)-1);++i){ for(int j=1;j&lt;=20;++j){ if(i&amp;(1&lt;&lt;(j-1)))continue; ll tmp=0; for(int k=0;k&lt;20;++k) if(i&amp;(1&lt;&lt;k))tmp+=cnt[k+1][j]; ans[i|(1&lt;&lt;(j-1))]=min(ans[i|(1&lt;&lt;(j-1))],tmp+ans[i]); } } cout&lt;&lt;ans[(1&lt;&lt;20)-1]&lt;&lt;endl; return 0;}","link":"/2019/09/Marbles/"},{"title":"Minimum-Inversion-Number","text":"Minimum Inversion Number 注意：一定要注意是多组数据输入，被坑了不是一次两次了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5e3+10;int n,vec[maxn],Seg[maxn],ans;int lowerbit(int cur){ return cur&amp;-cur;}void update(int cur){ while(cur&lt;=n){ Seg[cur]++; cur+=lowerbit(cur); }}int find(int cur){ int ans=0; while(cur){ ans+=Seg[cur]; cur-=lowerbit(cur); } return ans;}int main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); while(cin&gt;&gt;n){ for(int i=1;i&lt;=n;++i)Seg[i]=0; ans=0; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;vec[i]; vec[i]+=1; update(vec[i]); ans+=i-find(vec[i]); } //cout&lt;&lt;ans&lt;&lt;endl; int curans=ans; for(int i=1;i&lt;n;++i){ curans-=vec[i]-1; curans+=n-vec[i]; //cerr&lt;&lt;\"debug \"&lt;&lt;curans&lt;&lt;endl; ans=min(ans,curans); } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2019/07/Minimum-Inversion-Number/"},{"title":"Operating system interfaces","text":"大部分内容来自xv6， shell是一个简单的读取用户输入指令并执行它们的程序，是一个用户级程序，而不是内核级程序，这意味着shell可以被简单的代替。实际上，现代的Linux确实有各种各样的shell。 Processes and memory一个进程通过fork系统调用产生一个新的进程。fork创造一个新的进程，称为子进程，和调用进程（父进程）有着相同的内存内容。fork调用一次，返回两次，在父进程中返回子进程的PID，在子进程中返回0。例如下面的程序： 1234567891011int pid = fork();if(pid &gt; 0){ printf(\"parent: child=%d\\n\", pid); pid = wait(); printf(\"child %d is done\\n\", pid);} else if(pid == 0){ printf(\"child: exiting\\n\"); exit();} else { printf(\"fork error\\n\");} exit系统调用使调用进程终止运行，并返还拥有的系统资源，例如内存和打开文件。wait返回一个退出的子进程的pid。如果没有子进程退出，将会等待某个子进程退出。 子进程与父进程在不同的内存和寄存器中运行，改变其中一个进程的内容不会影响另一个。 exec系统调用永不返回，他将用一个新的内存镜像代替当前的进程的内存内容。新的内存镜像必须有某个特定的格式。exec调用继承调用进程的pid和打开文件。exec调用有两个参数，文件的名字和可执行命令的命令行参数，例如： 123456char *argv[3];argv[0] = \"echo\";argv[1] = \"hello\";argv[2] = 0;exec(\"/bin/echo\", argv);printf(\"exec error\\n\"); This fragment replaces the calling program with an instance of the program /bin/echo running with the argument list echo hello. Most programs ignore the first argument, which is conventionally the name of the program. xv6的shell利用上述的系统调用帮助用户执行程序，main函数关于shell的结构是简单的。main利用getcmd函数读取命令行输入，然后调用fork函数，生成一个shell的子进程。父进程shell简单的调用wait等待子进程执行结束，子进程通过exec系统调用执行用户输入的命令。 一个进程可以通过sbrk(n)申请内存空间。 I/O and File descriptors一个文件描述符是一个小的整数代表着一个内核维护的对象，可以被进程读取或者写入。一个进程可以通过打开一个文件，目录或者设备，或者通过新建一个管道，或者通过复制一个已存在的文件描述符。文件描述符为文件，管道和设备提供了一个统一的接口，使他们看起来都像是统一的字节流。 Internally, the xv6 kernel uses the file descriptor as an index into a per-process table, so that every process has a private space of file descriptors starting at zero. By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). As we will see, the shell exploits the convention to implement I/O redirectionand pipelines. The shell ensures that it always has three file descriptors open (8507) ,which are by default file descriptors for the console. 进程在文件描述符0读入，在文件描述符1输出，在文件描述符3输出标准错误。shell保证他总是有三个文件描述符打开。 The read and write system calls read bytes from and write bytes to open files named by file descriptors. The call read(fd, buf, n) reads at most n bytes from the file descriptor fd, copies them into buf, and returns the number of bytes read. Each file descriptor that refers to a file has an offset associated with it. Read reads data from the current file offset and then advances that offset by the number of bytes read: a subsequent read will return the bytes following the ones returned by the first read. When there are no more bytes to read, read returns zero to signal the end of the file. The call write(fd, buf, n) writes n bytes from buf to the file descriptor fd and returns the number of bytes written. Fewer than n bytes are written only when an error occurs. Like read, write writes data at the current file offset and then advances that offset by the number of bytes written: each write picks up where the previous one left off. cat命令将它的标准输入复制到标准输出。 一个值得注意的事情是，cat并不知道它的输入是来自于一个文件，一个console，或者一个管道。同样的，他并不知道它的输出指向哪里。标准输入为文件描述符0，标准输出为1允许cat一个简单的实现。 close将会释放一个文件描述符，使他可以被一个新的文件使用。A newly allocated file descriptor is al-ways the lowest-numbered unused descriptor of the current process. File descriptors and fork interact to make I/O redirection easy to implement. Fork copies the parent’s file descriptor table along with its memory, so that the child starts with exactly the same open files as the parent. The system call exec replaces the calling process’s memory but preserves its file table. This behavior allows the shell toimplement I/O redirection by forking, reopening chosen file descriptors, and then execing the new program. exec会替换父进程的内存内容，但是会保留文件描述符。 Here is a simplified version of the code a shell runs for thecommand cat &lt;input.txt: 12345678char *argv[2];argv[0] = \"cat\";argv[1] = 0;if(fork() == 0) {close(0);open(\"input.txt\", O_RDONLY);exec(\"cat\", argv);} After the child closes file descriptor 0, open is guaranteed to use that file descriptor for the newly opened input.txt: 0 will be the smallest available file descriptor. Cat then executes with file descriptor 0 (standard input) referring to input.txt. The code for I/O redirection in the xv6 shell works in exactly this way (8430) . Recall that at this point in the code the shell has already forked the child shell and that runcmd will call exec to load the new program. Now it should be clear why it is a good idea that fork and exec are separate calls. This separation allows the shell to fix up the child process before the child runs the intended program. Although fork copies the file descriptor table, each underlying file offset is shared between parent and child. Consider this example: 1234567if(fork() == 0) {write(1, \"hello \", 6);exit();} else {wait();write(1, \"world\\n\", 6);} At the end of this fragment, the file attached to file descriptor 1 will contain the data hello world. The write in the parent (which, thanks to wait, runs only after the child is done) picks up where the child’s write left off. This behavior helps produce sequential output from sequences of shell commands, like (echo hello; echo world)&gt;output.txt. The dup system call duplicates an existing file descriptor, returning a new one that refers to the same underlying I/O object. Both file descriptors share an offset, just as the file descriptors duplicated by fork do. This is another way to write hello world into a file: 123fd = dup(1);write(1, \"hello \", 6);write(fd, \"world\\n\", 6); Two file descriptors share an offset if they were derived from the same original file descriptor by a sequence of fork and dup calls. Otherwise file descriptors do not share offsets, even if they resulted from open calls for the same file. Dup allows shells to implement commands like this: ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1. The 2&gt;&amp;1 tells the shell to give the command a file descriptor 2 that is a dupli- cate of descriptor 1. Both the name of the existing file and the error message for the non-existing file will show up in the file tmp1. The xv6 shell doesn’t support I/O redi- rection for the error file descriptor, but now you know how to implement it. File descriptors are a powerful abstraction, because they hide the details of what they are connected to: a process writing to file descriptor 1 may be writing to a file, to a device like the console, or to a pipe. PipesA pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing. Writing data to one end of the pipe makes that data available for reading from the other end of the pipe. Pipes provide a way for processes to communicate. The following example code runs the program wc with standard input connected to the read end of a pipe. 管道是进程通信的一种方式。 12345678910111213141516int p[2];char *argv[2];argv[0] = \"wc\";argv[1] = 0;pipe(p);if(fork() == 0) {close(0);dup(p[0]);close(p[0]);close(p[1]);exec(\"/bin/wc\", argv);} else {write(p[1], \"hello world\\n\", 12);close(p[0]);close(p[1]);} The program calls pipe, which creates a new pipe and records the read and write file descriptors in the array p. After fork, both parent and child have file descriptors refer- ring to the pipe. The child dups the read end onto file descriptor 0, closes the file de- scriptors in p, and execs wc. When wc reads from its standard input, it reads from the pipe. The parent writes to the write end of the pipe and then closes both of its file descriptors. If no data is available, a read on a pipe waits for either data to be written or all file descriptors referring to the write end to be closed; in the latter case, read will re- turn 0, just as if the end of a data file had been reached. The fact that read blocks until it is impossible for new data to arrive is one reason that it’s important for the child to close the write end of the pipe before executing wc above: if one of wc’s file descriptors referred to the write end of the pipe, wc would never see end-of-file. The xv6 shell implements pipelines such as grep fork sh.c | wc -l in a man- ner similar to the above code (8450) . The child process creates a pipe to connect the left end of the pipeline with the right end. Then it calls runcmd for the left end of the pipeline and runcmd for the right end, and waits for the left and the right ends to fin- ish, by calling wait twice. The right end of the pipeline may be a command that itselfincludes a pipe (e.g., a | b | c), which itself forks two new child processes (one for b and one for c). Thus, the shell may create a tree of processes. The leaves of this tree are commands and the interior nodes are processes that wait until the left and right children complete. In principle, you could have the interior nodes run the left end of a pipeline, but doing so correctly would complicate the implementation. Pipes may seem no more powerful than temporary files: the pipeline 1echo hello world | wc could be implemented without pipes as 1echo hello world &gt;/tmp/xyz; wc &lt;/tmp/xyz There are at least three key differences between pipes and temporary files. First, pipes automatically clean themselves up; with the file redirection, a shell would have to be careful to remove /tmp/xyz when done. Second, pipes can pass arbitrarily long streams of data, while file redirection requires enough free space on disk to store all the data. Third, pipes allow for synchronization: two processes can use a pair of pipes to send messages back and forth to each other, with each read blocking its calling pro- cess until the other process has sent data with write. File systemThe xv6 file system provides data files, which are uninterpreted byte arrays, and directories, which contain named references to data files and other directories. Xv6 implements directories as a special kind of file. The directories form a tree, starting at a special directory called the root. A path like /a/b/c refers to the file or directory named c inside the directory named b inside the directory named a in the root direc- tory /. Paths that don’t begin with / are evaluated relative to the calling process’s cur- rent directory, which can be changed with the chdir system call. Both these code fragments open the same file (assuming all the directories involved exist): 1234chdir(\"/a\");chdir(\"b\");open(\"c\", O_RDONLY);open(\"/a/b/c\", O_RDONLY); The first fragment changes the process’s current directory to /a/b; the second neither refers to nor modifies the process’s current directory. There are multiple system calls to create a new file or directory: mkdir creates a new directory, open with the O_CREATE flag creates a new data file, and mknod creates a new device file. This example illustrates all three: 1234mkdir(\"/dir\");fd = open(\"/dir/file\", O_CREATE|O_WRONLY);close(fd);mknod(\"/console\", 1, 1); Mknod creates a file in the file system, but the file has no contents. Instead, the file’s metadata marks it as a device file and records the major and minor device numbers (the two arguments to mknod), which uniquely identify a kernel device. When a process later opens the file, the kernel diverts read and write system calls to the kernel device implementation instead of passing them to the file system. fstat retrieves information about the object a file descriptor refers to. It fills in a struct stat, defined in stat.h as: 1234567891011#define T_DIR 1 // Directory#define T_FILE 2 // File#define T_DEV 3 // Devicestruct stat { short type; // Type of file int dev; // File system's disk device uint ino; // Inode number short nlink; // Number of links to file uint size; // Size of file in bytes}; A file’s name is distinct from the file itself; the same underlying file, called an in- ode, can have multiple names, called links. The link system call creates another file system name referring to the same inode as an existing file. This fragment creates a new file named both a and b. 12open(\"a\", O_CREATE|O_WRONLY);link(\"a\", \"b\"); Reading from or writing to a is the same as reading from or writing to b. Each inode is identified by a unique inode number. After the code sequence above, it is possible to determine that a and b refer to the same underlying contents by inspecting the result of fstat: both will return the same inode number (ino), and the nlink count will be set to 2. The unlink system call removes a name from the file system. The file’s inode and the disk space holding its content are only freed when the file’s link count is zero and no file descriptors refer to it. Thus adding 1unlink(\"a\"); to the last code sequence leaves the inode and file content accessible as b. Further- more, 12fd = open(\"/tmp/xyz\", O_CREATE|O_RDWR);unlink(\"/tmp/xyz\"); is an idiomatic way to create a temporary inode that will be cleaned up when the pro- cess closes fd or exits. Xv6 commands for file system operations are implemented as user-level programs such as mkdir, ln, rm, etc. This design allows anyone to extend the shell with new user commands. In hind-sight this plan seems obvious, but other systems designed at the time of Unix often built such commands into the shell (and built the shell into the kernel). One exception is cd, which is built into the shell (8516) . cd must change the cur- rent working directory of the shell itself. If cd were run as a regular command, then the shell would fork a child process, the child process would run cd, and cd would change the child’s working directory. The parent’s (i.e., the shell’s) working directory would not change. cd是shell内置的命令。如果cd不是shell的命令，那么shell将会fork一个子进程，子进程更改工作目录，但是父进程的工作目录不会改变。 Real worldUnix’s combination of the ‘‘standard’’ file descriptors, pipes, and convenient shell syntax for operations on them was a major advance in writing general-purpose reusable programs. The idea sparked a whole culture of ‘‘software tools’’ that was re- sponsible for much of Unix’s power and popularity, and the shell was the first so-called ‘‘scripting language.’’ The Unix system call interface persists today in systems like BSD, Linux, and Mac OS X. Modern kernels provide many more system calls, and many more kinds of kernel services, than xv6. For the most part, modern Unix-derived operating systems have not followed the early Unix model of exposing devices as special files, like the console device file discussed above. The authors of Unix went on to build Plan 9, which ap- plied the ‘‘resources are files’’ concept to modern facilities, representing networks, graphics, and other resources as files or file trees. The file system abstraction has been a powerful idea, most recently applied to network resources in the form of the World Wide Web. Even so, there are other mod- els for operating system interfaces. Multics, a predecessor of Unix, abstracted file stor- age in a way that made it look like memory, producing a very different flavor of inter- face. The complexity of the Multics design had a direct influence on the designers of Unix, who tried to build something simpler. This book examines how xv6 implements its Unix-like interface, but the ideas and concepts apply to more than just Unix. Any operating system must multiplex process- es onto the underlying hardware, isolate processes from each other, and provide mech- anisms for controlled inter-process communication. After studying xv6, you should be able to look at other, more complex operating systems and see the concepts underlying xv6 in those systems as well.","link":"/2019/11/Operating-system-interfaces/"},{"title":"Operation","text":"题目There is an integer sequence a of length n and there are two kinds of operations:• 0 l r: select some numbers from a l …a r so that their xor sum is maximum, and print the maximumvalue.• 1 x: append x to the end of the sequence and let n = n + 1. InputThere are multiple test cases. The first line of input contains an integer T(T ≤ 10), indicating the numberof test cases.For each test case:The first line contains two integers n,m(1 ≤ n ≤ 5 × 10 5 ,1 ≤ m ≤ 5 × 10 5 ), the number of integersinitially in the sequence and the number of operations.The second line contains n integers a 1 ,a 2 ,…,a n (0 ≤ a i &lt; 2 30 ), denoting the initial sequence.Each of the next m lines contains one of the operations given above.It’s guaranteed thatPn ≤ 10 6 ,Pm ≤ 10 6 ,0 ≤ x &lt; 2 30 .And operations will be encrypted. You need to decode the operations as follows, where lastans denotesthe answer to the last type 0 operation and is initially zero:For every type 0 operation, let l=(l xor lastans)mod n + 1, r=(r xor lastans)mod n + 1, and thenswap l and r if l&gt;r.For every type 1 operation, let x=x xor lastans.OutputFor each type 0 operation, please output the maximum xor sum in a single line. 题解暴力的做法可以用数据结构维护区间线性基，但肯定过不了。贪心地维护序列的前缀线性基 (上三角形态)，对于每个线性基，将出现位置靠右的数字尽可能地放在高位，也就是说在插入新数字的时候，要同时记录对应位置上数字的出现位置，并且在找到可以插入的位置的时候，如果新数字比位置上原来的数字更靠右，就将该位置上原来的数字向低位推。在求最大值的时候，从高位向低位遍历，如果该位上的数字出现在询问中区间左端点的右侧且可以使答案变大，就异或到答案里。对于线性基的每一位，与它异或过的线性基更高位置上的数字肯定都出现在它右侧 (否则它就会被插入在那个位置了)，因此做法的正确性显然。 标程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=500000+10;int T,n,m,op,l,r,tmp,ans,a[MAXN],f[MAXN][32],pos[MAXN][32];inline int Read() { int x=0,f=1; char ch=getchar(); while (ch&lt;'0'||ch&gt;'9') {if (ch=='-') f=-f; ch=getchar();} while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar(); return x*f;}char s[30];inline void writeln(int x){ if (x&lt;0) putchar('-'),x=-x; if (!x) putchar('0'); else { int len=0; while (x) s[++len]=x%10+'0',x/=10; while (len) putchar(s[len--]); } putchar('\\n');}inline void Add(int i,int x){ int k=i; for (int j=30;j&gt;=0;--j) f[i][j]=f[i-1][j],pos[i][j]=pos[i-1][j]; for (int j=30;j&gt;=0;--j) if (x&gt;&gt;j) { if (!f[i][j]) { f[i][j]=x; pos[i][j]=k; break; } else { if (k&gt;pos[i][j]) { tmp=k,k=pos[i][j],pos[i][j]=tmp; tmp=x,x=f[i][j],f[i][j]=tmp; } x^=f[i][j]; } }}int main(){ //freopen(\"test.in\",\"r\",stdin); //freopen(\"test.out\",\"w\",stdout); T=Read(); while (T--) { n=Read(),m=Read(); for (int i=1;i&lt;=n;++i) a[i]=Read(),Add(i,a[i]); ans=0; while (m--) { op=Read(); if (op) a[++n]=Read()^ans,Add(n,a[n]); else { l=Read(),r=Read(); l=(l^ans)%n+1,r=(r^ans)%n+1; if (l&gt;r) swap(l,r); ans=0; for (int j=30;j&gt;=0;--j) if((ans^f[r][j])&gt;ans&amp;&amp;pos[r][j]&gt;=l) ans^=f[r][j]; writeln(ans); } } for (int i=1;i&lt;=n;++i) for (int j=30;j&gt;=0;--j) f[i][j]=pos[i][j]=0; } return 0;}","link":"/2019/07/Operation/"},{"title":"P1273 有线电视网","text":"题目描述某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的内部节点。 从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。 现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。 写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。 输入格式输入文件的第一行包含两个用空格隔开的整数N和M，其中2≤N≤3000，1≤M≤N-1，N为整个有线电视网的结点总数，M为用户终端的数量。 第一个转播站即树的根结点编号为1，其他的转播站编号为2到N-M，用户终端编号为N-M+1到N。 接下来的N-M行每行表示—个转播站的数据，第i+1行表示第i个转播站的数据，其格式如下： K A1 C1 A2 C2 … Ak Ck K表示该转播站下接K个结点(转播站或用户)，每个结点对应一对整数A与C，A表示结点编号，C表示从当前转播站传输信号到结点A的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。 输出格式输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。 输入输出样例输入 #1复制 输出 #1复制 说明/提示样例解释 如图所示，共有五个结点。结点①为根结点，即现场直播站，②为一个中转站，③④⑤为用户端，共M个，编号从N-M+1到N，他们为观看比赛分别准备的钱数为3、4、2，从结点①可以传送信号到结点②，费用为2，也可以传送信号到结点⑤，费用为3（第二行数据所示），从结点②可以传输信号到结点③，费用为2。也可传输信号到结点④，费用为3（第三行数据所示），如果要让所有用户（③④⑤）都能看上比赛，则信号传输的总费用为： 2+3+2+3=10，大于用户愿意支付的总费用3+4+2=9，有线电视网就亏本了，而只让③④两个用户看比赛就不亏本了。 抄的大佬讲解：这是一个非常不错的树形背包的题目，有助于理解树形背包的实质！ 按照常见树形背包定义状态：设dp[u][j]表示在以u为根的子树中，选择j个客户所能获得的最大收益。 状态转移：dp[u][j]=max(dp[u][j-k],dp[v][k]-w(u,v)); 树形背包一直有个疑惑，为什么在枚举背包容量的时候要反向枚举，浅层次的理解就是套用01背包枚举体积；但是细想又不对，因为01背包只有在使用滚动数组的时候才必须逆推；如果使用2维的话不需要； 那是不是意味着树形背包中原本应该是3维，滚动优化为2维了呢？？？ 仔细回味01背包的状态定义：f[i][j]表示在前i个物品占用体积为j的空间能够得到的最大价值；这里有一个限定前i个，初次学习树形背包一看人家的代码感觉就是这么写的，并没有深入去思考为什么。 所以仿照01背包定义dp[i][u][j]表示在以u为根的子树的前i棵子树中选择j个节点能够获得的最大费用 dp[i][u][j]=max(dp[i-1][u][j-k]+dp[v的总儿子数][v][k]-w(u,v)) 以上就是树形dp没有滚动优化的状态方程，为什么需要滚动优化？为什么可以滚动优化？ 为什么需要滚动优化？————不滚动很可能会MLE 为什么可以滚动优化？？？ 1.对于u而言很显然是可以滚动优化的，只不过j-k&lt;j要保证dp[u][j-k]是第i-1轮的值则j必须要逆推！！！ 2.关键在于v，滚动优化后怎么保证每次dp[v][k]==dp[v的总儿子数][v][k]? 其实关键还是在于01背包的本质的理解，dp[i][v][j]从v的前i个子树中选择j个节点， 递推求解的时候是i依次增大的，所以结束时一定有”i==v的总儿子数” 因此使用滚动数组计算v结束后，dp[v][k]中一定是保存的从v的所有儿子中选k个节点的值； 从而保证dp[v][k]==dp[v的总儿子数][v][k] 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;const int N=3001;struct node{ int to,w,nxt; node(int a=0,int b=0,int c=0):to(a),w(b),nxt(c){}} g[N];int fir[N],cnt,money[N],n,m,dp[N][N];void add(int f,int t,int w){ g[++cnt]=node(t,w,fir[f]); fir[f]=cnt;}int dfs(int u){ if(u&gt;n-m){//u是一个叶子节点 dp[u][1]=money[u];//叶子节点则选一个节点得到最大利益一定是该节点出的钱 dp[u][0]=0; return 1; } dp[u][0]=0;//不选任何节点一定收益为0 int leafs=0;//统计以u为根的子树中叶子的数目 for(int i=fir[u];i;i=g[i].nxt){ int v=g[i].to,w=g[i].w; int t=dfs(v);//t是v为根的子树中的叶子节点数 leafs+=t; for(int j=leafs;j&gt;0;j--)//在前i个子树中选，因此这里只需要知道前i个子树的总结点数，而不是u的所有节点个数 for(int k=0,kk=min(j,t);k&lt;=kk;k++)//v最多分到的节点不可能超过他的叶子数，也不能超过其所在子树节点总数 dp[u][j]=max(dp[u][j],dp[u][j-k]+dp[v][k]-w); } return leafs;}int main(){ int x,t,w; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n-m;i++){ cin&gt;&gt;x; for(int j=0;j&lt;x;j++){ cin&gt;&gt;t&gt;&gt;w; add(i,t,w); } } for(int j=n-m+1;j&lt;=n;j++) cin&gt;&gt;money[j]; memset(dp,0x8f,sizeof(dp)); memset(dp,0,sizeof(dp[0])); dfs(1); for(int i=m;i&gt;=0;i--){//将用户反向枚举，一旦发现非负数就输出 if(dp[1][i]&gt;=0){ cout&lt;&lt;i&lt;&lt;endl; break; } } return 0;}","link":"/2019/08/P1273/"},{"title":"P4513 小白逛公园","text":"https://www.luogu.org/problem/P4513 题目背景小新经常陪小白去公园玩，也就是所谓的遛狗啦… 题目描述在小新家附近有一条“公园路”，路的一边从南到北依次排着nn个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。 一开始，小白就根据公园的风景给每个公园打了分-.-。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第aa个和第bb个公园之间（包括aa、bb两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。 那么，就请你来帮小白选择公园吧。 输入格式第一行，两个整数NN和MM，分别表示表示公园的数量和操作（遛狗或者改变打分）总数。接下来NN行，每行一个整数，依次给出小白 开始时对公园的打分。接下来MM行，每行三个整数。第一个整数KK，11或22。 K=1K=1表示，小新要带小白出去玩，接下来的两个整数aa和bb给出了选择公园的范围（1≤a,b≤N1≤a,b≤N）。测试数据可能会出现a&gt;ba&gt;b的情况，需要进行交换； K=2K=2表示，小白改变了对某个公园的打分，接下来的两个整数pp和ss，表示小白对第pp个公园的打分变成了ss（1≤p≤N1≤p≤N）。其中，1≤N≤500 0001≤N≤500000，1≤M≤100 0001≤M≤100000，所有打分都是绝对值不超过10001000的整数。 输出格式小白每出去玩一次，都对应输出一行，只包含一个整数，表示小白可以选出的公园得分和的最大值。 输入输出样例输入 #1复制 输出 #1复制 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long//#define int long longconst int maxn = 5e5 + 10;struct node { int sum, ls, rs; int l, r; int Max; //node() :sum(0), ls(0), rs(0), l(0), r(0), Max(0) {}}tr[maxn &lt;&lt; 3];int n, m, arr[maxn], k;void build(int ro, int l, int r) { tr[ro].l = l, tr[ro].r = r; if (l == r) { tr[ro].Max = arr[l]; tr[ro].sum = arr[l]; tr[ro].ls = arr[l]; tr[ro].rs = arr[l]; return; } int mid = (l + r) &gt;&gt; 1; build(ro &lt;&lt; 1, l, mid); build(ro &lt;&lt; 1 | 1, mid + 1, r); tr[ro].ls = max(tr[ro &lt;&lt; 1].ls, tr[ro &lt;&lt; 1].sum + tr[ro &lt;&lt; 1 | 1].ls); tr[ro].rs = max(tr[ro &lt;&lt; 1 | 1].rs, tr[ro &lt;&lt; 1 | 1].sum + tr[ro &lt;&lt; 1].rs); tr[ro].sum = tr[ro &lt;&lt; 1].sum + tr[ro &lt;&lt; 1 | 1].sum; tr[ro].Max = max(tr[ro &lt;&lt; 1].Max, tr[ro &lt;&lt; 1 | 1].Max); tr[ro].Max = max(tr[ro].Max, max(tr[ro].ls, tr[ro].rs)); tr[ro].Max = max(tr[ro].Max, tr[ro &lt;&lt; 1].rs + tr[ro &lt;&lt; 1 | 1].ls);}void update(int ro, int inx, int v) { int l = tr[ro].l, r = tr[ro].r; if (l == inx &amp;&amp; r == inx) { tr[ro].Max = v; tr[ro].sum = v; tr[ro].ls = v; tr[ro].rs = v; return; } int mid = (l + r) &gt;&gt; 1; if (inx &lt;= mid)update(ro &lt;&lt; 1, inx, v); else update(ro &lt;&lt; 1 | 1, inx, v); tr[ro].ls = max(tr[ro &lt;&lt; 1].ls, tr[ro &lt;&lt; 1].sum + tr[ro &lt;&lt; 1 | 1].ls); tr[ro].rs = max(tr[ro &lt;&lt; 1 | 1].rs, tr[ro &lt;&lt; 1 | 1].sum + tr[ro &lt;&lt; 1].rs); tr[ro].sum = tr[ro &lt;&lt; 1].sum + tr[ro &lt;&lt; 1 | 1].sum; tr[ro].Max = max(tr[ro &lt;&lt; 1].Max, tr[ro &lt;&lt; 1 | 1].Max); tr[ro].Max = max(tr[ro].Max, max(tr[ro].ls, tr[ro].rs)); tr[ro].Max = max(tr[ro].Max, tr[ro &lt;&lt; 1].rs + tr[ro &lt;&lt; 1 | 1].ls);}node Quare(int ro, int L, int R) { int l = tr[ro].l, r = tr[ro].r; if (l == L &amp;&amp; r == R)return tr[ro]; int mid = (l + r) &gt;&gt; 1; if (R &lt;= mid) return Quare(ro &lt;&lt; 1, L, R); else if (L &gt; mid)return Quare(ro &lt;&lt; 1 | 1, L, R); else { node ans; node l_ = Quare(ro &lt;&lt; 1, L, mid); node r_ = Quare(ro &lt;&lt; 1 | 1, mid + 1, R); ans.ls = max(l_.ls, l_.sum + r_.ls); ans.rs = max(r_.rs, r_.sum + l_.rs); ans.sum = l_.sum + r_.sum; ans.Max = max(l_.Max, r_.Max); ans.Max = max(ans.Max, max(ans.ls, ans.rs)); ans.Max = max(ans.Max, l_.rs + r_.ls); return ans; }}signed main() { scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) { scanf(\"%d\", &amp;arr[i]); } build(1, 1, n); for (int i = 1; i &lt;= m; ++i) { int a, b; scanf(\"%d%d%d\", &amp;k, &amp;a, &amp;b); if (k == 2) { update(1, a, b); } else { if (a &gt; b)swap(a, b); node ans = Quare(1, a, b); printf(\"%d\\n\", ans.Max); } } return 0;}","link":"/2019/08/P4513/"},{"title":"POJ2104","text":"POJ2104 DescriptionYou are working for Macrohard company in data structures department. After failing your previous task about key insertion you were asked to write a new data structure that would be able to return quickly k-th order statistics in the array segment.That is, given an array a[1…n] of different integer numbers, your program must answer a series of questions Q(i, j, k) in the form: “What would be the k-th number in a[i…j] segment, if this segment was sorted?”For example, consider the array a = (1, 5, 2, 6, 3, 7, 4). Let the question be Q(2, 5, 3). The segment a[2…5] is (5, 2, 6, 3). If we sort this segment, we get (2, 3, 5, 6), the third number is 5, and therefore the answer to the question is 5. InputThe first line of the input file contains n — the size of the array, and m — the number of questions to answer (1 &lt;= n &lt;= 100 000, 1 &lt;= m &lt;= 5 000).The second line contains n different integer numbers not exceeding 109 by their absolute values — the array for which the answers should be given.The following m lines contain question descriptions, each description consists of three numbers: i, j, and k (1 &lt;= i &lt;= j &lt;= n, 1 &lt;= k &lt;= j - i + 1) and represents the question Q(i, j, k). OutputFor each question output the answer to it — the k-th number in sorted a[i…j] segment. Sample Input 123457 31 5 2 6 3 7 42 5 34 4 11 7 3 Sample Output 123563 Hint This problem has huge input,so please use c-style input(scanf,printf),or you may got time limit exceed. Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/***************Author:MySakure*Time:2019-05-23*Source:POJ2104*Theme:ChainTree*State:Accept***************/#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e5 + 7;struct node { int l, r, sum;}T[maxn*40];int n, m, x, y, k, root[maxn], a[maxn],cnt;vector&lt;int&gt;v;int getid(int cur) { return lower_bound(v.begin(), v.end(), cur) - v.begin() + 1;}void update(int l, int r, int&amp; x, int y, int pos) { T[++cnt] = T[y], x = cnt, T[x].sum++; if (l == r)return; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid)update(l, mid, T[x].l, T[y].l, pos); else update(mid + 1, r, T[x].r, T[y].r, pos);}int quare(int l, int r, int x, int y, int k) { if (l == r)return l; int mid = (l + r) &gt;&gt; 1; int sum = T[T[y].l].sum - T[T[x].l].sum; if (k &lt;= sum)return quare(l, mid, T[x].l, T[y].l, k); else return quare(mid + 1, r, T[x].r, T[y].r, k - sum);}int main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i], v.push_back(a[i]); sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); for (int i = 1; i &lt;= n; ++i) { update(1, n, root[i], root[i - 1], getid(a[i])); } for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; cout &lt;&lt; v[quare(1, n, root[x - 1], root[y], k) - 1] &lt;&lt; endl; } return 0;}","link":"/2019/07/POJ2104/"},{"title":"Planting Trees","text":"Planting Trees 链接：https://ac.nowcoder.com/acm/contest/883/F来源：牛客网 The semester is finally over and the summer holiday is coming. However, as part of your university’s graduation requirement, you have to take part in some social service during the holiday. Eventually, you decided to join a volunteer group which will plant trees in a mountain. To simplify the problem, let’s represent the mountain where trees are to be planted with an N×NN \\times NN×N grid. Let’s number the rows 1\\ 1 1 to N\\ N N from top to bottom, and number the columns 1\\ 1 1 to N\\ N N from left to right. The elevation of the cell in the i\\ i i-th row and j\\ j j-th column is denoted by ai,ja_{i,j}ai,j. Your leader decides that trees should be planted in a rectangular area within the mountain and that the maximum difference in elevation among the cells in that rectangle should not exceed M. In other words, if the coordinates of the top-left and the bottom-right corners of the rectangle are (x1,y1)(x_1,y_1)(x1,y1) and (x2,y2)(x_2,y_2)(x2,y2), then the condition ∣ai,j−ak,l∣≤M|a_{i,j} - a_{k,l}| \\le M∣ai,j−ak,l∣≤M must hold for x1≤i,k≤x2, y1≤j,l≤y2x_1 \\le i,k \\le x_2, \\ y_1 \\le j,l \\le y_2x1≤i,k≤x2, y1≤j,l≤y2. Please help your leader calculate the maximum possible number of cells in such a rectangle so that he’ll know how many trees will be planted. 输入描述:The input contains multiple cases. The first line of the input contains a single integer T (1≤T≤1000)T \\ (1 \\le T \\le 1000)T (1≤T≤1000), the number of cases.For each case, the first line of the input contains two integers N (1≤N≤500)N\\ (1 \\le N \\le 500)N (1≤N≤500) and M (0≤M≤105)M\\ (0 \\le M \\le 10^5)M (0≤M≤105). The following N lines each contain N integers, where the j\\ j j-th integer in the i\\ i i-th line denotes ai,j (1≤ai,j≤105)a_{i,j} \\ (1 \\le a_{i,j} \\le 10^5)ai,j (1≤ai,j≤105).It is guaranteed that the sum of N3N^3N3 over all cases does not exceed 25⋅10725 \\cdot 10^725⋅107. 输出描述:For each case, print a single integer, the maximum number of cells in a valid rectangle. 示例1 输入复制 1234567822 01 22 13 11 3 22 3 13 2 1 输出复制 1214 Solution code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std; inline bool scan_d(int&amp; num){ char in; bool IsN = false; in = getchar(); if (in == EOF) return false; while (in != '-' &amp;&amp; (in&lt;'0' || in&gt;'9')) in = getchar(); if (in == '-') { IsN = true; num = 0; } else num = in - '0'; while (in = getchar(), in &gt;= '0' &amp;&amp; in &lt;= '9') { num *= 10, num += in - '0'; } if (IsN) num = -num; return true;} const int maxn = 510;int arr[maxn][maxn], Max[maxn], Min[maxn];struct node { int inx, value; node(int k, int value) :inx(k), value(value) {} node() :inx(0), value(0) {};};node big[maxn], small[maxn];int bigl, bigr, smal, smar;int n, k, t, ans = 1;inline void InsertBig(int k, int value) { while (bigr &gt; bigl &amp;&amp; big[bigr].value &lt;= value)bigr--; big[++bigr] = node(k, value); /*while (!big.empty() &amp;&amp; big.back().value &lt;= value)big.pop_back(); big.emplace_back(node(k, value));*/}inline void InsertSmall(int k, int value) { while (smar &gt; smal &amp;&amp; small[smar].value &gt;= value)smar--; small[++smar] = node(k, value); /*while (!small.empty() &amp;&amp; small.back().value &gt;= value)small.pop_back(); small.emplace_back(node(k, value));*/}inline void update(int&amp; inx, int r) { while (inx &lt;= r) { /*if (!big.empty() &amp;&amp; big.front().inx &lt; inx)big.pop_front(); if (!small.empty() &amp;&amp; small.front().inx &lt; inx)small.pop_front(); if (!big.empty()&amp;&amp;!small.empty()&amp;&amp;big.front().value - small.front().value &lt;= k)break; */ if (bigr &gt; bigl &amp;&amp; big[bigl + 1].inx &lt; inx)bigl++; if (smar &gt; smal &amp;&amp; small[smal + 1].inx &lt; inx)smal++; if (smal &lt; smar &amp;&amp; bigl &lt; bigr &amp;&amp; big[bigl + 1].value - small[smal + 1].value &lt;= k)break; inx++; }}signed main() { scan_d(t); /*cin &gt;&gt; t;*/ while (t--) { ans = 1; /*cin &gt;&gt; n &gt;&gt; k;*/ scan_d(n),scan_d(k); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) scan_d(arr[i][j]); //cin &gt;&gt; arr[i][j]; for (int i = 1; i &lt;= n; ++i) { for (int k = 1; k &lt;= n; ++k)Min[k] = Max[k] = arr[i][k]; for (int j = i; j &lt;= n; ++j) { if (j != i)for (int k = 1; k &lt;= n; ++k) { Min[k] = min(Min[k], arr[j][k]); Max[k] = max(Max[k], arr[j][k]); } bigl = bigr = smal = smar = 0; /*big.clear(); small.clear();*/ int inx = 1; for (int k = 1; k &lt;= n; ++k) { InsertBig(k, Max[k]); InsertSmall(k, Min[k]); update(inx, k); ans = max(ans, (k - inx + 1) * (j - i + 1)); //cerr &lt;&lt; \"debug \" &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" \" &lt;&lt; k &lt;&lt; \" \" &lt;&lt; (k - inx+1) * (j - i + 1) &lt;&lt; endl; } } } cout &lt;&lt; ans &lt;&lt; endl; } return 0;} std：12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N=611;int i,j,k,n,m,tests,a[N][N],q1[N],q2[N],l1,r1,l2,r2,b1[N],b2[N],ans,w;int main(){// freopen(\"a.in\",\"r\",stdin); for (scanf(\"%d\",&amp;tests);tests--;){ scanf(\"%d%d\",&amp;n,&amp;m);ans=0; for (i=1;i&lt;=n;i++) for (j=1;j&lt;=n;j++) scanf(\"%d\",&amp;a[i][j]); for (i=1;i&lt;=n;i++){ for (j=1;j&lt;=n;j++) b1[j]=b2[j]=a[i][j]; for (j=i;j&lt;=n;j++){ for (k=1;k&lt;=n;k++) b1[k]=min(b1[k],a[j][k]),b2[k]=max(b2[k],a[j][k]); l1=l2=1;r1=r2=0; if ((j-i+1)*n&lt;ans) continue; for (k=w=1;k&lt;=n;k++){ while (l1&lt;=r1&amp;&amp;b1[q1[r1]]&gt;=b1[k]) r1--; q1[++r1]=k; while (l2&lt;=r2&amp;&amp;b2[q2[r2]]&lt;=b2[k]) r2--; q2[++r2]=k; while (w&lt;=k&amp;&amp;b2[q2[l2]]-b1[q1[l1]]&gt;m){ w++; while (l1&lt;=r1&amp;&amp;q1[l1]&lt;w) l1++; while (l2&lt;=r2&amp;&amp;q2[l2]&lt;w) l2++; } if ((j-i+1)*(n-w+1)&lt;ans) break; if (w&lt;=k) ans=max(ans,(j-i+1)*(k-w+1)); } } } printf(\"%d\\n\",ans); } return 0;}","link":"/2019/07/Planting-Trees/"},{"title":"Process Struct","text":"Process overview(xv6的描述)The unit of isolation in xv6 (as in other Unix operating systems) is a process. Theprocess abstraction prevents one process from wrecking or spying on another process’s memory, CPU, file descriptors, etc. It also prevents a process from wrecking the kernel itself, so that a process can’t subvert the kernel’s isolation mechanisms. The kernelmust implement the process abstraction with care because a buggy or malicious appli-cation may trick the kernel or hardware in doing something bad (e.g., circumventingenforced isolation). The mechanisms used by the kernel to implement processes in-clude the user/kernel mode flag, address spaces, and time-slicing of threads.To help enforce isolation, the process abstraction provides the illusion to a pro-gram that it has its own private machine. A process provides a program with what ap-pears to be a private memory system, or address space, which other processes cannotread or write. A process also provides the program with what appears to be its ownCPU to execute the program’s instructions.Xv6 uses page tables (which are implemented by hardware) to give each processits own address space. The x86 page table translates (or ‘‘maps’’) a virtual address (theaddress that an x86 instruction manipulates) to a physical address (an address that theprocessor chip sends to main memory).Xv6 maintains a separate page table for each process that defines that process’saddress space. As illustrated in Figure 1-2, an address space includes the process’s usermemory starting at virtual address zero. Instructions come first, followed by globalvariables, then the stack, and finally a ‘‘heap’’ area (for malloc) that the process can ex-pand as needed. Each process’s address space maps the kernel’s instructions and data as well as theuser program’s memory. When a process invokes a system call, the system call exe-cutes in the kernel mappings of the process’s address space. This arrangement existsso that the kernel’s system call code can directly refer to user memory. In order toleave plenty of room for user memory, xv6’s address spaces map the kernel at high ad-dresses, starting at 0x80100000.The xv6 kernel maintains many pieces of state for each process, which it gathersinto a struct proc (2337) . A process’s most important pieces of kernel state are itspage table, its kernel stack, and its run state. We’ll use the notation p-&gt;xxx to refer toelements of the proc structure.Each process has a thread of execution (or thread for short) that executes the pro-cess’s instructions. A thread can be suspended and later resumed. To switch transpar-ently between processes, the kernel suspends the currently running thread and resumesanother process’s thread. Much of the state of a thread (local variables, function callreturn addresses) is stored on the thread’s stacks. Each process has two stacks: a userstack and a kernel stack (p-&gt;kstack). When the process is executing user instructions,only its user stack is in use, and its kernel stack is empty. When the process enters thekernel (for a system call or interrupt), the kernel code executes on the process’s kernelstack; while a process is in the kernel, its user stack still contains saved data, but isn’tactively used. A process’s thread alternates between actively using its user stack and itskernel stack. The kernel stack is separate (and protected from user code) so that thekernel can execute even if a process has wrecked its user stack.When a process makes a system call, the processor switches to the kernel stack,raises the hardware privilege level, and starts executing the kernel instructions that im-plement the system call. When the system call completes, the kernel returns to userspace: the hardware lowers its privilege level, switches back to the user stack, and re-sumes executing user instructions just after the system call instruction. A process’sthread can ‘‘block’’ in the kernel to wait for I/O, and resume where it left off when theI/O has finished.p-&gt;state indicates whether the process is allocated, ready to run, running, wait-ing for I/O, or exiting.p-&gt;pgdir holds the process’s page table, in the format that the x86 hardware ex-pects. xv6 causes the paging hardware to use a process’s p-&gt;pgdir when executingthat process. A process’s page table also serves as the record of the addresses of thephysical pages allocated to store the process’s memory. xv6部分代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Per-CPU statestruct cpu { uchar apicid; // Local APIC ID struct context *scheduler; // swtch() here to enter scheduler struct taskstate ts; // Used by x86 to find stack for interrupt struct segdesc gdt[NSEGS]; // x86 global descriptor table volatile uint started; // Has the CPU started? int ncli; // Depth of pushcli nesting. int intena; // Were interrupts enabled before pushcli? struct proc *proc; // The process running on this cpu or null};extern struct cpu cpus[NCPU];extern int ncpu;//PAGEBREAK: 17// Saved registers for kernel context switches.// Don't need to save all the segment registers (%cs, etc),// because they are constant across kernel contexts.// Don't need to save %eax, %ecx, %edx, because the// x86 convention is that the caller has saved them.// Contexts are stored at the bottom of the stack they// describe; the stack pointer is the address of the context.// The layout of the context matches the layout of the stack in swtch.S// at the \"Switch stacks\" comment. Switch doesn't save eip explicitly,// but it is on the stack and allocproc() manipulates it.struct context { uint edi; uint esi; uint ebx; uint ebp; uint eip;};enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };// Per-process statestruct proc { uint sz; // Size of process memory (bytes) pde_t* pgdir; // Page table char *kstack; // Bottom of kernel stack for this process enum procstate state; // Process state int pid; // Process ID struct proc *parent; // Parent process struct trapframe *tf; // Trap frame for current syscall struct context *context; // swtch() here to run process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory char name[16]; // Process name (debugging)};// Process memory is laid out contiguously, low addresses first:// text// original data and bss// fixed-size stack// expandable heap","link":"/2019/07/Process-Struct/"},{"title":"Recovery","text":"H: Recovery题目描述Consider an n × m matrix of ones and zeros. For example, this 4 × 4:1 1 1 10 1 1 10 1 1 10 1 1 0 We can compute even parity for each row, and each column. In this case, the row parities are [0, 1, 1, 0] and the column parities are [1, 0, 0, 1] (the parity is 1 if there is an odd number of 1s in the row or column, 0 if the number of 1s is even). Note that the top row is row 1, the bottom row is row n, the leftmost column is column 1, and the rightmost column is column m.Suppose we lost the original matrix, and only have the row and column parities. Can we recover the original matrix? Unfortunately, we cannot uniquely recover the original matrix, but with some constraints, we can uniquely recover a matrix that ﬁts the bill. Firstly, the recovered matrix must contain as many 1’s as possible. Secondly, of all possible recovered matrices with the most 1’s, use the one which has the smallest binary value when you start with row 1, concatenate row 2 to the end of row 1, then append row 3, row 4, and so on. 输入Each input will consist of a single test case. Note that your program may be run multiple times on different inputs. Each test case will consist of exactly two lines. The ﬁrst line will contain a string R (1 ≤ |R| ≤ 50), consisting only of the characters 0 and 1. These are the row parities, in order.The second line will contain a string C (1 ≤ |C| ≤ 50), consisting only of the characters 0 and 1.These are the column parities, in order. 输出If it is possible to recover the original matrix with the given constraints, then output the matrix as |R| lines of exactly |C| characters, consisting only of 0’s and 1’s. If it is not possible to recover the original matrix, output −1. 样例输入1201101001 样例输出12341111011111101111题意：给你两个01字符串，第一行第i个 0代表第i行有偶数个1 1代表第i行有奇数个1。第二行 对应代表列的奇偶另外的两个条件 1.1的个数尽量多 2.若很多情况1的个数相同，从第一行到第n行，选二进制最小的那个（优先行数小的）解析：1.记录下答案是几列、几行的矩阵，并都初始化为1。2.记录哪一行不满足条件，初始化的矩阵1的个数的奇偶与给定的不同(说明这行需要加0使条件符合) cnt1个3.如第2步记录列的 （与2同） cnt2个4.若cnt1!=cnt2 那么就要优先往左上角补 （若cnt1&lt;cnt2 说明需要改的行不够 那就从第一行补，列为1的点）然后sort 贪心一下将矩阵该变的变为0 就可以输出了参考：http://www.cnblogs.com/tingtin/p/9487642.html代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ char s1[55]; char s2[55]; while(scanf(\"%s%s\",s1,s2)==2) { int n = strlen(s1); int m = strlen(s2); int x = n%2; int y = m%2; int a[105],b[105]; int cnt1 = 0,cnt2 = 0; for(int i=0; i&lt;n; i++) { int tmp = s1[i]-'0'; if(tmp!=y) a[cnt1++] = i; } for(int i=0; i&lt;m; i++) { int tmp = s2[i]-'0'; if(tmp!=x) b[cnt2++] = i; }// for(int i=0;i&lt;cnt1;i++)// {// cout&lt;&lt;a[i]&lt;&lt;\" \"&lt;&lt;b[i]&lt;&lt;endl;// } if((cnt1+cnt2)%2!=0) { printf(\"-1\\n\"); continue; } while(cnt1&lt;cnt2) a[cnt1++] = 0; while(cnt2&lt;cnt1) b[cnt2++] = 0; int Map[55][55]; for(int i=0; i&lt;n; i++) { for(int j=0; j&lt;m; j++) { Map[i][j] = 1; } } sort(a,a+cnt1); sort(b,b+cnt2); for(int i=0; i&lt;cnt1; i++) { Map[a[i]][b[i]] = 0; } for(int i=0; i&lt;n; i++) { for(int j=0; j&lt;m; j++) { cout&lt;&lt;Map[i][j]; } cout&lt;&lt;endl; } } return 0;}","link":"/2019/08/Recovery/"},{"title":"Shichikuji and Power Grid","text":"D. Shichikuji and Power Grid这题目很好很刺激 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * author: MySakure * created: 02.11.2019 22:21:52 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn=2010;int n,c[maxn],k[maxn],x[maxn],y[maxn],id;vector&lt;int&gt;a;vector&lt;pair&lt;int,int&gt;&gt;b;struct edge{ int u,v; long long c;}e[maxn*maxn];int fa[maxn];int cmp(const edge&amp;a,const edge&amp;b){ return a.c&lt;b.c;}int getf(int u){ return fa[u]==u?u:fa[u]=getf(fa[u]);}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i)cin&gt;&gt;x[i]&gt;&gt;y[i]; for(int i=1;i&lt;=n;++i)cin&gt;&gt;c[i]; for(int i=1;i&lt;=n;++i)cin&gt;&gt;k[i]; for(int i=1;i&lt;=n;++i) for(int j=i+1;j&lt;=n;++j){ e[++id]=edge{i,j,(abs(x[i]-x[j])+abs(y[i]-y[j]))*(k[i]+k[j])}; } for(int i=1;i&lt;=n;++i)e[++id]=edge{0,i,c[i]}; sort(e+1,e+id+1,cmp); for(int i=0;i&lt;=n;++i)fa[i]=i; long long ans=0; for(int i=1;i&lt;=id;++i){ int u=e[i].u,v=e[i].v; int uf=getf(u),vf=getf(v); if(uf==vf)continue; ans+=e[i].c; if(u==0||v==0)a.push_back(u?u:v); else b.push_back({u,v}); fa[uf]=vf; } cout&lt;&lt;ans&lt;&lt;'\\n'; cout&lt;&lt;a.size()&lt;&lt;'\\n'; for(auto x:a)cout&lt;&lt;x&lt;&lt;\" \"; cout&lt;&lt;'\\n'; cout&lt;&lt;b.size()&lt;&lt;'\\n'; for(auto x:b)cout&lt;&lt;x.first&lt;&lt;\" \"&lt;&lt;x.second&lt;&lt;'\\n'; return 0;}","link":"/2019/11/Shichikuji-and-Power-Grid/"},{"title":"Snowy Smile","text":"版权声明：本文为CSDN博主「ShadowGhostH」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/ShadowGhostH/article/details/81611432 对于一个固定区间，求最大子段和我们有O(n)O(n)的算法。但是如何维护不同区间的LISLIS就成了一个问题。我们选择线段树解决区间问题，但使用线段树的话，我们需要明白，维护什么值，以及如何进行区间操作。 那么我们思考，对于相邻的两个区间，他们的LISLIS有几种可能？ 左侧区间的LISLIS 右侧区间的LISLIS 两个区间合并后，中间新连接的部分前两点都好理解，针对第三点我们继续思考，中间部分能够成为LISLIS，其实就是我们从连接部分分别向前向后，获得一个尽可能大的前/后缀和。那么我们维护或者合并区间的LISLIS就需要维护三个值，区间最大子段和，最大前缀和，最大后缀和。而我们在合并区间的时候，如何维护前/后缀和呢？我们需要多维护一个区间和。 整理我们得到，定义区间ls,rsls,rs合并得到区间d，每个区间维护区间和sumsum，区间最大字段和maxsmaxs，区间最大前缀和maxlmaxl，区间最大后缀和maxrmaxr。则合并区间时，可得关系如下$$d.sum=ls.sum+rs.sumd.sum=ls.sum+rs.sum\\ d.maxs=max(ls.maxs,rs.maxs,ls.maxr+rs.maxl)\\ d.maxl=max(ls.maxl,ls.sum+rs.maxl)\\ d.maxr=max(rs.maxr,rs.sum+ls.maxr)\\$$ 用线段树维护即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct Node{ int l, r; int sum, maxs, maxl, maxr; //区间和, 区间最大子段和, 最大前缀和, 最大后缀和}tree[maxn&lt;&lt;2];int num[maxn]; //数值数组void build(int i, int l, int r){ tree[i].l = l; tree[i].r = r; if(l == r){ tree[i].sum = num[l]; tree[i].maxs = num[l]; tree[i].maxl = num[l]; tree[i].maxr = num[l]; return ; } int mid = (l+r)&gt;&gt;1; build(i&lt;&lt;1, l, mid); build(i&lt;&lt;1|1, mid+1, r); //子树建树后更新特征值 tree[i].sum = tree[i&lt;&lt;1].sum + tree[i&lt;&lt;1|1].sum; tree[i].maxs = max(max(tree[i&lt;&lt;1].maxs, tree[i&lt;&lt;1|1].maxs), tree[i&lt;&lt;1].maxr+tree[i&lt;&lt;1|1].maxl); tree[i].maxl = max(tree[i&lt;&lt;1].maxl, tree[i&lt;&lt;1].sum+tree[i&lt;&lt;1|1].maxl); tree[i].maxr = max(tree[i&lt;&lt;1|1].maxr, tree[i&lt;&lt;1|1].sum+tree[i&lt;&lt;1].maxr); return ;}Node query(int i, int l, int r){ if(tree[i].l==l &amp;&amp; tree[i].r==r) return tree[i]; int mid = (tree[i].l+tree[i].r)&gt;&gt;1; if(mid &gt;= r) return query(i&lt;&lt;1, l, r); else if(mid &lt; l) return query(i&lt;&lt;1|1, l, r); else { Node ls = query(i, l, mid); Node rs = query(i, mid+1, r); Node ans; ans.maxs = max(max(ls.maxs, rs.maxs), ls.maxr+rs.maxl); ans.maxl = max(ls.maxl, ls.sum+rs.maxl); ans.maxr = max(rs.maxr, rs.sum+ls.maxr); ans.sum = ls.sum + rs.sum; return ans; }}int main(){ int n, m; sd(n); rep(i, 1, n+1) sd(num[i]); build(1, 1, n); sd(m); rep(i, 0, m) { int l, r; sdd(l, r); Node ans = query(1, l, r); printf(\"%d\\n\", ans.maxs); } return 0;} 题目：Snowy SmileTime Limit: 4000/4000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others)Total Submission(s): 367 Accepted Submission(s): 127 Problem Description There are n pirate chests buried in Byteland, labeled by 1,2,…,n. The i-th chest’s location is (xi,yi), and its value is wi, wi can be negative since the pirate can add some poisonous gases into the chest. When you open the i-th pirate chest, you will get wi value. You want to make money from these pirate chests. You can select a rectangle, the sides of which are all paralleled to the axes, and then all the chests inside it or on its border will be opened. Note that you must open all the chests within that range regardless of their values are positive or negative. But you can choose a rectangle with nothing in it to get a zero sum. Please write a program to find the best rectangle with maximum total value. Input The first line of the input contains an integer T(1≤T≤100), denoting the number of test cases. In each test case, there is one integer n(1≤n≤2000) in the first line, denoting the number of pirate chests. For the next n lines, each line contains three integers xi,yi,wi(−109≤xi,yi,wi≤109), denoting each pirate chest. It is guaranteed that ∑n≤10000. Output For each test case, print a single line containing an integer, denoting the maximum total value. Sample Input 123456789241 1 502 1 501 2 502 2 -5002-1 1 5-1 1 1 Sample Output 121006 Source 2019 Multi-University Training Contest 6 Code(群里某大佬所写）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define ll long long#define pi pair&lt;int, ll&gt;#define mk make_pairusing namespace std;const int maxn = 2010;struct node { int x, y; ll w; bool operator&lt;(const node&amp; t) const { if (y == t.y) return x &lt; t.x; return y &gt; t.y; }}p[maxn];int X[maxn], Y[maxn];ll mx[maxn * 4], L[maxn * 4], R[maxn * 4], sum[maxn * 4];vector&lt;pi&gt; G[maxn];#define ls o * 2#define rs o * 2 + 1#define mid (l + r) / 2void up(int o, int l, int r, int k, ll w) { if (l == r) { mx[o] += w; L[o] += w; R[o] += w; sum[o] += w; return; } if (k &lt;= mid) up(ls, l, mid, k, w); else up(rs, mid + 1, r, k, w); sum[o] = sum[ls] + sum[rs]; L[o] = max(L[ls], sum[ls] + L[rs]); R[o] = max(R[rs], sum[rs] + R[ls]); mx[o] = max(L[o], R[o]); ll tmp = max(mx[ls], mx[rs]); ll tmp2 = max(tmp, R[ls] + L[rs]); mx[o] = max(mx[o], tmp2);}int main() { int T; scanf(\"%d\", &amp;T); while (T--) { int n, m = 0; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%d%d%lld\", &amp;p[i].x, &amp;p[i].y, &amp;p[i].w); X[i] = p[i].x; Y[i] = p[i].y; } sort(X + 1, X + 1 + n); sort(Y + 1, Y + 1 + n); int sz1 = unique(X + 1, X + 1 + n) - X - 1; int sz2 = unique(Y + 1, Y + 1 + n) - Y - 1; for (int i = 1; i &lt;= n; i++) { p[i].x = lower_bound(X + 1, X + 1 + sz1, p[i].x) - X; p[i].y = lower_bound(Y + 1, Y + 1 + sz2, p[i].y) - Y; G[p[i].y].push_back(mk(p[i].x, p[i].w)); } ll ans = 0; for (int i = 1; i &lt;= sz2; i++) { //枚举下边界 for (int j = 1; j &lt;= sz1 * 4; j++) mx[j] = L[j] = R[j] = sum[j] = 0; for (int j = i; j; j--) { //枚举上边界 for (auto tmp : G[j]) up(1, 1, sz1, tmp.first, tmp.second); ans = max(ans, mx[1]); } } printf(\"%lld\\n\", ans); for (int i = 1; i &lt;= sz2; i++) G[i].clear(); }}","link":"/2019/08/Snowy-Smile/"},{"title":"Spreading the Wealth","text":"This browser does not support PDFs. Please download the PDF to view it: Download PDF. Code: 123456789101112131415161718192021222324252627282930//训练指南有详细题解，P5#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=1e6+10;int a[maxn],n,c[maxn];signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); while(cin&gt;&gt;n){ ll tot=0; rep(i,1,n){ cin&gt;&gt;a[i]; tot+=a[i]; } int M=tot/n; rep(i,1,n)c[i]=c[i-1]+M-a[i]; sort(c+1,c+1+n); ll x1=c[n/2],ans=0; rep(i,1,n){ ans+=abs(x1-c[i]); } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2019/08/Spreading-the-Wealth/"},{"title":"Stone game","text":"Stone game先将石头按照从大到小的顺序排序，然后枚举CSL选的石头的最小值。假设枚举到第$i$个石头作为CSL选择的最小石头，那么第$i+1~n$必然是未选的，然后我们可以求出CSL除了最小石头外的剩余背包容量范围。$dp[i][j]$表示以前$i$个石头背包，总容量为$j$的方案数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * author: MySakure * created: 15.09.2019 13:34:09 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int mod=1e9+7;const int maxn=310;#define int long longint dp[2][150010],n,a[maxn],s,Max;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); int t; cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; s=0; rep(i,1,n){ cin&gt;&gt;a[i]; s+=a[i]; } sort(a+1,a+1+n); reverse(a+1,a+1+n); Max=s; rep(i,0,Max)dp[0][i]=0; dp[0][0]=1; bool flag=1; int Ans=0; for(int i=1;i&lt;=n;++i,flag^=1){ for(int j=0;j&lt;=Max;++j) dp[flag][j]=dp[!flag][j]%mod; for(int j=a[i];j&lt;=Max;++j){ dp[flag][j]+=dp[!flag][j-a[i]]; dp[flag][j]%=mod; } //for(int j=0;j&lt;=Max;++j) //cerr&lt;&lt;\"debug \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;dp[flag][j]&lt;&lt;endl; //cerr&lt;&lt;\"Max \"&lt;&lt;max(0ll,(Max-2*a[i]+1)/2)&lt;&lt;\" \"&lt;&lt;(Max-a[i])/2&lt;&lt;endl; for(int j=max(0ll,(Max-2*a[i]+1)/2);j&lt;=(Max-a[i])/2;++j){ Ans+=dp[!flag][j]; Ans%=mod; } } cout&lt;&lt;Ans&lt;&lt;endl; } return 0;}","link":"/2019/09/Stone%20game/"},{"title":"String","text":"链接：https://ac.nowcoder.com/acm/contest/887/A来源：牛客网 题目描述A string is perfect if it has the smallest lexicographical ordering among its cyclic rotations. For example: “0101” is perfect as it is the smallest string among (“0101”, “1010”, “0101”, “1010”). Given a 01 string, you need to split it into the least parts and all parts are perfect. 输入描述:1The first line of the input gives the number of test cases, T (T≤300)T\\ (T \\leq 300)T (T≤300). test cases follow.For each test case, the only line contains one non-empty 01 string. The length of string is not exceed 200. 输出描述:1For each test case, output one string separated by a space. 示例1 输入复制 123454000010010111011110 输出复制 123400001001 0111 01111 0 STD:12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std; bool isOk(string s) { int n = s.length(); for (int i = 1; i &lt; n; i++) for (int j = 0; j &lt; n; j++) { if (s[j] &lt; s[(i+j)%n]) break; if (s[j] &gt; s[(i+j)%n]) return false; } return true;}int main() { int T; string s; scanf(\"%d\", &amp;T); assert(T &lt;= 300); while (T--) { cin&gt;&gt;s; int n = s.length(); assert(n &gt; 0 &amp;&amp; n &lt;= 200); int i = 0; while (i &lt; n) { for (int j = n-i; j &gt; 0; j--) { if (isOk(s.substr(i, j))) { cout&lt;&lt;s.substr(i, j); i += j; if (i &lt; n)printf(\" \"); break; } } } cout&lt;&lt;endl; } return 0; }","link":"/2019/08/String-0/"},{"title":"Subarray","text":"Subarray 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; #define ERR(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator&lt;string&gt; _it(_ss); err(_it, args); } void err(istream_iterator&lt;string&gt; it) { cerr &lt;&lt; \"\\n\";}template&lt;typename T, typename... Args&gt;void err(istream_iterator&lt;string&gt; it, T a, Args... args) { cerr &lt;&lt; *it &lt;&lt; \"=\" &lt;&lt; a &lt;&lt; \", \"; err(++it, args...);} #define ERR1(arg,n) { cerr&lt;&lt;\"\"&lt;&lt;#arg&lt;&lt;\"=\\n \"; for(int i=1;i&lt;=n;i++) cerr&lt;&lt;arg[i]&lt;&lt;\" \"; cerr&lt;&lt;\"\\n\"; }#define ERR2(arg,n,m) { cerr&lt;&lt;\"\"&lt;&lt;#arg&lt;&lt;\"=\\n\"; for(int i=1;i&lt;=n;i++) { cerr&lt;&lt;\" \"; for(int j=1;j&lt;=m;j++)cerr&lt;&lt;arg[i][j]&lt;&lt;\" \"; cerr&lt;&lt;\"\\n\"; } } const int INF = 0x3f3f3f3f;const int MAXN = 10000000, MAXM = 1000000; int l[MAXM + 5], r[MAXM + 5], f[MAXM + 5], g[MAXM + 5];int sum[MAXN * 3 + 5], b[MAXN * 3 + 5], c[MAXN * 3 + 5]; int main() {#ifdef Yinku freopen(\"Yinku.in\", \"r\", stdin);#endif // Yinku int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d%d\", &amp;l[i], &amp;r[i]); f[1] = r[1] - l[1] + 1; //f[i]以i段右端点为结尾的能构造出的最大的前缀和 for (int i = 2; i &lt;= n; i++) f[i] = max(0, f[i - 1] - (l[i] - r[i - 1] - 1)) + r[i] - l[i] + 1; //0：以i-1段右端点结尾的能构造出的最大的前缀和都不足够跨过[i-1,i]之间的-1 //f[i - 1] - (l[i] - r[i - 1] - 1)：跨过之后还剩下多少贡献给这段 g[n] = r[n] - l[n] + 1; //g[i]以i段左端点为开头的能构造出的最大的前缀和 for (int i = n - 1; i &gt;= 1; i--) g[i] = max(0, g[i + 1] - (l[i + 1] - r[i] - 1)) + r[i] - l[i] + 1; //ERR1(f, n); //ERR1(g, n); int i = 1, base = 10000000; ll ans = 0; while (i &lt;= n) { int j = i + 1; while (j &lt;= n &amp;&amp; g[j] + f[j - 1] &gt;= l[j] - r[j - 1] - 1) { //说明这个[j-1,j]之间的-1段可以因为两侧的f[j-1]和g[j]足够大而连接起来 j++; } j--; //此时j是从i开始最远能够连接到的区间 int left = max(0, l[i] - g[i]), right = min(1000000000 - 1, r[j] + f[j]); //left,right是至少会产生一个贡献的范围 //ERR(left, right); int t = i, mi = INF, mx = 0; sum[0] = 0; for (int k = left; k &lt;= right; k++) { //统计这一整段可连接区间的前缀和 if (k &gt;= l[t] &amp;&amp; k &lt;= r[t]) sum[k - left + 1] = sum[k - left] + 1; else sum[k - left + 1] = sum[k - left] - 1; if (k == r[t]) t++; mi = min(mi, sum[k - left + 1] + base); mx = max(mx, sum[k - left + 1] + base); //以left-1为开头，每次sum&gt;0会产生一次贡献 ans += sum[k - left + 1] &gt; 0; //b记录前缀和出现过的次数 b[sum[k - left + 1] + base] ++; } //ERR1(sum, right); //b记录前缀和出现过的次数的后缀和 for (int k = mx - 1; k &gt;= mi; k--) b[k] += b[k + 1]; for (int k = left; k &lt;= right; k++) { t = sum[k - left + 1] + base; //t表示k位置sum的值 //b[t+1]比t大的值的个数 //c[t+1]比在k位置左侧的比t大的值的个数的lazy b[t + 1] -= c[t + 1]; //把lazy加上去 c[t] += c[t + 1] + 1; //lazy标记下移 c[t + 1] = 0; //清空lazy ans += b[t + 1]; } for (int k = mi; k &lt;= mx; k++) b[k] = 0, c[k] = 0; i = j + 1; } printf(\"%lld\", ans); return 0;}","link":"/2019/07/Subarray/"},{"title":"TDL","text":"TDLTime Limit: 2000/1000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others)Total Submission(s): 211 Accepted Submission(s): 93 Problem Description For a positive integer n, let’s denote function f(n,m) as the m-th smallest integer x that x&gt;n and gcd(x,n)=1. For example, f(5,1)=6 and f(5,5)=11. You are given the value of m and (f(n,m)−n)⊕n, where ``⊕’’ denotes the bitwise XOR operation. Please write a program to find the smallest positive integer nthat (f(n,m)−n)⊕n=k, or determine it is impossible. Input The first line of the input contains an integer T(1≤T≤10), denoting the number of test cases. In each test case, there are two integers k,m(1≤k≤1018,1≤m≤100). Output For each test case, print a single line containing an integer, denoting the smallest n. If there is no solution, output ``-1’’ instead. Sample Input 12323 56 100 Sample Output 125-1 Source 2019 Multi-University Training Contest 6 code：123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define sz size#define ll long longll t,n,m,k;ll get(ll cur){ int ans=0; rep(i,1,2000){ if(__gcd(cur,i*1ll)==1)ans++; if(ans==m)return i; } return -1;}signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;t; while(t--){ n=2e18; cin&gt;&gt;k&gt;&gt;m; rep(i,1,2000) { ll cur=i^k; if(get(cur)==i)n=min(n,cur); } if(n==2e18){ cout&lt;&lt;-1&lt;&lt;endl; } else cout&lt;&lt;n&lt;&lt;endl; } return 0;}","link":"/2019/08/TDL/"},{"title":"The Bus Driver Problem","text":"The Bus Driver Problem感觉整个人都很傻逼，想复杂了。没想到是个简单的贪心，emmmm code：12345678910111213141516171819202122232425262728293031/** * author: MySakure * created: 26.09.2019 18:31:13 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=110;int a[maxn],b[maxn],n,ans,d,r;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); while(cin&gt;&gt;n&gt;&gt;d&gt;&gt;r&amp;&amp;n){ rep(i,1,n)cin&gt;&gt;a[i]; rep(i,1,n)cin&gt;&gt;b[i]; sort(a+1,a+1+n); sort(b+1,b+1+n); reverse(b+1,b+1+n); ans=0; rep(i,1,n){ ans+=max(0,a[i]+b[i]-d)*r; } cout&lt;&lt;ans&lt;&lt;'\\n'; } return 0;}","link":"/2019/09/The%20Bus%20Driver%20Problem/"},{"title":"The Number Of Good Substrings","text":"C. The Number Of Good Substrings You are given a binary string ss (recall that a string is binary if each character is either 00 or 11). Let f(t)f(t) be the decimal representation of integer tt written in binary form (possibly with leading zeroes). For example $f(011)=3,f(00101)=5,f(00001)=1,f(10)=2,f(000)=0f(011)=3,f(00101)=5,f(00001)=1,f(10)=2,f(000)=0 and f(000100)=4f(000100)=4.$ The substring $sl,sl+1,…,srsl,sl+1,…,sr$ is good if $r−l+1=f(sl…sr)r−l+1=f(sl…sr)$. For example string s=1011s=1011 has 55 good substrings:$ s1…s1=1s1…s1=1, s3…s3=1s3…s3=1, s4…s4=1s4…s4=1, s1…s2=10s1…s2=10 and s2…s4=011s2…s4=011$. Your task is to calculate the number of good substrings of string ss. You have to answer tt independent queries. Input The first line contains one integer tt (1≤t≤10001≤t≤1000) — the number of queries. The only line of each query contains string ss (1≤|s|≤2⋅1051≤|s|≤2⋅105), consisting of only digits 00 and 11. It is guaranteed that ∑i=1t|si|≤2⋅105∑i=1t|si|≤2⋅105. Output For each query print one integer — the number of good substrings of string ss. Example input Copy 12345401100101000010000001000 output Copy 12344343 思路要点：当第一位为1时，总长度超过20位的话，值已超过2e5 Code: 复杂度：$O(n)$ 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=2e5+10;int t,a[maxn],dp[maxn];string str;signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); //freopen(\"../in.txt\", \"r\", stdin); //freopen(\"../out.txt\", \"w\", stdout); cin&gt;&gt;t; while(t--){ cin&gt;&gt;str; int n=int(str.size()); for(int i=1;i&lt;=n;++i)a[i]=str[i-1]-'0'; a[0]=-1; for(int i=1;i&lt;=n;++i)dp[i]=a[i-1]==0?dp[i-1]+1:0; int ans=0; for(int i=1;i&lt;=n;++i){ if(!a[i])continue; int cur=0; for(int j=1;j&lt;=20&amp;&amp;i+j-1&lt;=n;++j){ cur=cur*2+a[i+j-1]; ans+=(j+dp[i]&gt;=cur); } } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2019/09/The%20Number%20Of%20Good%20Substrings/"},{"title":"Tian Ji -- The Horse Racing","text":"Tian Ji – The Horse Racing来源于某大佬的题解：题意: 田忌要和国王赛马,双方各有n只马,赢一场得200,输一场,失200,平局不给钱;问怎么安排田忌赚最多; 思路: 首先第一步肯定是把双方的马都排序,然后先把最慢的马比一下,如果这马比国王快,直接赢下来,如果比国王慢那就用这匹马输给国王最快的马(反正都要输,尽量消耗他); 但是如果一样快,就要比较最快的那匹马,如果最快的那匹马比较快,也是直接赢下来,然后比较接下去最快的,如果最快的马小于或等于国王的,那就用慢的那匹去输(因为如果直接快对快,慢对慢,那么就是一平一负,用慢对快,就是那一负,但是快的那匹肯定会多赢一场下来,收获是一样的,但是这样做我们留下的一匹快的,对方留下一只慢的,后面可以做更好的安排)(如果快马也等于快马也是一样,把两平,换成一胜一负)————————————————版权声明：本文为CSDN博主「二分查找」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/yeyeyeguoguo/article/details/43855417 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * author: MySakure * created: 25.09.2019 19:56:19 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int maxn=1010;int a[maxn],b[maxn],cnta,cntb,cntc,cntd;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); int n; while(cin&gt;&gt;n&amp;&amp;n){ rep(i,1,n)cin&gt;&gt;a[i]; rep(i,1,n)cin&gt;&gt;b[i]; sort(a+1,a+1+n); sort(b+1,b+1+n); cnta=cntc=1,cntb=cntd=n; int ans=0; while(n--){ if(a[cnta]&gt;b[cntc]){ ans+=200; cnta++,cntc++; } else if(a[cnta]&lt;b[cntc]){ ans-=200; cnta++; cntd--; } else{ if(a[cntb]&gt;b[cntd]){ ans+=200; cntb--,cntd--; } else{ ans-=(a[cnta]!=b[cntd])*200; cnta++; cntd--; } } } cout&lt;&lt;ans&lt;&lt;endl; } return 0;}/*题意:田忌要和国王赛马,双方各有n只马,赢一场得200,输一场,失200,平局不给钱;问怎么安排田忌赚最多;思路:首先第一步肯定是把双方的马都排序,然后先把最慢的马比一下,如果这马比国王快,直接赢下来,如果比国王慢那就用这匹马输给国王最快的马(反正都要输,尽量消耗他);但是如果一样快,就要比较最快的那匹马,如果最快的那匹马比较快,也是直接赢下来,然后比较接下去最快的,如果最快的马小于或等于国王的,那就用慢的那匹去输(因为如果直接快对快,慢对慢,那么就是一平一负,用慢对快,就是那一负,但是快的那匹肯定会多赢一场下来,收获是一样的,但是这样做我们留下的一匹快的,对方留下一只慢的,后面可以做更好的安排)(如果快马也等于快马也是一样,把两平,换成一胜一负)————————————————版权声明：本文为CSDN博主「二分查找」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/yeyeyeguoguo/article/details/43855417*/","link":"/2019/09/Tian%20Ji%20--%20The%20Horse%20Racing/"},{"title":"Travel","text":"Travel 这道题告诉我，最短路不要想当然的瞎去松弛，会把复杂度搞大，要使用科学的最短路松弛方法。不然就一直T 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * author: MySakure * created: 26.09.2019 18:54:16 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll unsigned long long const ll maxn=1e5,inf=1e18;int a[maxn],n,m,q,x,y;ll d[maxn],ans,vis[maxn],v[maxn];struct edge{ int to; ll w;};vector&lt;edge&gt;g[maxn];inline ll getdis(int x,int y){ if(x&gt;y)swap(x,y); return min(d[y-1]-d[x-1],d[n]-(d[y-1]-d[x-1]));}int ue[30],ve[30];ll we[30];inline void solve(){ for(int i=1;i&lt;=m;++i){ vis[ue[i]]=getdis(ue[i],x); vis[ve[i]]=getdis(ve[i],x); } vis[y]=getdis(x,y); vis[0]=inf; for(int i=1;i&lt;=2*m;++i){ int start=0; for(int i=1;i&lt;=m;++i){ if(vis[start]&gt;vis[ue[i]]&amp;&amp;!v[ue[i]])start=ue[i]; if(vis[start]&gt;vis[ve[i]]&amp;&amp;!v[ve[i]])start=ve[i]; } v[start]=1; //cerr&lt;&lt;\"debug \"&lt;&lt;start&lt;&lt;endl; for(int i=1;i&lt;=m;++i){ vis[ue[i]]=min(vis[ue[i]],vis[start]+getdis(ue[i],start)); vis[ve[i]]=min(vis[ve[i]],vis[start]+getdis(ve[i],start)); } for(int i=0;i&lt;int(g[start].size());++i){ int to=g[start][i].to,w=g[start][i].w; vis[to]=min(vis[to],vis[start]+w); } } for(int i=1;i&lt;=m;++i){ ans=min(ans,getdis(y,ue[i])+vis[ue[i]]); ans=min(ans,getdis(y,ve[i])+vis[ve[i]]); }}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n&gt;&gt;m; rep(i,1,n){ cin&gt;&gt;d[i]; d[i]+=d[i-1]; } rep(i,1,m){ cin&gt;&gt;ue[i]&gt;&gt;ve[i]&gt;&gt;we[i]; g[ue[i]].push_back(edge{ve[i],we[i]}); g[ve[i]].push_back(edge{ue[i],we[i]}); } cin&gt;&gt;q; while(q--){ cin&gt;&gt;x&gt;&gt;y; if(x&gt;y)swap(x,y); rep(i,1,m){ vis[ue[i]]=inf,vis[ve[i]]=inf; v[ue[i]]=0;v[ve[i]]=0; } vis[x]=0; ans=getdis(x,y); solve(); cout&lt;&lt;ans&lt;&lt;'\\n'; } return 0;}","link":"/2019/09/Travel/"},{"title":"Treasure Island","text":"链接：https://codeforces.com/contest/1214/problem/D 参考题解：https://blog.csdn.net/liufengwei1/article/details/100546882 https://blog.csdn.net/weixin_44231553/article/details/100547027 code: 哈希(抄的dls的大质数，我的双哈希都被卡掉了) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define int long long#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;const int mod=1e9+7;typedef long long ll;typedef pair&lt;int,int&gt; PII;mt19937 mrand(chrono::high_resolution_clock::now().time_since_epoch().count());//const ll mod=1000000007;int rnd(int x) { return mrand() % x;}ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1){if(b&amp;1)res=res*a%mod;a=a*a%mod;}return res;}ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}// head const int N=1010000;int n,m;ll dp[N],pd[N],pp;char s[N];bool p[N];typedef pair&lt;ll,ll&gt; PLL;namespace Factor { const int N=1010000; ll C,fac[10010],n,mut,a[1001000]; int T,cnt,i,l,prime[N],p[N],psize,_cnt; ll _e[100],_pr[100]; vector&lt;ll&gt; d; inline ll mul(ll a,ll b,ll p) { if (p&lt;=1000000000) return a*b%p; else if (p&lt;=1000000000000ll) return (((a*(b&gt;&gt;20)%p)&lt;&lt;20)+(a*(b&amp;((1&lt;&lt;20)-1))))%p; else { ll d=(ll)floor(a*(long double)b/p+0.5); ll ret=(a*b-d*p)%p; if (ret&lt;0) ret+=p; return ret; } } void prime_table(){ int i,j,tot,t1; for (i=1;i&lt;=psize;i++) p[i]=i; for (i=2,tot=0;i&lt;=psize;i++){ if (p[i]==i) prime[++tot]=i; for (j=1;j&lt;=tot &amp;&amp; (t1=prime[j]*i)&lt;=psize;j++){ p[t1]=prime[j]; if (i%prime[j]==0) break; } } } void init(int ps) { psize=ps; prime_table(); } ll powl(ll a,ll n,ll p) { ll ans=1; for (;n;n&gt;&gt;=1) { if (n&amp;1) ans=mul(ans,a,p); a=mul(a,a,p); } return ans; } bool witness(ll a,ll n) { int t=0; ll u=n-1; for (;~u&amp;1;u&gt;&gt;=1) t++; ll x=powl(a,u,n),_x=0; for (;t;t--) { _x=mul(x,x,n); if (_x==1 &amp;&amp; x!=1 &amp;&amp; x!=n-1) return 1; x=_x; } return _x!=1; } bool miller(ll n) { if (n&lt;2) return 0; if (n&lt;=psize) return p[n]==n; if (~n&amp;1) return 0; for (int j=0;j&lt;=7;j++) if (witness(rand()%(n-1)+1,n)) return 0; return 1; } ll gcd(ll a,ll b) { ll ret=1; while (a!=0) { if ((~a&amp;1) &amp;&amp; (~b&amp;1)) ret&lt;&lt;=1,a&gt;&gt;=1,b&gt;&gt;=1; else if (~a&amp;1) a&gt;&gt;=1; else if (~b&amp;1) b&gt;&gt;=1; else { if (a&lt;b) swap(a,b); a-=b; } } return ret*b; } ll rho(ll n) { for (;;) { ll X=rand()%n,Y,Z,T=1,*lY=a,*lX=lY; int tmp=20; C=rand()%10+3; X=mul(X,X,n)+C;*(lY++)=X;lX++; Y=mul(X,X,n)+C;*(lY++)=Y; for(;X!=Y;) { ll t=X-Y+n; Z=mul(T,t,n); if(Z==0) return gcd(T,n); tmp--; if (tmp==0) { tmp=20; Z=gcd(Z,n); if (Z!=1 &amp;&amp; Z!=n) return Z; } T=Z; Y=*(lY++)=mul(Y,Y,n)+C; Y=*(lY++)=mul(Y,Y,n)+C; X=*(lX++); } } } void _factor(ll n) { for (int i=0;i&lt;cnt;i++) { if (n%fac[i]==0) n/=fac[i],fac[cnt++]=fac[i];} if (n&lt;=psize) { for (;n!=1;n/=p[n]) fac[cnt++]=p[n]; return; } if (miller(n)) fac[cnt++]=n; else { ll x=rho(n); _factor(x);_factor(n/x); } } void dfs(ll x,int dep) { if (dep==_cnt) d.pb(x); else { dfs(x,dep+1); for (int i=1;i&lt;=_e[dep];i++) dfs(x*=_pr[dep],dep+1); } } void norm() { sort(fac,fac+cnt); _cnt=0; rep(i,0,cnt) if (i==0||fac[i]!=fac[i-1]) _pr[_cnt]=fac[i],_e[_cnt++]=1; else _e[_cnt-1]++; } vector&lt;ll&gt; getd() { d.clear(); dfs(1,0); return d; } vector&lt;ll&gt; factor(ll n) { cnt=0; _factor(n); norm(); return getd(); } vector&lt;PLL&gt; factorG(ll n) { cnt=0; _factor(n); norm(); vector&lt;PLL&gt; d; rep(i,0,_cnt) d.pb(mp(_pr[i],_e[i])); return d; } bool is_primitive(ll a,ll p) { assert(miller(p)); vector&lt;PLL&gt; D=factorG(p-1); rep(i,0,SZ(D)) if (powl(a,(p-1)/D[i].fi,p)==1) return 0; return 1; }}#define pb push_back#define mk make_pair#define ll long long#define vvc vector&lt;vector &lt;char&gt; &gt;#define vvb vector&lt;vector &lt;bool&gt; &gt; const int maxn=1e6+10;int ans=2; int isok(int x,int y){ return x&gt;0&amp;&amp;x&lt;=n&amp;&amp;y&gt;0&amp;&amp;y&lt;=m;}signed main(){ ios::sync_with_stdio(NULL); cin.tie(0); cin&gt;&gt;n&gt;&gt;m; Factor::init(100000); while (1) { pp=1000000000+rnd(1000000000); if (Factor::miller(pp)) break; } vector&lt;vector &lt;char&gt; &gt; v(n+10 ,vector&lt;char&gt;(m+10)); //m*n的二维vector for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) cin&gt;&gt;v[i][j]; vector&lt;vector &lt;int&gt; &gt; dpa(n+10 ,vector&lt;int&gt;(m+10)); vector&lt;vector &lt;int&gt; &gt; dpb(n+10 ,vector&lt;int&gt;(m+10)); //vector&lt;vector &lt;bool&gt; &gt; vis(n+10,vector&lt;bool&gt;(m+10)); dpa[1][0]=dpb[n][m+1]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j){ if(v[i][j]=='#')continue; else dpa[i][j]=(dpa[i-1][j]+dpa[i][j-1])%pp; } for(int i=n;i&gt;=1;--i) for(int j=m;j&gt;=1;--j) if(v[i][j]=='#')continue; else dpb[i][j]=(dpb[i+1][j]+dpb[i][j+1])%pp; if(!dpa[n][m]){ cout&lt;&lt;0&lt;&lt;endl; return 0; } for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=m;++j){ if(i==1&amp;&amp;j==1)continue; if(i==n&amp;&amp;j==m)continue; if(dpa[i][j]*1ll*dpb[i][j]%pp==dpa[n][m]){ cout&lt;&lt;1&lt;&lt;endl; return 0; } } } cout&lt;&lt;2&lt;&lt;endl; return 0;} DFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long#define vvc vector&lt;vector &lt;char&gt; &gt;#define vvb vector&lt;vector &lt;bool&gt; &gt;int n,m;int isok(int x,int y){ return x&lt;=n&amp;&amp;y&lt;=m;}int dfs(int x,int y,vvb&amp;vis,vvb&amp;a,vvc&amp;v){ if(!isok(x,y)||v[x][y]=='#'||vis[x][y])return false; vis[x][y]=1; if(x==n&amp;&amp;y==m)return true; if(dfs(x+1,y,vis,a,v)||dfs(x,y+1,vis,a,v)){ a[x][y]=true; return true; } return false;}int dfs2(int x,int y,vvc&amp; v,vvb&amp;a,vvb&amp;vis){ if(!isok(x,y)||v[x][y]=='#'||vis[x][y]||a[x][y])return false; vis[x][y]=true; if(x==n&amp;&amp;y==m)return true; return dfs2(x+1,y,v,a,vis)||dfs2(x,y+1,v,a,vis);}signed main(){ ios::sync_with_stdio(NULL); cin.tie(0); cin&gt;&gt;n&gt;&gt;m; vector&lt;vector &lt;char&gt; &gt; v(n+10 ,vector&lt;char&gt;(m+10)); //m*n的二维vector for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) cin&gt;&gt;v[i][j]; vector&lt;vector &lt;bool&gt; &gt; a(n+10 ,vector&lt;bool&gt;(m+10)); vector&lt;vector &lt;bool&gt; &gt; vis(n+10,vector&lt;bool&gt;(m+10)); if(!dfs(1,1,vis,a,v)){ cout&lt;&lt;0&lt;&lt;endl; return 0; } a[1][1]=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) vis[i][j]=0; if(dfs2(1,1,v,a,vis)){ cout&lt;&lt;2&lt;&lt;endl; return 0; } cout&lt;&lt;1&lt;&lt;endl; return 0;}","link":"/2019/09/Treasure-Island/"},{"title":"Typical-Stairs","text":"C - Typical Stairs ProblemTime Limit: 2 sec / Memory Limit: 1024 MB Score : 300300 points Problem StatementThere is a staircase with NN steps. Takahashi is now standing at the foot of the stairs, that is, on the 00-th step. He can climb up one or two steps at a time. However, the treads of the a1a1-th, a2a2-th, a3a3-th, ……, aMaM-th steps are broken, so it is dangerous to set foot on those steps. How many are there to climb up to the top step, that is, the NN-th step, without setting foot on the broken steps? Find the count modulo 1 000 000 007. Constraints 1≤N≤1051≤N≤105 0≤M≤N−10≤M≤N−1 1≤a1&lt;a2&lt;1≤a1&lt;a2&lt; …… &lt;aM≤N−1&lt;aM≤N−1 InputInput is given from Standard Input in the following format: 1234567NN MMa1a1a2a2......aMaM OutputPrint the number of ways to climb up the stairs under the condition, modulo 1 000 000 0071 000 000 007. Sample Input 1 CopyCopy 126 13 Sample Output 1 CopyCopy 14 There are four ways to climb up the stairs, as follows: 0→1→2→4→5→60→1→2→4→5→6 0→1→2→4→60→1→2→4→6 0→2→4→5→60→2→4→5→6 0→2→4→60→2→4→6 Sample Input 2 CopyCopy 12310 245 Sample Output 2 CopyCopy 10 There may be no way to climb up the stairs without setting foot on the broken steps. Sample Input 3 CopyCopy 123456100 5123456789 Sample Output 3 CopyCopy 1608200469 Be sure to print the count modulo 1 000 000 0071 000 000 007. answer1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;int arr[maxn],n,m;const int mod=1e9+7;int main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin&gt;&gt;n&gt;&gt;m; while(m--){ int tmp; cin&gt;&gt;tmp; arr[tmp]=-1; } arr[0]=1; for(int i=1;i&lt;=n;++i){ if(arr[i]==-1){ arr[i]=0; continue; } else arr[i]=(i&gt;=2?arr[i-2]:0)%mod+arr[i-1]%mod; arr[i]%=mod; } cout&lt;&lt;arr[n]&lt;&lt;endl; return 0;}","link":"/2019/07/Typical-Stairs/"},{"title":"Valentine's Day","text":"Valentine’s DayTime Limit: 2000/2000 MS (Java/Others) Memory Limit: 524288/524288 K (Java/Others)Total Submission(s): 137 Accepted Submission(s): 66Special Judge Problem Description Oipotato loves his girlfriend very much. Since Valentine’s Day is coming, he decides to buy some presents for her. There are n presents in the shop, and Oipotato can choose to buy some of them. We know that his girlfriend will possibly feel extremely happy if she receives a present. Therefore, if Oipotato gives k presents to his girlfriend, she has k chances to feel extremely happy. However, Oipotato doesn’t want his girlfriend to feel extremely happy too many times for the gifts.、 Formally, for each present i, it has a possibility of Pi to make Oipotato’s girlfriend feel extremely happy. Please help Oipotato decide what to buy and maximize the possibility that his girlfriend feels extremely happy for exactly one time. Input There are multiple test cases. The first line of the input contains an integer T (1≤T≤100), indicating the number of test cases. For each test case: The first line contains an integer n (1≤n≤10 000), indicating the number of possible presents. The second line contains n decimals Pi (0≤Pi≤1) with exactly six digits after the decimal point, indicating the possibility that Oipotato’s girlfriend feels extremely happy when receiving present i. It is guaranteed that the sum of n in all test cases does not exceed 450000. Output For each test case output one line, indicating the answer. Your answer will be considered correct if and only if the absolute error of your answer is less than 10−6. Sample Input 12345230.100000 0.200000 0.90000030.100000 0.300000 0.800000 Sample Output 120.9000000000000.800000000000 Source 2019 Multi-University Training Contest 10 理解：首先，先按照概率的大小sort一下(我也不知道为什么sort一下，但是看着就像是sort一下的样子）。然后我们建立递推式，我们根据礼物$1-i$总结的唯一有用的两个信息便是这$i$个礼物中高兴一次的概率$p_i$和不高兴的概率$q_i$，我们根据这个信息加上第$i+1$个礼物的高兴的概率$P_i$，可以推出前$i+1$个中高兴一次的概率$p_i*(1-P_i)+P_i*q_i$和不高兴的概率$q_i*(1-P_i)$.我们在这个推理的过程中取得高兴一次的最大值。 Code:12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e4+10;double a[maxn],ans;double ca,cb;int t,n;int cmp(double a,double b){return a&gt;b;}int main(){ scanf(\"%d\",&amp;t); while(t--){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i)scanf(\"%lf\",&amp;a[i]); sort(a+1,a+1+n,cmp); ans=a[1]; ca=a[1],cb=1-a[1]; int inx=2; while(inx&lt;=n){ double pra=ca,prb=cb; ca=pra*(1-a[inx])+prb*a[inx]; cb=prb*(1-a[inx]); ans=max(ans,ca); ++inx; } printf(\"%.12lf\\n\",ans); }return 0;}","link":"/2019/08/Valentine-s-Day/"},{"title":"White Lines","text":"White Lines Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//--------------------- //版权声明：本文为CSDN博主「pxlsdz」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。//原文链接：https://blog.csdn.net/sdz20172133/article/details/99307046#include &lt;bits/stdc++.h&gt;using namespace std;const int N=2005;int sumR[N][N],sumC[N][N];int ansR[N][N],ansC[N][N];int R[N][N],C[N][N]; char ch[N];int n,k;void out(int a[][N]){ for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { cout&lt;&lt;a[i][j]; } cout&lt;&lt;endl; } cout&lt;&lt;endl;}int main(){ scanf(\"%d%d\",&amp;n,&amp;k); for(int i=1; i&lt;=n; i++) { scanf(\"%s\",ch+1); for(int j=1; j&lt;=n; j++) { sumR[i][j]=sumR[i][j-1]+(ch[j]=='B'); sumC[i][j]=sumC[i-1][j]+(ch[j]=='B'); } } int pre_sum=0; for(int i=1; i&lt;=n; i++) { if(sumR[i][n]==0) pre_sum++; } for(int i=1; i&lt;=n; i++) { if(sumC[n][i]==0) pre_sum++; } for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n-k+1; j++) { if(sumR[i][n]!=0) if(sumR[i][n]==sumR[i][j+k-1]-sumR[i][j-1]) { R[i][j]=1; } } } for(int j=1; j&lt;=n; j++) { for(int i=1; i&lt;=n-k+1; i++) { if(sumC[n][j]!=0) if(sumC[n][j]==sumC[i+k-1][j]-sumC[i-1][j]) { C[i][j]=1; } } } /* out(ansR); out(ansC); */ for(int i=1; i&lt;=n; i++) { for(int j=1; j&lt;=n; j++) { ansR[i][j]=ansR[i][j-1]+C[i][j]; ansC[i][j]=ansC[i-1][j]+R[i][j]; } } /*out(ansR); out(ansC); */ int ans=0; for(int i=1; i&lt;=n-k+1; i++) for(int j=1; j&lt;=n-k+1; j++) { ans=max(ans,ansR[i][j+k-1]-ansR[i][j-1]+ansC[i+k-1][j]-ansC[i-1][j]) ; } printf(\"%d\",ans+pre_sum); }","link":"/2019/08/White-Lines/"},{"title":"WonderTeam","text":"WonderTeam 最近的贪心我就没有做出来的，一开始这道题想的是让这支队伍赢得次数很多，因为他需要最多的赢得次数。但是实际上，它不需要赢得次数很多，它只需要比其他队伍多就好。emmmm 题目大意： 有n支队伍，每两支队伍打两场比赛(主客场各一次)，胜得3分，平得1分，输不得分，比赛结束之后会评选出一个梦之队，梦之队满足以下条件：进球总数最多，胜利场数最多，丢求总数最少，三个都不能并列，求梦之队的最低排名 解析来自：https://blog.csdn.net/l123012013048/article/details/44001543 分析 1.让梦之队的胜利场的进球总数达到无穷大(当然这是不可能的)，输的场都是进0球对方队伍进1球，平的场都是0:0的得分，这样即使梦之队只赢一场也能达到进球总数最多了，其他队伍的平局的时候就让其丢求数大于梦之队的总丢球数，这样梦之队的丢球总数就是最少了 2.胜利场数最多，胜利场的得分是3分，要让梦之队的排名尽量低的话，胜利场数就不能太多，输的场数让其多一点 Code：1234567891011121314#include&lt;cstdio&gt; int main() { int n; while( scanf(\"%d\",&amp;n) == 1 &amp;&amp; n ) { if(n &lt;= 3) printf(\"1\\n\"); else if(n == 4) printf(\"2\\n\"); else printf(\"%d\\n\",n); } return 0; }","link":"/2019/09/WonderTeam/"},{"title":"codeforces1294","text":"A. Collecting CoinsDescription:Polycarp has three sisters: Alice, Barbara, and Cerene. They’re collecting coins. Currently, Alice has $a$ coins, Barbara has $b$ coins and Cerene has $c$ coins. Recently Polycarp has returned from the trip around the world and brought $n$ coins.He wants to distribute all these $n$ coins between his sisters in such a way that the number of coins Alice has is equal to the number of coins Barbara has and is equal to the number of coins Cerene has. In other words, if Polycarp gives $A$ coins to Alice, $B$ coins to Barbara and $C$ coins to Cerene ($A+B+C=n$), then $a + A = b + B = c + C$.Note that A, B or C (the number of coins Polycarp gives to Alice, Barbara and Cerene correspondingly) can be 0. Your task is to find out if it is possible to distribute all $n$ coins between sisters in a way described above.You have to answer $t$ independent test cases. Input:The first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) — the number of test cases.The next $t$ lines describe test cases. Each test case is given on a new line and consists of four space-separated integers $a, b, c$ and $n$ ($1 \\le a, b, c, n \\le 10^8$) — the number of coins Alice has, the number of coins Barbara has, the number of coins Cerene has and the number of coins Polycarp has. OutputFor each test case, print “YES” if Polycarp can distribute all $n$ coins between his sisters and “NO” otherwise. Sample Input:12345655 3 2 8100 101 102 1053 2 1 10000000010 20 15 14101 101 101 3 Sample Output:12345YESYESNONOYES 题目链接AC代码:12345678910111213141516171819202122232425/** * author: MySakure * created: 25.01.2020 17:32:07 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;=n;i++)#define per(i,a,n) for (int i=n;i&gt;=a;i--)int a,b,c,d,t;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;t; while(t--){ cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; if((a+b+c+d)%3==0&amp;&amp;(a+b+c+d)/3&gt;=max(a,max(b,c))) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; } return 0;} B. Collecting PackagesDescription:There is a robot in a warehouse and $n$ packages he wants to collect. The warehouse can be represented as a coordinate grid. Initially, the robot stays at the point $(0, 0)$. The $i$-th package is at the point $(x_i, y_i)$. It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point $(0, 0)$ doesn’t contain a package.The robot is semi-broken and only can move up (‘U’) and right (‘R’). In other words, in one move the robot can go from the point $(x, y)$ to the point ($x + 1, y$) or to the point $(x, y + 1)$.As we say above, the robot wants to collect all $n$ packages (in arbitrary order). He wants to do it with the minimum possible number of moves. If there are several possible traversals, the robot wants to choose the lexicographically smallest path.The string $s$ of length $n$ is lexicographically less than the string $t$ of length $n$ if there is some index $1 \\le j \\le n$ that for all $i$ from $1$ to $j-1$ $s_i = t_i$ and $s_j &lt; t_j$. It is the standard comparison of string, like in a dictionary. Most programming languages compare strings in this way. Input:The first line of the input contains an integer $t$ ($1 \\le t \\le 100$) — the number of test cases. Then test cases follow.The first line of a test case contains one integer $n$ ($1 \\le n \\le 1000$) — the number of packages.The next $n$ lines contain descriptions of packages. The $i$-th package is given as two integers $x_i$ and $y_i$ ($0 \\le x_i, y_i \\le 1000$) — the $x$-coordinate of the package and the $y$-coordinate of the package.It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point $(0, 0)$ doesn’t contain a package.The sum of all values $n$ over test cases in the test doesn’t exceed $1000$. OutputPrint the answer for each test case.If it is impossible to collect all $n$ packages in some order starting from ($0,0$), print “NO” on the first line.Otherwise, print “YES” in the first line. Then print the shortest path — a string consisting of characters ‘R’ and ‘U’. Among all such paths choose the lexicographically smallest path.Note that in this problem “YES” and “NO” can be only uppercase words, i.e. “Yes”, “no” and “YeS” are not acceptable. Sample Input:123456789101112351 31 23 35 54 321 00 114 3 Sample Output:12345YESRUUURRRRUUNOYESRRRRUUU 题目链接AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * author: MySakure * created: 25.01.2020 17:36:36 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;=n;i++)#define per(i,a,n) for (int i=n;i&gt;=a;i--)const int maxn=1e3+10;int t,n;struct point{ int x,y;}a[maxn];bool cmp(const point&amp;a,const point&amp;b){ return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;t; a[0].x=a[0].y=0; while(t--){ cin&gt;&gt;n; for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i].x&gt;&gt;a[i].y; sort(a+1,a+1+n,cmp); bool flag=true; for(int i=0;i&lt;n;++i) flag=flag&amp;&amp;a[i].x&lt;=a[i+1].x&amp;&amp;a[i].y&lt;=a[i+1].y; if(!flag){ cout&lt;&lt;\"NO\"&lt;&lt;endl; continue; } cout&lt;&lt;\"YES\"&lt;&lt;endl; for(int i=0;i&lt;n;++i){ int res=a[i+1].x-a[i].x; while(res--)cout&lt;&lt;\"R\"; res=a[i+1].y-a[i].y; while(res--)cout&lt;&lt;\"U\"; } cout&lt;&lt;'\\n'; } return 0;} C. Product of Three NumbersDescription:You are given one integer number $n$. Find three distinct integers $a, b, c$ such that $2 \\le a, b, c$ and $a \\cdot b \\cdot c = n$ or say that it is impossible to do it.If there are several answers, you can print any.You have to answer $t$ independent test cases. Input:The first line of the input contains one integer $t$ ($1 \\le t \\le 100$) — the number of test cases.The next $n$ lines describe test cases. The $i$-th test case is given on a new line as one integer $n$ ($2 \\le n \\le 10^9$). OutputFor each test case, print the answer on it. Print “NO” if it is impossible to represent $n$ as $a \\cdot b \\cdot c$ for some distinct integers $a, b, c$ such that $2 \\le a, b, c$.Otherwise, print “YES” and any possible such representation. Sample Input:1234565643297212345 Sample Output:1234567YES2 4 8 NONONOYES3 5 823 题目链接AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * author: MySakure * created: 25.01.2020 17:48:32 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;=n;i++)#define per(i,a,n) for (int i=n;i&gt;=a;i--)int t,n,a[100],id;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; id=0; memset(a,0,sizeof(a)); for(int i=2;i*i&lt;=n;++i){ //cout&lt;&lt;\"deug \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;n&lt;&lt;endl; if(n%i!=0)continue; while(n%i==0){ a[++id]=i; n/=i; } } if(n!=1)a[++id]=n; int ansa=0,ansb=0,ansc=1,res=1; ansa=a[1]; if(a[1]==a[2]){ ansb=a[2]*a[3]; res=4; } else { ansb=a[2]; res=3; } for(int i=res;i&lt;=id;++i)ansc*=a[i]; if(ansa&amp;&amp;ansb&amp;&amp;ansc&gt;1&amp;&amp;ansc!=ansa&amp;&amp;ansb!=ansc){ cout&lt;&lt;\"YES\"&lt;&lt;'\\n'; cout&lt;&lt;ansa&lt;&lt;\" \"&lt;&lt;ansb&lt;&lt;\" \"&lt;&lt;ansc&lt;&lt;'\\n'; } else cout&lt;&lt;\"NO\"&lt;&lt;'\\n'; } return 0;} D. MEX maximizingDescription:Recall that MEX of an array is a minimum non-negative integer that does not belong to the array. Examples: for the array $[0, 0, 1, 0, 2]$ MEX equals to $3$ because numbers $0, 1$ and $2$ are presented in the array and $3$ is the minimum non-negative integer not presented in the array; for the array $[1, 2, 3, 4]$ MEX equals to $0$ because $0$ is the minimum non-negative integer not presented in the array; for the array $[0, 1, 4, 3]$ MEX equals to $2$ because $2$ is the minimum non-negative integer not presented in the array. You are given an empty array $a=[]$ (in other words, a zero-length array). You are also given a positive integer $x$.You are also given $q$ queries. The $j$-th query consists of one integer $y_j$ and means that you have to append one element $y_j$ to the array. The array length increases by $1$ after a query.In one move, you can choose any index $i$ and set $a_i := a_i + x$ or $a_i := a_i - x$ (i.e. increase or decrease any element of the array by $x$). The only restriction is that $a_i$ cannot become negative. Since initially the array is empty, you can perform moves only after the first query.You have to maximize the MEX (minimum excluded) of the array if you can perform any number of such operations (you can even perform the operation multiple times with one element).You have to find the answer after each of $q$ queries (i.e. the $j$-th answer corresponds to the array of length $j$).Operations are discarded before each query. I.e. the array $a$ after the $j$-th query equals to $[y_1, y_2, \\dots, y_j]$. Input:The first line of the input contains two integers $q, x$ ($1 \\le q, x \\le 4 \\cdot 10^5$) — the number of queries and the value of $x$.The next $q$ lines describe queries. The $j$-th query consists of one integer $y_j$ ($0 \\le y_j \\le 10^9$) and means that you have to append one element $y_j$ to the array. OutputPrint the answer to the initial problem after each query — for the query $j$ print the maximum value of MEX after first $j$ queries. Note that queries are dependent (the array changes after each query) but operations are independent between queries. Sample Input:123456787 301220010 Sample Output:12345671233447 Sample Input:123454 31212 Sample Output:12340000 题目链接AC代码:1234567891011121314151617181920212223/** * author: MySakure * created: 27.01.2020 11:24:50 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;=n;i++)#define per(i,a,n) for (int i=n;i&gt;=a;i--)const int maxn=4e5+10;int q,x,a[maxn],id;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;q&gt;&gt;x; while(q--){ int res; cin&gt;&gt;res; a[res%x]++; while(a[id%x])a[id%x]--,++id; cout&lt;&lt;id&lt;&lt;'\\n'; } return 0;} E. Obtain a PermutationDescription:You are given a rectangular matrix of size $n \\times m$ consisting of integers from $1$ to $2 \\cdot 10^5$.In one move, you can: choose any element of the matrix and change its value to any integer between $1$ and $n \\cdot m$, inclusive; take any column and shift it one cell up cyclically (see the example of such cyclic shift below). A cyclic shift is an operation such that you choose some $j$ ($1 \\le j \\le m$) and set $a_{1, j} := a_{2, j}, a_{2, j} := a_{3, j}, \\dots, a_{n, j} := a_{1, j}$ simultaneously. Example of cyclic shift of the first column You want to perform the minimum number of moves to make this matrix look like this: In other words, the goal is to obtain the matrix, where $a_{1, 1} = 1, a_{1, 2} = 2, \\dots, a_{1, m} = m, a_{2, 1} = m + 1, a_{2, 2} = m + 2, \\dots, a_{n, m} = n \\cdot m$ (i.e. $a_{i, j} = (i - 1) \\cdot m + j$) with the minimum number of moves performed. Input:The first line of the input contains two integers $n$ and $m$ ($1 \\le n, m \\le 2 \\cdot 10^5, n \\cdot m \\le 2 \\cdot 10^5$) — the size of the matrix.The next $n$ lines contain $m$ integers each. The number at the line $i$ and position $j$ is $a_{i, j}$ ($1 \\le a_{i, j} \\le 2 \\cdot 10^5$). OutputPrint one integer — the minimum number of moves required to obtain the matrix, where $a_{1, 1} = 1, a_{1, 2} = 2, \\dots, a_{1, m} = m, a_{2, 1} = m + 1, a_{2, 2} = m + 2, \\dots, a_{n, m} = n \\cdot m$ ($a_{i, j} = (i - 1)m + j$). Sample Input:12343 33 2 11 2 34 5 6 Sample Output:16 Sample Input:123454 31 2 34 5 67 8 910 11 12 Sample Output:10 Sample Input:12343 41 6 3 45 10 7 89 2 11 12 Sample Output:12 题目链接AC代码:123456789101112131415161718192021222324252627282930313233343536373839/** * author: MySakure * created: 27.01.2020 16:06:00 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;=n;i++)#define per(i,a,n) for (int i=n;i&gt;=a;i--)const int maxn=2e5+10;int n,m,res[maxn];signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n&gt;&gt;m; vector&lt;vector&lt;int&gt;&gt;a(n,vector&lt;int&gt;(m)); for(int i=0;i&lt;n;++i) for(int j=0;j&lt;m;++j){ cin&gt;&gt;a[i][j]; a[i][j]--; } int ans=0; for(int i=0;i&lt;m;++i){ for(int j=0;j&lt;n;++j) res[j]=n; for(int j=0;j&lt;n;++j){ if(a[j][i]%m!=i||a[j][i]/m&gt;=n)continue; res[((j+n-a[j][i]/m)%n+n)%n]--; //cout&lt;&lt;\"debug \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;i&lt;&lt;\" \"&lt;&lt;(a[j][i]/m-j+n)%n&lt;&lt;endl; } int cnt=1e9; for(int j=0;j&lt;n;++j) cnt=min(cnt,j+res[j]); //cout&lt;&lt;\"debug \"&lt;&lt;cnt&lt;&lt;endl; ans+=cnt; } cout&lt;&lt;ans&lt;&lt;'\\n'; return 0;} F. Three Paths on a TreeDescription:You are given an unweighted tree with $n$ vertices. Recall that a tree is a connected undirected graph without cycles.Your task is to choose three distinct vertices $a, b, c$ on this tree such that the number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$ is the maximum possible. See the notes section for a better understanding.The simple path is the path that visits each vertex at most once. Input:The first line contains one integer number $n$ ($3 \\le n \\le 2 \\cdot 10^5$) — the number of vertices in the tree.Next $n - 1$ lines describe the edges of the tree in form $a_i, b_i$ ($1 \\le a_i$, $b_i \\le n$, $a_i \\ne b_i$). It is guaranteed that given graph is a tree. OutputIn the first line print one integer $res$ — the maximum number of edges which belong to at least one of the simple paths between $a$ and $b$, $b$ and $c$, or $a$ and $c$.In the second line print three integers $a, b, c$ such that $1 \\le a, b, c \\le n$ and $a \\ne, b \\ne c, a \\ne c$.If there are several answers, you can print any. Sample Input:1234567881 22 33 44 54 63 73 8 Sample Output:1251 8 6 题目链接AC代码:","link":"/2020/01/codeforces1294/"},{"title":"lydsy1001","text":"1001: [BeiJing2006]狼抓兔子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;using namespace std;#define N 2000001#define M 8000010#define p(a,b) m*(a-1)+bconst int maxn=1e6+10;int n,m,c,head[N],id=-1,cur[N],d[N],vis[N],s,t;struct edge{ int to,next,cap;}e[M];inline int read(){ int x=0,f=1;char ch; while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}void addedge(int from,int to,int c){ id++; e[id].to=to; e[id].next=head[from]; e[id].cap=c; head[from]=id;}queue&lt;int&gt;Q;int bfs(){ for(int i=s;i&lt;=t;i++)vis[i]=0,d[i]=-1; while(!Q.empty())Q.pop(); Q.push(s); vis[s]=1,d[s]=0; while(!Q.empty()){ int u=Q.front(); Q.pop(); for(int i=head[u];i!=-1;i=e[i].next){ int v=e[i].to; if(e[i].cap&lt;=0||vis[v])continue; d[v]=d[u]+1; vis[v]=1;Q.push(v); if(v==t)return true; } } return vis[t];}int dfs(int u,int a){ if(u==t||!a)return a; int f,flow=0; for(int &amp;i=cur[u];i!=-1;i=e[i].next){ int v=e[i].to; if(d[v]==d[u]+1&amp;&amp;(f=dfs(v,min(a,e[i].cap)))&gt;0){ flow+=f; a-=f; e[i].cap-=f; e[i^1].cap+=f; if(!a)break; } } return flow;}void add(int from,int to,int c){ addedge(from,to,c); addedge(to,from,c);}int dinic(){ int flow=0; while(bfs()){ for(int i=s;i&lt;=t;i++)cur[i]=head[i]; flow+=dfs(1,1e9); //cerr&lt;&lt;\"debug \"&lt;&lt;flow&lt;&lt;endl; } return flow;}signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); n=read(),m=read(); s=1,t=n*m; memset(head,-1,sizeof(head)); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; m; ++j) { int tmp=read(); add(p(i,j),p(i,j+1), tmp); } for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt;= m; ++j) { int tmp=read(); add(p(i,j),p(i+1,j), tmp); } for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt; m; ++j) { int tmp=read(); add(p(i,j),p(i+1,j+1), tmp); } cout&lt;&lt;dinic()&lt;&lt;endl; return 0;}","link":"/2019/07/lydsy1001/"},{"title":"permutation 2","text":"permutation 2Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others)Total Submission(s): 158 Accepted Submission(s): 83 Problem Description You are given three positive integers N,x,y.Please calculate how many permutations of 1∼N satisfies the following conditions (We denote the i-th number of a permutation by pi): \\1. p1=x \\2. pN=y \\3. for all 1≤i&lt;N, |pi−pi+1|≤2 Input The first line contains one integer T denoting the number of tests. For each test, there is one line containing three integers N,x,y. * 1≤T≤5000 * 2≤N≤105 * 1≤x&lt;y≤N Output For each test, output one integer in a single line indicating the answer modulo 998244353. Sample Input 123434 1 44 2 4100000 514 51144 Sample Output 12321253604680 Source 2019 Multi-University Training Contest 5 题解： 群里大佬理解：设Fn表示起始点为$1$，终点为$n$时，方案数只有两种方法 一个是走一步（n-1） 一种是走两步退一步再走两步（n-3） 代码：12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod=998244353;const int maxn=1E5+10;ll a[maxn],n,t,x,y;int main(){ scanf(\"%lld\",&amp;t); while(t--){ scanf(\"%lld%lld%lld\",&amp;n,&amp;x,&amp;y); if(x==1&amp;&amp;y!=n){ n=y-2; }else if(x!=1&amp;&amp;y==n){ n=n-x-1; }else if(x!=1&amp;&amp;y!=n){ n=y-x-2; }else n=n-1; a[0]=a[1]=a[2]=1; for(int i=3;i&lt;=n;i++){ a[i]=(a[i-1]+a[i-3])%mod; } printf(\"%lld\\n\",a[n]); } return 0;}","link":"/2019/08/permutation-2/"},{"title":"sequence","text":"链接：https://ac.nowcoder.com/acm/contest/884/C来源：牛客网 Your are given two sequences a1…na_{1 \\dots n}a1…n and b1…nb_{1 \\dots n}b1…n .You need to answer max⁡1≤l≤r≤n{min(al…r)×sum(bl…r)}\\displaystyle \\max_{1 \\le l \\le r \\le n} {min(a_{l \\dots r}) \\times sum(b_{l \\dots r})}1≤l≤r≤nmax{min(al…r)×sum(bl…r)} 。 Where min(a) means the minimal value of every element of sequence a, sum(a) means the sum of every element of sequence a . 输入描述:The first line contains an integer n .The second line contains n integers meaning a1…na_{1 \\dots n}a1…n .The third line contains n integers meaning b1…nb_{1 \\dots n}b1…n . 输出描述:An integer meaning the answer. 示例1 输入复制 12331 -1 11 2 3 输出复制 13 备注:1For all test datas, 1≤n≤3×106,−106≤ai,bi≤1061 \\leq n \\leq 3 \\times 10^6,-10^6 \\leq a_i,b_i \\leq 10^61≤n≤3×106,−106≤ai,bi≤106. 代码：笛卡尔Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define ll long longconst int maxn=3e6+10;int a[maxn],n;ll b[maxn],ans;struct node{ int l,r,par,size; ll Max,Min; node():l(0),r(0),par(0),Max(-1e14),Min(1e14){}}tr[maxn];inline int build(){ stack&lt;int&gt;s; rep(i,1,n){ int pop=-1; while(!s.empty()&amp;&amp;a[s.top()]&gt;a[i]){ pop=s.top(); s.pop(); } if(!s.empty()){ tr[s.top()].r=i; tr[i].par=s.top(); } if(pop!=-1){ tr[pop].par=i; tr[i].l=pop; } s.push(i); } int root=-1; while(!s.empty()){ root=s.top(); s.pop(); } return root;}void dfs(int root){ if(root==0)return; dfs(tr[root].l),dfs(tr[root].r); tr[root].Min=min(b[root-1],min(tr[tr[root].l].Min,tr[tr[root].r].Min)); tr[root].Max=max(b[root],max(tr[tr[root].l].Max,tr[tr[root].r].Max));}inline ll solve(int root){ if(root==0)return -1e18; if(tr[root].l==0&amp;&amp;tr[root].r==0)return a[root]*(b[root]-b[root-1]); ll ans=max(solve(tr[root].l),solve(tr[root].r)); if(tr[root].l!=0&amp;&amp;tr[root].r!=0){ ans=max(a[root]*(tr[tr[root].r].Max-tr[tr[root].l].Min),ans); ans=max(a[root]*(tr[tr[root].r].Min-tr[tr[root].l].Max),ans); } else if(tr[root].l==0){ ans=max(a[root]*(tr[tr[root].r].Max-tr[root].Min),ans); ans=max(a[root]*(tr[tr[root].r].Min-tr[root].Max),ans); } else{ ans=max(a[root]*(tr[root].Max-tr[tr[root].l].Min),ans); ans=max(a[root]*(tr[root].Min-tr[tr[root].l].Max),ans); } return ans;}signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;n; rep(i,1,n)cin&gt;&gt;a[i]; rep(i,1,n){cin&gt;&gt;b[i];b[i]+=b[i-1];} int root=build(); dfs(root); cout&lt;&lt;solve(root)&lt;&lt;endl; return 0;} 线段树：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define int long longconst int maxn = 3e6 + 10; int a[maxn], b[maxn], n, st[maxn][2]; ll f[maxn], ans=-1e18;struct node { int l, r; ll Max, Min;}seg[maxn &lt;&lt; 2];stack&lt;int&gt;s;queue&lt;int&gt;q;void build(int root, int l, int r) { seg[root].l = l, seg[root].r = r; if (l == r) { //cerr &lt;&lt; \"build \" &lt;&lt; l &lt;&lt; endl; seg[root].Max = f[l], seg[root].Min = f[l]; return; } int mid = (l + r) &gt;&gt; 1; build(root &lt;&lt; 1, l, mid); build(root &lt;&lt; 1 | 1, mid + 1, r); seg[root].Max = max(seg[root &lt;&lt; 1].Max, seg[root &lt;&lt; 1 | 1].Max); seg[root].Min = min(seg[root &lt;&lt; 1].Min, seg[root &lt;&lt; 1 | 1].Min);}ll FindMin(int root, int L, int R) { int l = seg[root].l, r = seg[root].r; if (l == L &amp;&amp; r == R) { //cerr &lt;&lt; \"seg[root].Min \" &lt;&lt; seg[root].Min &lt;&lt; endl; return seg[root].Min; } int mid = (l + r) &gt;&gt; 1; if (R &lt;= mid)return FindMin(root &lt;&lt; 1, L, R); else if (L &gt; mid)return FindMin(root &lt;&lt; 1 | 1, L, R); else return min(FindMin(root &lt;&lt; 1, L, mid), FindMin(root &lt;&lt; 1 | 1, mid + 1, R));}ll FindMax(int root, int L, int R) { int l = seg[root].l, r = seg[root].r; if (l == L &amp;&amp; r == R) return seg[root].Max; int mid = (l + r) &gt;&gt; 1; if (R &lt;= mid)return FindMax(root &lt;&lt; 1, L, R); else if (L &gt; mid)return FindMax(root &lt;&lt; 1 | 1, L, R); else return max(FindMax(root &lt;&lt; 1, L, mid), FindMax(root &lt;&lt; 1 | 1, mid + 1, R));}signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; b[i]; f[i] = f[i - 1] + b[i]; } for (int i = 1; i &lt;= n; ++i) { while (!s.empty() &amp;&amp; a[s.top()] &gt; a[i]) { int inx = a[s.top()]; while (!s.empty() &amp;&amp; a[s.top()] == inx) { //cerr &lt;&lt; \"debug \" &lt;&lt; endl; q.push(s.top()); s.pop(); } while (!q.empty()) { st[q.front()][1] = i; //cerr &lt;&lt; \"emmm \"&lt;&lt;i &lt;&lt; endl; q.pop(); } } st[i][0] = s.empty() ? 0 : s.top(); s.push(i); } while (!s.empty()) { st[s.top()][1] = n + 1; s.pop(); } build(1, 0, n); //cerr &lt;&lt; \"finmin \" &lt;&lt; FindMin(1, 0, n) &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) { //cerr &lt;&lt; \"debug \"&lt;&lt;i&lt;&lt;\" \" &lt;&lt; st[i][1] - 1 &lt;&lt; \" \" &lt;&lt; st[i][0] &lt;&lt; endl; //cerr &lt;&lt; FindMax(1, i, st[i][1] - 1) &lt;&lt; \" \" &lt;&lt; FindMin(1, st[i][0], i) &lt;&lt; endl; if (a[i] &gt; 0)ans = max(ans, a[i] * 1ll * (FindMax(1, i, st[i][1] - 1) - FindMin(1, st[i][0], i))); else ans = max(ans, a[i] * 1ll * (FindMin(1, i, st[i][1] - 1) - FindMax(1, st[i][0], i))); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} 题解：","link":"/2019/07/sequence/"},{"title":"命令行爬取nowcoder测试数据和提交代码n","text":"命令行提交nowcoder首先，我要说明这代码非常的不完善，而且存在很多弱智的bug，而且还有很大的局限性。emmmmm，看起来一无是处，但是一定程度上方便了我的使用。 我的邮箱，大家有问题可以发我：mysakure@qq.com 先把代码贴出来： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154# -*- coding: utf-8 -*-import requestsimport sysimport reimport osimport stringimport timeimport datetimefrom bs4 import BeautifulSoupimport jsondef MkdirFolder(path,Flag=True): folder=os.path.exists(path) if not folder or Flag: if not folder: os.makedirs(path) else: x=input(\"file already exists,overwrite?y/n\") while x!='y' and x!='n': x = input(\"invalid input,please input again: y/n\") if x=='n': sys.exit()def ParseData(path,url,headers): html = requests.get(url+'A', headers=headers) htmlbs=BeautifulSoup(html.text,\"html.parser\") #判断cookie是否已经过期 if str(htmlbs.title)=='&lt;title&gt;登录_牛客网&lt;/title&gt;': print(\"Cookie is out of date, please update it\") sys.exit() #创建比赛文件夹 MkdirFolder(path,False) for id in string.ascii_uppercase: html = requests.get(url+id, headers=headers) urls=re.findall('data-clipboard-text=\"[\\s\\S]*?\"',html.text) if len(urls)==0: sys.exit() cpath = path + \"/\" + id.lower()+\"/\" MkdirFolder(cpath) inx=0 while(inx&lt;len(urls)): with open(cpath+\"in\"+str(int(inx/2+1))+\".txt\", 'w') as file: file.write(urls[inx][21:-1]) with open(cpath + \"ans\" + str(int(inx/2+1)) + \".txt\", 'w') as file: file.write(urls[inx+1][21:-1]) inx=inx+2 print(str(id) + \" with \" + str(int(len(urls) / 2)) + \" examples\")#获得要提交问题的questionIddef Get_questionId(text,headers): s=re.findall(\"questionId:[\\s\\S]*?,\",text) return int(re.findall(r\"\\d+\",s[0])[0])#获得要提交问题的tagIddef Get_tagId(text,headers): s=re.findall(\"tagId:[\\s\\S]*?,\",text) return int(re.findall(r\"\\d+\",s[0])[0])#获得要提交问题的subTagIddef Get_subTagId(text,headers): s=re.findall(\"subTagId:[\\s\\S]*?,\",text) return int(re.findall(r\"\\d+\",s[0])[0])#获得要提交问题的doneQuestionIddef Get_doneQuestionId(text,headers): s=re.findall(\"doneQuestionId:[\\s\\S]*?,\",text) return int(re.findall(r\"\\d+\",s[0])[0])def SubmitCode(headers,code,questionId,tagId,subTagId,doneQuestionId): url=\"https://ac.nowcoder.com/nccommon/submit_cd?\" data = {'questionId': questionId,'tagId': tagId,'subTagId': subTagId,'content':code,'language': 2,'languageName': 'C++11(clang++ 3.9)','doneQuestionId': doneQuestionId} r =requests.post(url,headers=headers,data=data) #返回代码的提交ID return int(re.findall(r\"\\d+\",r.text)[1])def main(): #print(os.path.abspath('.').split('/')[-1]) #print(os.path.abspath('.').split('/')[-2]) #下一行代码为cookie存储位置，务必设置为自己的 with open(\"/home/mysakure/.cookie/NowCoderCookie\", 'r') as myfile: cookie = myfile.read() headers = {'Sec-Fetch-Mode': 'no-cors', 'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Mobile Safari/537.36', 'Referer': 'https://ac.nowcoder.com/acm/contest/1112', 'cookie':cookie[0:-1]} if len(sys.argv)==1: print(\"Usage:\\n now parse [&lt;contest-id&gt;]\") print(\"Usage:\\n now submit\") sys.exit() if sys.argv[1]==\"parse\": if len(sys.argv)!=3: print(\"Usage:\\n now parse [&lt;contest-id&gt;]\") sys.exit() url=\"https://ac.nowcoder.com/acm/contest/\"+sys.argv[2]+\"/\" ParseData(sys.argv[2],url,headers) if sys.argv[1]==\"submit\": problemid=os.path.abspath('.').split('/')[-1] contestid=os.path.abspath('.').split('/')[-2] url=\"https://ac.nowcoder.com/acm/contest/\"+contestid+'/'+problemid problemhtml=requests.get(url,headers=headers) html_bs=BeautifulSoup(problemhtml.text,\"html.parser\") if str(html_bs.title)=='&lt;title&gt;登录_牛客网&lt;/title&gt;': print(\"Cookie is out of date, please update it\") sys.exit() prob=str(html_bs.title) if problemhtml.status_code==404: print(\"cant access this problem\") sys.exit() questionId=Get_questionId(problemhtml.text,headers) tagId=Get_tagId(problemhtml.text,headers) subTagId=Get_subTagId(problemhtml.text,headers) doneQuestionId=Get_doneQuestionId(problemhtml.text,headers) with open(problemid+\".cpp\", 'r') as myfile: code = myfile.read() #print(\"Submit 1277 D GNU G++17 7.3.0\") submissionId=SubmitCode(headers,code,questionId,tagId,subTagId,doneQuestionId) print(\"Submitted\") inx = 1 status_code=0 print(\" #: %d\"%submissionId) print(\" when: %s\"%datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')) #print(\" prob: %s - %s\"%(problemid,prob[7:-7])) print(\" prob: %s\"%prob[7:-8]) while status_code==0: submissionTime=round((time.time()-800) * 1000) data={'submissionId':submissionId,'tagId':tagId,'subTagId':subTagId,'_':submissionTime} response=requests.get(\"https://ac.nowcoder.com/nccommon/status\",params=data) status=json.loads(response.text) status_code=status[\"status\"] if status_code==0: print(\"\\r status: running\",end=\"\") elif status_code==5: print(\"\\r status: %s\"%status[\"desc\"]) print(\" time: %d ms\"%status[\"seconds\"]) print(\" memory: %d KB\"%status[\"memory\"]) else : print(\"\\r status: %s\"%status[\"desc\"]) print(\"\\r memo: %s\"%status[\"memo\"][:-5]) #print(type(status[\"desc\"])) inx=inx+1 time.sleep(1)#https://ac.nowcoder.com/nccommon/status?submissionId=42562195&amp;tagId=4&amp;subTagId=1&amp;_=1577116814181main()''' #: 67499001 when: 2019-12-24 10:44 prob: D - Let's Play the Words? lang: GNU C++17 status: Accepted time: 436 ms memory: 33.59 MB''' 这份代码可以爬取nowcoder的测试数据和提交代码。但是只支持c++，但是如果想改其他语言也简单。 首先说一下这份代码最大的局限性，这份代码需要自己打开浏览器抓取cookie，而且在cookie过时时需要更新。 在使用此份代码前务必将cookie找到存储到某文件，然后将代码中cookie的存储位置改为自己的对应路径。代码中coookie位置代码中已经说明。 代码用法：首先务必设置好cookie。 爬取测试数据 1python3 now.py(上述代码文件名字) parse 比赛id 提交代码文件夹需符合 */比赛id/比赛序号/，例如/home/mysakure/4114/a/,并且相应的代码文件名字必须放置在该文件夹，并且名字必须为 比赛序号.cpp，例如a.cpp。语法为 12python3 now.py(上述代码 文件名字) submit` //下面配上我的使用记录 //爬取数据记录 12345678910111213141516171819202122232425mysakure@ubuntu:~/code/oj_shell/py$ python3 now.py parse 4114A with 1 examplesB with 2 examplesC with 2 examplesD with 2 examplesE with 1 examplesF with 2 examplesG with 2 examplesH with 1 examplesI with 2 examplesJ with 1 examplesmysakure@ubuntu:~/code/oj_shell/py$ ls4114 GetCodeforces.py now.pymysakure@ubuntu:~/code/oj_shell/py$ cd 4114mysakure@ubuntu:~/code/oj_shell/py/4114$ lsa b c d e f g h i jmysakure@ubuntu:~/code/oj_shell/py/4114$ ls */*a/ans1.txt c/in1.txt f/ans1.txt h/ans1.txta/in1.txt c/in2.txt f/ans2.txt h/in1.txtb/ans1.txt d/ans1.txt f/in1.txt i/ans1.txtb/ans2.txt d/ans2.txt f/in2.txt i/ans2.txtb/in1.txt d/in1.txt g/ans1.txt i/in1.txtb/in2.txt d/in2.txt g/ans2.txt i/in2.txtc/ans1.txt e/ans1.txt g/in1.txt j/ans1.txtc/ans2.txt e/in1.txt g/in2.txt j/in1.txt //代码提交记录 123456789101112131415161718mysakure@ubuntu:~/acmcode/codeforces$ cd ../nowcoder/mysakure@ubuntu:~/acmcode/nowcoder$ ls3781 3782 3979mysakure@ubuntu:~/acmcode/nowcoder$ cd 3781mysakure@ubuntu:~/acmcode/nowcoder/3781$ lsa b c d e fmysakure@ubuntu:~/acmcode/nowcoder/3781$ cd amysakure@ubuntu:~/acmcode/nowcoder/3781/a$ lsa.cpp ans1.txt in1.txt sol.outmysakure@ubuntu:~/acmcode/nowcoder/3781/a$ now submitSubmitted #: 42729124 when: 2020-01-28 18:18:34 prob: A-Tic-Tac-Toe_牛客练习赛57 status: 答案正确:恭喜！您提交的程序通过了所有的测试用例 time: 4 ms memory: 532 KBmysakure@ubuntu:~/acmcode/nowcoder/3781/a$","link":"/2020/01/shell-submit-nowcoder/"},{"title":"string","text":"链接：https://ac.nowcoder.com/acm/contest/884/I来源：牛客网 We call a,ba,ba,b non-equivalent if and only if a≠ba \\neq ba\\=b and a≠rev(b)a \\neq rev(b)a\\=rev(b), where rev(s)rev(s)rev(s) refers to the string obtained by reversing characters of sss, for example rev(abca)=acbarev(abca)=acbarev(abca)=acba. There is a string sss consisted of lower-case letters. You need to find some substrings of sss so that any two of them are non-equivalent. Find out what’s the largest number of substrings you can choose. 输入描述:1A line containing a string sss of lower-case letters. 输出描述:1A positive integer - the largest possible number of substrings of sss that are non-equivalent. 示例1 输入复制 1abac 输出复制 18 说明1The set of following substrings is such a choice: abac,b,a,ab,aba,bac,ac,cabac,b,a,ab,aba,bac,ac,cabac,b,a,ab,aba,bac,ac,c. 备注:11≤∣s∣≤2×1051 \\leq |s|\\leq 2 \\times 10^51≤∣s∣≤2×105, sss is consisted of lower-case letters. 题解： 题目给你一个字符串s,让你求s中的子串组成的最大集合，满足这个集合内的每一个子串str, str和rev(str)不同时存在{rev(str):表示str反过来} 思路：就是先用SAM统计出s#rev(s)中不包含 ‘#’的所有子串ans1; 然后用PAM统计出s中本质不同的子串数量ans2; 这答案就是(ans1+ans2)/2; 为什么呢？ 因为在用SAM统计s#rev(s)的时候会把所有字符串统计两边，而本身就是回文串的只会统计一遍。 STD:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define SZ 455555char s[SZ]; int n;struct PTree{int ch[SZ][26],len[SZ],fail[SZ],s[SZ],cl,an,lst;int addn(int l) {len[an]=l; return an++;}PTree(){ cl=an=lst=0; memset(ch,0,sizeof(ch)); addn(0); addn(-1); fail[0]=1; s[0]=-233;}int gfail(int x,int l){ while(s[l-len[x]-1]!=s[l]) x=fail[x]; return x;}void add(int c){ s[++cl]=c; int cp=gfail(lst,cl); if(!ch[cp][c]) { int nn=addn(len[cp]+2); fail[nn]=ch[gfail(fail[cp],cl)][c]; ch[cp][c]=nn; } lst=ch[cp][c];}}pt;int sa[SZ],rk[SZ],su[SZ],ork[SZ],h[SZ];bool diff(int a,int b,int g){return ork[a]!=ork[b]||ork[a+g]!=ork[b+g];}void build_sa(){ int G=max(n,200); for(int i=0;i&lt;=G;++i) su[i]=0; for(int i=0;i&lt;n;++i) ++su[rk[i]=s[i]]; for(int i=1;i&lt;=G;++i) su[i]+=su[i-1]; for(int i=0;i&lt;n;++i) sa[--su[rk[i]]]=i; for(int g=1;g&lt;=n;g&lt;&lt;=1) { for(int i=0;i&lt;=G;++i) su[i]=0; static int ts[SZ]; int tn=0; for(int i=n-1;i&gt;=0;--i) { if(sa[i]&gt;=g) ts[++tn]=sa[i]-g; ork[i]=rk[i]; } for(int i=n-g;i&lt;n;++i) ts[++tn]=i; for(int i=1;i&lt;=tn;++i) ++su[rk[ts[i]]]; for(int i=1;i&lt;=G;++i) su[i]+=su[i-1]; for(int i=1;i&lt;=tn;++i) sa[--su[rk[ts[i]]]]=ts[i]; int t=0; for(int i=0;i&lt;n;++i) { if(i&amp;&amp;diff(sa[i-1],sa[i],g)) ++t; rk[sa[i]]=t; } } for(int i=0;i&lt;n;++i) rk[sa[i]]=i; int g=0; for(int i=0;i&lt;n;++i) { g=max(g-1,0); if(rk[i]==n-1) { h[rk[i]]=0; continue; } int A=i,B=sa[rk[i]+1]; while(s[A+g]==s[B+g]) ++g; h[rk[i]]=g; }}int main(){ scanf(\"%s\",s); n=strlen(s); for(int i=0;i&lt;n;++i) pt.add(s[i]-'a'); int p=pt.an-2,N=n; s[N]='|'; for(int i=0;i&lt;N;++i) s[N+i+1]=s[N-i-1]; n=N+N+1; build_sa(); ll tt=0; for(int i=1;i&lt;=n;++i) tt+=i-h[i-1]; printf(\"%lld\\n\",(tt-(N+1)*ll(N+1)+p)/2);} Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;const int maxn = 4e5 + 5;using namespace std;struct SAM{ int trans[maxn&lt;&lt;1][27], slink[maxn&lt;&lt;1], maxlen[maxn&lt;&lt;1]; int indegree[maxn&lt;&lt;1], endpos[maxn&lt;&lt;1], rank[maxn&lt;&lt;1]; int last, now, root, len; inline void newnode (int v) { maxlen[++now] = v; } inline void extend(int c) { newnode(maxlen[last] + 1); int p = last, np = now; // 更新trans while (p &amp;&amp; !trans[p][c]) { trans[p][c] = np; p = slink[p]; } if (!p) slink[np] = root; else { int q = trans[p][c]; if (maxlen[p] + 1 != maxlen[q]) { // 将q点拆出nq，使得maxlen[p] + 1 == maxlen[q] newnode(maxlen[p] + 1); int nq = now; memcpy(trans[nq], trans[q], sizeof(trans[q])); slink[nq] = slink[q]; slink[q] = slink[np] = nq; while (p &amp;&amp; trans[p][c] == q) { trans[p][c] = nq; p = slink[p]; } }else slink[np] = q; } last = np; // 初始状态为可接受状态 endpos[np] = 1; } inline void build(char *s) { root = last = now = 1; for (int i = 0; s[i]; ++i) extend(s[i] - 'a'); // extend(s[i] - '1'); } inline long long getNum() { // 拓扑排序 for (int i = 1; i &lt;= now; ++i) indegree[ maxlen[i] ]++; for (int i = 1; i &lt;= now; ++i) indegree[i] += indegree[i-1]; for (int i = 1; i &lt;= now; ++i) rank[ indegree[ maxlen[i] ]-- ] = i; memset(endpos, 0, sizeof(endpos)); endpos[1] = 1; // 从根节点向后求有效的入度 for (int i = 1; i &lt;= now; ++i) { int x = rank[i]; for (int j = 0; j &lt; 26; ++j) { int nex = trans[x][j]; if (!nex) continue; endpos[nex] += endpos[x]; // 有效入度 } } long long ans = 0; for (int i = 2; i &lt;= now; ++i) ans += endpos[i]; return ans; }}sam;struct Palindrome_Tree{ int nex[maxn][26]; int fail[maxn], cnt[maxn], num[maxn]; // num 记录每个节点右端点的表示回文串的个数 int len[maxn], S[maxn]; // cnt 记录每个节点表示的回文串出现的次数 int last, n, p; int newnode(int l) { // 新建节点 for (int i = 0; i &lt; 26; ++i) nex[p][i] = 0; cnt[p] = num[p] = 0; len[p] = l; return p++; } void init() { // 初始化 p = 0; newnode(0), newnode(-1); // 新建奇根和偶根 last = n = 0; S[n] = -1; fail[0] = 1; // 偶根指向 } int get_fail(int x) { // 求fail while (S[n - len[x] - 1] != S[n]) x = fail[x]; return x; } void add(int c) { // 添加节点 c -= 'a'; S[++n] = c; int cur = get_fail(last); if (!nex[cur][c]) { int now = newnode(len[cur] + 2); fail[now] = nex[get_fail(fail[cur])][c]; nex[cur][c] = now; num[now] = num[fail[now]] + 1; } last = nex[cur][c]; cnt[last]++; } void count() { // 求cnt for (int i = p - 1; i &gt;= 0; --i) cnt[fail[i]] += cnt[i]; }}Tree;char s[maxn];int main() { ios::sync_with_stdio(0); cin.tie(0), cout.tie(0); scanf(\"%s\", s); Tree.init(); int len = strlen(s); s[len] = 26 + 'a'; for (int i = 0; i &lt; len; ++i) { Tree.add(s[i]); s[i+len+1] = s[len-i-1]; } s[len+len+1] = 0; // cout &lt;&lt; s &lt;&lt; endl; sam.build(s); // cout &lt;&lt; sam.getNum() &lt;&lt; endl; long long ans = (sam.getNum() + Tree.p - 2) / 2; printf(\"%lld\\n\", ans); return 0;}","link":"/2019/07/string/"},{"title":"subsequence 1","text":"链接：https://ac.nowcoder.com/acm/contest/885/G来源：牛客网 You are given two strings s**t∼\\sim∼sntms**t Please calculate the number of valid subsequences of s that are larger than t if viewed as positive integers. A subsequence is valid if and only if its first character is not ‘0’. Two subsequences are different if they are composed of different locations in the original string. For example, string “1223” has 2 different subsequences “23”. Because the answer may be huge, please output the answer modulo 998244353. 输入描述:1The first line contains one integer T, indicating that there are T tests.Each test consists of 3 lines.The first line of each test contains two integers n and m, denoting the length of strings s and t.The second line of each test contains the string s.The third line of each test contains the string t.* 1≤m≤n≤30001 \\le m \\le n \\le 30001≤m≤n≤3000.* sum of n in all tests ≤3000\\le 3000≤3000.* the first character of both s and t aren't '0'. 输出描述:1For each test, output one integer in a line representing the answer modulo 998244353. 示例1 输入复制 1234567891034 21234134 21034134 111112 输出复制 1239611 说明1For the last test, there are 6 subsequences &quot;11&quot;, 4 subsequcnes &quot;111&quot; and 1 subsequence &quot;1111&quot; that are valid, so the answer is 11. 题解： 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;list&gt;#include&lt;cstring&gt;using namespace std;#define int long long#define ll long long#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)const int maxn = 3100;const int mod = 998244353;int dp[maxn][maxn][3];int t, n, m;int a[maxn], b[maxn]; int pow_mod(int a, int b, int c) { int ans = 1; int base = a % c; while (b) { if (b &amp; 1) ans = (ans * base) % c; base = (base * base) % c; b &gt;&gt;= 1; } return ans;}long long solve() { long long ans = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt; m; ++j) for (int k = 0; k &lt;= 2; ++k) dp[i][j][k] = dp[i - 1][j][k]% mod; for (int j = 1; j &lt;= min(m, i); ++j) { if (j == 1 &amp;&amp; a[i] == 0)continue; dp[i][j][0] += (a[i] == b[j] ? dp[i - 1][j - 1][0] : 0); dp[i][j][1] += (a[i] &gt; b[j] ? dp[i - 1][j - 1][0] + dp[i - 1][j - 1][1] : 0); dp[i][j][1] += (a[i] &lt;= b[j] ? dp[i - 1][j - 1][1] : 0); dp[i][j][2] += (a[i] &lt; b[j] ? dp[i - 1][j - 1][0] + dp[i - 1][j - 1][2] : 0); dp[i][j][2] += (a[i] &gt;= b[j] ? dp[i - 1][j - 1][2] : 0); dp[i][j][0]%=mod,dp[i][j][1]%=mod,dp[i][j][2]%=mod; } ans += dp[i][m][1] * ((pow_mod(2, n - i,mod) - 1) % mod) % mod; ans%=mod; ans += dp[i][m][0] * ((pow_mod(2, n - i, mod) - 1) % mod) % mod; ans%=mod; ans += dp[i][m][2] * ((pow_mod(2, n - i, mod) - 1) % mod) % mod; ans%=mod; ans += dp[i][m][1]; ans%=mod; } return ans%mod;}signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin &gt;&gt; t; while (t--) { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) { char tmp; cin &gt;&gt; tmp; a[i] = signed(tmp - '0'); } for (int i = 1; i &lt;= m; ++i) { char tmp; cin &gt;&gt; tmp; b[i] = signed(tmp - '0'); } for(int i=0;i&lt;=n;++i) for(int j=0;j&lt;=m;++j) dp[i][j][0]=dp[i][j][1]=dp[i][j][2]=0; for (int i = 0; i &lt;= n; ++i) dp[i][0][0] = 1; //cerr &lt;&lt; \"debug \" &lt;&lt; endl; cout &lt;&lt; solve()%mod &lt;&lt; endl; } return 0;} 标程：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;const int MAX_N = 3005;const int MOD = 998244353;int n, m;char s[MAX_N], t[MAX_N];long long C[MAX_N][MAX_N];void ADD(long long &amp;x, long long v) { x += v; if(x &gt;= MOD) x -= MOD;}void pre() { for(int i = 0;i &lt; MAX_N; i++) { C[i][0] = 1; for(int j = 1;j &lt;= i; j++) { C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; if(C[i][j] &gt;= MOD) C[i][j] -= MOD; } }}long long dp[MAX_N][MAX_N];void solve(){ long long an = 0; for(int i = n - 1; i &gt;= 0; i--) { if(s[i] != '0') { for(int j = m; j &lt;= n - i - 1; j++) { ADD(an, C[n - i - 1][j]); } } } for(int j = 0; j &lt;= n; j++) { for(int i = 0; i &lt;= m; i++) { dp[j][i] = 0; } } for(int i = m - 1; i &gt;= 0; i--) { for(int j = n - 1; j &gt;= 0; j--) { ADD(dp[j][i], dp[j + 1][i]); if(s[j] &gt; t[i]) { ADD(dp[j][i], C[n - j - 1][m - i - 1]); } else if(s[j] == t[i]) { ADD(dp[j][i], dp[j + 1][i + 1]); } } } ADD(an, dp[0][0]); printf(\"%lld\\n\", an);}int main() { pre(); int T; scanf(\"%d\", &amp;T); while(T--) { scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%s%s\", s, t); solve(); } return 0;}","link":"/2019/08/subsequence-1/"},{"title":"triples I","text":"链接：https://ac.nowcoder.com/acm/contest/884/D来源：牛客网 Doctor Elephant is testing his new program: output the bitwise or of the numbers inputed. He has decided to input several multiples of 3 and the output of the program should be his favorite number aaa. Because he is lazy, he decided to input as few numbers as possible. He wants you to construct such an input for every aaa he chose. It’s guaranteed that for every aaa in the input there is such a solution. If there’re multiple solutions you can output any. 输入描述:There’re multiple test cases in a test file.The first line contains a positive integer TTT - the number of test cases.In each of the following TTT lines there is one positive integer aaa. 输出描述:For each test case output a line. First you need to output the number of numbers in your input, and then you need to output these numbers, separating by spaces. 示例1 输入复制 123237 输出复制 121 32 3 6 说明13=3, (3|6)=7 备注:11≤T≤1051 \\leq T \\leq 10^51≤T≤105, 1≤a≤10181 \\leq a \\leq 10^{18}1≤a≤1018. 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define int long longint t;ll q;ll oddv[1000], evenv[1000];inline void solve(ll cur) { int odd = 0, even = 0; ll tmp = cur; ll emm = 1; int pos = 0; while (cur) { if(cur&amp;1) if (pos &amp; 1) oddv[++odd] = emm; else evenv[++even] = emm; cur /= 2; emm *= 2; pos ^= 1; } /*cerr &lt;&lt; \"debug \" &lt;&lt; odd &lt;&lt; \" \" &lt;&lt; even &lt;&lt; endl; for (int i = 1; i &lt;= odd;++i)cerr &lt;&lt; oddv[i] &lt;&lt; \" \";; cout &lt;&lt; endl; for (int i = 1; i &lt;= even;++i)cerr &lt;&lt; evenv[i] &lt;&lt; \" \";; cout &lt;&lt; endl;*/ ll ans = 0; cout &lt;&lt; ((odd == even || (max(odd, even) - min(odd, even)) % 3 == 0) ? 1 : 2) &lt;&lt; \" \"; int r1 = odd, r2 = even; odd = 1, even = 1; while (odd &lt;= r1 &amp;&amp; even &lt;= r2) ans += oddv[odd++] + evenv[even++]; while (odd + 2 &lt;= r1) { ans += oddv[odd] + oddv[odd + 1] + oddv[odd + 2]; odd += 3; } while (even + 2 &lt;= r2) { ans += evenv[even] + evenv[even + 1] + evenv[even + 2]; even += 3; } cout &lt;&lt; ans &lt;&lt; \" \"; if (odd &lt;= r1) { ll curans = 0; int aaa=odd; while (odd &lt;= r1)curans += oddv[odd++]; int m; if (curans % 3 == 1) { if (aaa &gt;= 2)m = oddv[1]; else m = evenv[1] + evenv[2]; } else { if (aaa &gt;= 3)m = oddv[1]+oddv[2]; else m = evenv[1]; } cout &lt;&lt; curans+m &lt;&lt; endl; } else if (even &lt;= r2) { ll curans = 0; int aaa = even; while (even &lt;= r2)curans += evenv[even++]; int m; if (curans % 3 == 1) { if (r1 &gt;= 1)m = oddv[1]; else m = evenv[1] + evenv[2]; } else { if (r1&gt;=2)m = oddv[1] + oddv[2]; else m = evenv[1]; } cout &lt;&lt; curans+m &lt;&lt; endl; } else cout &lt;&lt; endl;}signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin &gt;&gt; t; while (t--) { cin &gt;&gt; q; if (q % 3 == 0)cout &lt;&lt; 1 &lt;&lt; \" \" &lt;&lt; q &lt;&lt; endl; else solve(q); } return 0;}","link":"/2019/07/triples-I/"},{"title":"tyvj1035","text":"题目限制 时间限制 内存限制 评测方式 题目来源 1000ms 131072KiB 标准比较器 Local 题目描述给出一张nn(n&lt;=100)的国际象棋棋盘，其中被删除了一些点，问可以使用多少12的多米诺骨牌进行掩盖。 输入格式第一行为n，m（表示有m个删除的格子）第二行到m+1行为x,y，分别表示删除格子所在的位置x为第x行y为第y列 输出格式一个数，即最大覆盖格数 提示经典问题 样例数据 输入样例 #1 输出样例 #1 8 0 32 Tips：只有二分图才能使用匈牙利算法。普通图改成二分图后可以使用匈牙利算法 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define sz sizeconst int maxn=110;int mp[maxn][maxn],n,m,x,y,vis[maxn*maxn],matching[maxn*maxn];vector&lt;int&gt;G[maxn*maxn];int dfs(int rot){ for(int i=0;i&lt;G[rot].size();++i) { if(!vis[G[rot][i]]) { vis[G[rot][i]]=true; if(!matching[G[rot][i]]||dfs(matching[G[rot][i]])) { matching[G[rot][i]]=rot; return true; } } } return false;}int match(){ int ans=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) { if((i+j)&amp;1){ memset(vis,0,sizeof(vis)); if(dfs((i-1)*n+j))ans++; } } return ans;}signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) mp[i][j]=1; for(int i=1;i&lt;=m;++i){ cin&gt;&gt;x&gt;&gt;y; mp[x][y]=0; } for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) { if(!mp[i][j])continue; if(mp[i][j+1]){ G[(i-1)*n+j].push_back((i-1)*n+j+1); G[(i-1)*n+j+1].push_back((i-1)*n+j); } if(mp[i+1][j]){ G[(i-1)*n+j].push_back(i*n+j); G[i*n+j].push_back((i-1)*n+j); } } cout&lt;&lt;match()&lt;&lt;endl; return 0;}","link":"/2019/08/tyvj1035/"},{"title":"xv6 shell理解","text":"参考：Implement a Shell by yourself – MIT xv6 shell(转载) 看了几天的xv6​的shell作业，总算看懂一点点，感觉看懂别人的代码比自己写代码还难。 由于我本身太菜了，理解可能有诸多偏差，希望各位不吝赐教。 首先发现了两个不符合我的以往观念的东西： 函数和结构体可以具有相同的名称 未分配内存的指针，可以在调用解引用运算符后调用sizeof函数 真是奇怪啊 讲述一下我对xv6代码的大体框架的认识： shell的main主函数是一个不断读取指令的循环，当需要执行指令时，fork一个子进程去执行。 123456789101112131415161718192021intmain(void){ static char buf[100]; int fd, r; // Read and run input commands. while(getcmd(buf, sizeof(buf)) &gt;= 0){ if(buf[0] == 'c' &amp;&amp; buf[1] == 'd' &amp;&amp; buf[2] == ' '){ // Clumsy but will have to do for now. // Chdir has no effect on the parent if run in the child. buf[strlen(buf)-1] = 0; // chop \\n if(chdir(buf+3) &lt; 0) fprintf(stderr, \"cannot cd %s\\n\", buf+3); continue; } if(fork1() == 0) runcmd(parsecmd(buf)); wait(&amp;r); } exit(0);} 接下来看一下几种类型的指令： 123456789101112131415161718192021222324// All commands have at least a type. Have looked at the type, the code// typically casts the *cmd to some specific cmd type.struct cmd { int type; // ' ' (exec), | (pipe), '&lt;' or '&gt;' for redirection};struct execcmd { int type; // ' ' char *argv[MAXARGS]; // arguments to the command to be exec-ed};struct redircmd { int type; // &lt; or &gt; struct cmd *cmd; // the command to be run (e.g., an execcmd) char *file; // the input/output file int mode; // the mode to open the file with int fd; // the file descriptor number to use for the file};struct pipecmd { int type; // | struct cmd *left; // left side of pipe struct cmd *right; // right side of pipe}; cmd的基类是struct cmd结构体，然后派生出三个类，exec，redirc和pipe。分别对应要执行的指令，文件重定位的指令和管道指令（我也不知道这么叫对不对，但是大体意思是这样的）。基类和派生类的相互转换给我们的代码实现带来了很大的便利。 一个很重要的关键点是，exec结构体和pipe结构体里面有指向cmd结构体的指针，这就让我们可以去构建一棵进程树，然后我们可以根据这棵树去调用执行进程，事实上我们也确实是这么做的。 看主函数里面的 123if(fork1() == 0) runcmd(parsecmd(buf)); wait(&amp;r); parsecmd(buf)实际上就是分析我们输入的指令，构造一棵进程树的代码。返回的是根节点，而runcmd，则是递归的去调用执行这棵树的叶子节点的进程。（事实上叶子节点是进程，而任何一个不是叶子节点的点都代表一种关系，例如输入输出关系，| ） 管道符号的实现机制是：输入输出流重定向。进程之间利用管道通信，将进程的输入流或者输出流重定向到管道，隐藏了上层的不同（进程实际并不知道它的输出指向哪里），为实现提供了便利。 文件重定向也是将进程的输入或输出流重定向到文件。 分析输入指令的大体流程貌似是这样的，首先将指令按照 | （管道）符号分隔开，构建一颗不完整的树。然后再去分析无管道符号的指令的内部结构。如果里面有文件重定向，再慢慢在树上构建出他们的输入输出关系。 123456789101112131415161718192021222324struct cmd*pipecmd(struct cmd *left, struct cmd *right){ struct pipecmd *cmd; cmd = malloc(sizeof(*cmd)); memset(cmd, 0, sizeof(*cmd)); cmd-&gt;type = '|'; cmd-&gt;left = left; cmd-&gt;right = right; return (struct cmd*)cmd;}struct cmd*parsepipe(char **ps, char *es){ struct cmd *cmd; cmd = parseexec(ps, es); if(peek(ps, es, \"|\")){ gettoken(ps, es, 0, 0); cmd = pipecmd(cmd, parsepipe(ps, es)); } return cmd;} parsepipe是一个递归函数，pipecmd是链接两颗进程树。而parseexec大概就是分析没有管道符号的进程关系的函数。（里面细节太多，看得我头皮发麻，读不懂。但是我猜测大体程序结构是这样的） 12345678910111213141516171819202122232425262728293031struct cmd*parseexec(char **ps, char *es){ char *q, *eq; int tok, argc; struct execcmd *cmd; struct cmd *ret; ret = execcmd(); cmd = (struct execcmd*)ret; argc = 0; ret = parseredirs(ret, ps, es); while(!peek(ps, es, \"|\")){ if((tok=gettoken(ps, es, &amp;q, &amp;eq)) == 0) break; if(tok != 'a') { fprintf(stderr, \"syntax error\\n\"); exit(-1); } cmd-&gt;argv[argc] = mkcopy(q, eq); argc++; if(argc &gt;= MAXARGS) { fprintf(stderr, \"too many args\\n\"); exit(-1); } ret = parseredirs(ret, ps, es); } cmd-&gt;argv[argc] = 0; return ret;} parseexe是分析里面的文件重定向并扣出里面运行参数的代码。while循环的意思大概是防止parseexec函数处理越界，因为它是不负责处理带管道符号的指令的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct cmd*redircmd(struct cmd *subcmd, char *file, int type){ struct redircmd *cmd; cmd = malloc(sizeof(*cmd)); memset(cmd, 0, sizeof(*cmd)); cmd-&gt;type = type; cmd-&gt;cmd = subcmd; cmd-&gt;file = file; cmd-&gt;mode = (type == '&lt;') ? O_RDONLY : O_WRONLY|O_CREAT|O_TRUNC; cmd-&gt;fd = (type == '&lt;') ? 0 : 1; return (struct cmd*)cmd;}char *mkcopy(char *s, char *es){ int n = es - s; char *c = malloc(n+1); assert(c); strncpy(c, s, n); c[n] = 0; return c;}struct cmd*parseredirs(struct cmd *cmd, char **ps, char *es){ int tok; char *q, *eq; while(peek(ps, es, \"&lt;&gt;\")){ tok = gettoken(ps, es, 0, 0); if(gettoken(ps, es, &amp;q, &amp;eq) != 'a') { fprintf(stderr, \"missing file for redirection\\n\"); exit(-1); } switch(tok){ case '&lt;': cmd = redircmd(cmd, mkcopy(q, eq), '&lt;'); break; case '&gt;': cmd = redircmd(cmd, mkcopy(q, eq), '&gt;'); break; } } return cmd;} 这个函数负责处理里面的文件重定向，因为里面可能存在多个重定向符号，所以采用了while循环来处理 。rideccmd是构建具体的文件进程命令。（里面细节真的好多啊） 细节看得我头皮发麻。最后附上sh.c的完整代码（大佬写完作业的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386/* * 函数和结构体可以具有相同的名称 * 未分配内存的指针，可以在调用解引用运算符后调用sizeof函数 */#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;// Simplifed xv6 shell.#define MAXARGS 10// All commands have at least a type. Have looked at the type, the code// typically casts the *cmd to some specific cmd type.struct cmd { int type; // ' ' (exec), | (pipe), '&lt;' or '&gt;' for redirection};struct execcmd { int type; // ' ' char *argv[MAXARGS]; // arguments to the command to be exec-ed};struct redircmd { int type; // &lt; or &gt; struct cmd *cmd; // the command to be run (e.g., an execcmd) char *file; // the input/output file int mode; // the mode to open the file with int fd; // the file descriptor number to use for the file};struct pipecmd { int type; // | struct cmd *left; // left side of pipe struct cmd *right; // right side of pipe};int fork1(void); // Fork but exits on failure.struct cmd *parsecmd(char*);// Execute cmd. Never returns.voidruncmd(struct cmd *cmd){ int p[2]; // used for pipe line in shell int r; // return value struct execcmd *ecmd; struct pipecmd *pcmd; struct redircmd *rcmd; if(cmd == 0) exit(0); switch(cmd-&gt;type){ default: fprintf(stderr, \"unknown runcmd\\n\"); exit(-1); case ' ': ecmd = (struct execcmd*)cmd; if(ecmd-&gt;argv[0] == 0) exit(0); //fprintf(stderr, \"exec not implemented\\n\"); // Your code here ... if (access(ecmd-&gt;argv[0], S_IXUSR | S_IRUSR) == 0) { execv(ecmd-&gt;argv[0], ecmd-&gt;argv); } else { printf(\"directory changed \\n\"); if(chdir(\"/bin/\") &lt; 0) { printf(\"change directory failed in line %d\\n\", __LINE__); exit(0); } execv(ecmd-&gt;argv[0], ecmd-&gt;argv); } fprintf(stderr, \"execv() %s failed in line %d\\n\", ecmd-&gt;argv[0], __LINE__); break; case '&gt;': case '&lt;': rcmd = (struct redircmd*)cmd; //fprintf(stderr, \"redir not implemented\\n\"); // Your code here ... close(rcmd-&gt;fd); if(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; 0) { fprintf(stderr, \"Try to open :%s failed\\n\", rcmd-&gt;file); exit(0); } runcmd(rcmd-&gt;cmd); break; case '|': pcmd = (struct pipecmd*)cmd; //fprintf(stderr, \"pipe not implemented\\n\"); // Your code here ... if(pipe(p) &lt; 0) { fprintf(stderr, \"call syscall pipe() failed in line %d\\n\", __LINE__); exit(0); } if(fork1() == 0) { close(1); dup(p[1]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); } if(fork1() == 0) { close(0); dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); } close(p[0]); close(p[1]); wait(); wait(); break; } exit(0);}intgetcmd(char *buf, int nbuf){ //isatty:判断文件描述词是否为终端机 //fileno:取得参数指定的文件流的文件描述符 if (isatty(fileno(stdin))) fprintf(stdout, \"6.828$ \"); memset(buf, 0, nbuf); fgets(buf, nbuf, stdin); if(buf[0] == 0) // EOF return -1; return 0;}intmain(void){ static char buf[100]; int fd, r; // Read and run input commands. while(getcmd(buf, sizeof(buf)) &gt;= 0){ if(buf[0] == 'c' &amp;&amp; buf[1] == 'd' &amp;&amp; buf[2] == ' '){ // Clumsy but will have to do for now. // Chdir has no effect on the parent if run in the child. buf[strlen(buf)-1] = 0; // chop \\n if(chdir(buf+3) &lt; 0) fprintf(stderr, \"cannot cd %s\\n\", buf+3); continue; } if(fork1() == 0) runcmd(parsecmd(buf)); wait(&amp;r); } exit(0);}intfork1(void){ int pid; pid = fork(); if(pid == -1) perror(\"fork\"); return pid;}struct cmd*execcmd(void){ struct execcmd *cmd; cmd = malloc(sizeof(*cmd)); memset(cmd, 0, sizeof(*cmd)); cmd-&gt;type = ' '; return (struct cmd*)cmd;}struct cmd*redircmd(struct cmd *subcmd, char *file, int type){ struct redircmd *cmd; cmd = malloc(sizeof(*cmd)); memset(cmd, 0, sizeof(*cmd)); cmd-&gt;type = type; cmd-&gt;cmd = subcmd; cmd-&gt;file = file; cmd-&gt;mode = (type == '&lt;') ? O_RDONLY : O_WRONLY|O_CREAT|O_TRUNC; cmd-&gt;fd = (type == '&lt;') ? 0 : 1; return (struct cmd*)cmd;}struct cmd*pipecmd(struct cmd *left, struct cmd *right){ struct pipecmd *cmd; cmd = malloc(sizeof(*cmd)); memset(cmd, 0, sizeof(*cmd)); cmd-&gt;type = '|'; cmd-&gt;left = left; cmd-&gt;right = right; return (struct cmd*)cmd;}// Parsingchar whitespace[] = \" \\t\\r\\n\\v\";char symbols[] = \"&lt;|&gt;\";intgettoken(char **ps, char *es, char **q, char **eq){ char *s; int ret; s = *ps; while(s &lt; es &amp;&amp; strchr(whitespace, *s)) s++; if(q) *q = s; ret = *s; switch(*s){ case 0: break; case '|': case '&lt;': s++; break; case '&gt;': s++; break; default: ret = 'a'; while(s &lt; es &amp;&amp; !strchr(whitespace, *s) &amp;&amp; !strchr(symbols, *s)) s++; break; } if(eq) *eq = s; while(s &lt; es &amp;&amp; strchr(whitespace, *s)) s++; *ps = s; return ret;}intpeek(char **ps, char *es, char *toks){ char *s; s = *ps; while(s &lt; es &amp;&amp; strchr(whitespace, *s)) s++; *ps = s; return *s &amp;&amp; strchr(toks, *s);}struct cmd *parseline(char**, char*);struct cmd *parsepipe(char**, char*);struct cmd *parseexec(char**, char*);// make a copy of the characters in the input buffer, starting from s through es.// null-terminate the copy to make it a string.char *mkcopy(char *s, char *es){ int n = es - s; char *c = malloc(n+1); assert(c); strncpy(c, s, n); c[n] = 0; return c;}struct cmd*parsecmd(char *s){ char *es; struct cmd *cmd; es = s + strlen(s); cmd = parseline(&amp;s, es); peek(&amp;s, es, \"\"); if(s != es){ fprintf(stderr, \"leftovers: %s\\n\", s); exit(-1); } return cmd;}struct cmd*parseline(char **ps, char *es){ struct cmd *cmd; cmd = parsepipe(ps, es); return cmd;}struct cmd*parsepipe(char **ps, char *es){ struct cmd *cmd; cmd = parseexec(ps, es); if(peek(ps, es, \"|\")){ gettoken(ps, es, 0, 0); cmd = pipecmd(cmd, parsepipe(ps, es)); } return cmd;}struct cmd*parseredirs(struct cmd *cmd, char **ps, char *es){ int tok; char *q, *eq; while(peek(ps, es, \"&lt;&gt;\")){ tok = gettoken(ps, es, 0, 0); if(gettoken(ps, es, &amp;q, &amp;eq) != 'a') { fprintf(stderr, \"missing file for redirection\\n\"); exit(-1); } switch(tok){ case '&lt;': cmd = redircmd(cmd, mkcopy(q, eq), '&lt;'); break; case '&gt;': cmd = redircmd(cmd, mkcopy(q, eq), '&gt;'); break; } } return cmd;}struct cmd*parseexec(char **ps, char *es){ char *q, *eq; int tok, argc; struct execcmd *cmd; struct cmd *ret; ret = execcmd(); cmd = (struct execcmd*)ret; argc = 0; ret = parseredirs(ret, ps, es); while(!peek(ps, es, \"|\")){ if((tok=gettoken(ps, es, &amp;q, &amp;eq)) == 0) break; if(tok != 'a') { fprintf(stderr, \"syntax error\\n\"); exit(-1); } cmd-&gt;argv[argc] = mkcopy(q, eq); argc++; if(argc &gt;= MAXARGS) { fprintf(stderr, \"too many args\\n\"); exit(-1); } ret = parseredirs(ret, ps, es); } cmd-&gt;argv[argc] = 0; return ret;}","link":"/2019/11/xv6-shell%E7%90%86%E8%A7%A3/"},{"title":"一道树题","text":"一道树题 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int maxn=2e5+10;int vis[maxn],ans,dp[maxn],n,a,b;signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;n; for(int i=1;i&lt;n;++i) { cin&gt;&gt;a&gt;&gt;b; int Min=min(vis[a],vis[b]),Max=max(vis[a],vis[b]); dp[i]=dp[i-1]+i-Max-Min; ans+=dp[i]; vis[a]=i; vis[b]=i; } //cerr&lt;&lt;\"debug \"&lt;&lt;dp[1]&lt;&lt;\" \"&lt;&lt;dp[2]&lt;&lt;\" \"&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2019/07/%E4%B8%80%E9%81%93%E6%A0%91%E9%A2%98/"},{"title":"分组","text":"分组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#define M 200005using namespace std;vector&lt;int&gt;a[M];//链式结构存入数据 int n,m,vis[M],col[M];//vis为标记数组，col为0或1两个组的记录值 void dfs(int x){ int cent=0; for(int i=0;i&lt;a[x].size();i++)//遍历x全部认识的人 { if(!vis[a[x][i]]) { vis[a[x][i]]=1; col[a[x][i]]=!col[x];//将x认识的人分到与之相反的组 dfs(a[x][i]);//往下搜索 } if(col[a[x][i]]==col[x])//1. cent++; } if(cent&gt;=2)//2. col[x]=!col[x]; //1和2是为了防止出现x认识的人都已经赋值了并且还是同一组超过1个，所以要将x分到另一组，递归往上更新 }int main(){ scanf(\"%d%d\",&amp;n,&amp;m); memset(vis,0,sizeof(vis)); memset(col,0,sizeof(col)); for(int i=0;i&lt;m;i++)//链表结构存入a数组 { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); a[x].push_back(y); a[y].push_back(x); } for(int i=1;i&lt;=n;i++)//对没个点访问边，防止漏搜了 dfs(i); for(int i=1;i&lt;=n;i++) printf(\"%d \",col[i]+1); printf(\"\\n\"); return 0; }","link":"/2019/10/%E5%88%86%E7%BB%84/"},{"title":"双倍快乐","text":"双倍快乐 题目描述 Illyasviel：”你想要最长不下降子序列吗？” star-dust：”好啊！” Illyasviel：”老板，给我整两个最长不下降子序列，要最大的。” 求序列 aa 中的两个不相交的不下降子序列使得他们的元素和的和最大，子序列可以为空。 注 1：序列 aa 不下降的定义是不存在 l&lt;rl&lt;r 且 a_l&gt;a_ra**l&gt;a**r 注 2：两个子序列不相交的定义是：不存在 a_ia**i 即在第一个子序列中也在第二个子序列中。 输入描述 第一行一个数字 nn 代表序列 aa 的长度。 接下来一行 nn 个数，第 ii 个数代表 a_ia*i*。 数据范围： 2 \\le n \\le 5002≤n≤500 1\\leq a_i \\leq 10^51≤a*i*≤105 输出描述 一行一个整数代表两个不相交的不下降子序列的元素和的最大值。 样例输入 1 1295 3 2 1 4 2 1 4 6 样例输出 1 122 提示 样例解释： 第一个序列选了 “5” 第二个序列选了 “3 4 4 6” 总和为 2222。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define inf 0x3f3f3f3fusing namespace std;int n,m,i,j,k,l,x,y;int cnt;int ans;using namespace std;const int maxn = 1e3+12;int dp[maxn][maxn],a[maxn];int main(){ cin&gt;&gt;n; for(i=1; i&lt;=n; ++i) cin&gt;&gt;a[i]; ans=0; memset(dp,0,sizeof(dp)); for(k=1; k&lt;=n; ++k) { for(i=0; i&lt;k; ++i) { for(j=0; j&lt;k; ++j) { if(a[k]&gt;=a[i]) dp[k][j]=max(dp[k][j],dp[i][j]+a[k]); if(a[k]&gt;=a[j]) dp[i][k]=max(dp[i][k],dp[i][j]+a[k]); ans=max(ans,dp[k][j]); } } } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2019/07/%E5%8F%8C%E5%80%8D%E5%BF%AB%E4%B9%90/"},{"title":"字典序","text":"字典序我们容易想到一个n^3的贪心：每次找到最小的可以放进来的第j列，同时记录当前连续的依然相等的行。第j列可以放进来的条件为：对于当前每一个依然相等的连续行(i,i+1)(i,i+1)(i,i+1)，有C[i][j]&lt;=C[i+1][j]C[i][j] &lt;= C[i+1][j]C[i][j]&lt;=C[i+1][j]。一共要找m次列，每次找列是枚举m个列，而检查列是否符合条件需要检查当前所有依然相等的连续行，最差情况下要检查n次。总的复杂度O(m2n)O(m^2n)O(m2 n)，肯定是不行的。考虑优化其中的一个步骤。 想到优化检查这一步，不是暴力检查，而是用cnt[j]cnt[j]cnt[j]记录第jjj列有多少行满足（C[i][j]&gt;C[i+1][j]）（C[i][j] &gt; C[i+1][j]）（C[i][j]&gt;C[i+1][j]）。如果为0，则表示这一列可以加入。这样把检查优化到了O(1)，但是每一次加入一列之后要去更新其他没加入的列的cntcntcnt。什么情况下一列的cnt会减少？也就是什么情况下对于还没放入的第j列，(C[i][j]&gt;C[i+1][j])(C[i][j] &gt; C[i+1][j])(C[i][j]&gt;C[i+1][j])的影响被消除？只要前面放入的列中，有一列k满足(C[i][k]&lt;C[i+1][k])(C[i][k]&lt;C[i+1][k])(C[i][k]&lt;C[i+1][k]),那么(C[i][j]&gt;C[i+1][j])(C[i][j] &gt; C[i+1][j])(C[i][j]&gt;C[i+1][j])对于第j列的影响就被消除了。记录当前依然相等的连续行，加入新的一列j时，如果第j列可以把某连续行(i,i+1)分开（也就是C[i][j]&lt;C[i+1][j])，那么就更新剩余列的cnt。因为只更新连续行，最多更新n次（一共就n行，每更新一次最少会少1个连续行），更新一次的复杂度是O(m)。总的复杂度为O(m2+nm)O(m^2+nm)O(m2 +nm)————————————————版权声明：本文为CSDN博主「_ 泛白」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_43202683/article/details/100170570 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int maxn = 2e3 + 50;int n, m;int c[maxn][maxn];int cnt[maxn];// 有多少个不符合条件的int dif[maxn];//dif[i]=1 表示第i行和i+1行已经不相等了int vis[maxn];void init(){ memset(cnt, 0, (m+1)&lt;&lt;2); memset(vis, 0, (m+1)&lt;&lt;2); memset(dif, 0, (n+1)&lt;&lt;2); for(int i = 1; i &lt;= n; ++i){ for(int j = 1; j &lt;= m ;++j){ scanf(\"%d\", &amp;c[i][j]); if(i!=1){ cnt[j] += (c[i-1][j] &gt; c[i][j]); } } }}vector&lt;int&gt; ans;void sol(){ ans.clear(); while(ans.size() &lt; m){ int j; for(j = 1; j &lt;= m; ++j){ if(vis[j] || cnt[j] &gt; 0) continue; break; } if(j &gt; m){//没找到 printf(\"-1\\n\"); return; } ans.push_back(j); vis[j] = 1; for(int i = 1; i &lt; n; ++i){ if(dif[i]) continue; if(c[i][j] &gt;= c[i+1][j]) continue; dif[i] = 1; for(int k = 1; k &lt;= m; ++k){ if(c[i][k] &gt; c[i+1][k]) cnt[k]--; } } } for(int i = 0; i &lt; ans.size(); ++i){ if(i &gt; 0) printf(\" \"); printf(\"%d\", ans[i]); }printf(\"\\n\");}int main(){ while(scanf(\"%d%d\", &amp;n, &amp;m)!=EOF){ init();sol(); }}","link":"/2019/10/%E5%AD%97%E5%85%B8%E5%BA%8F/"},{"title":"小doge的快乐阳光跑","text":"小doge的快乐阳光跑作者：四糸智乃https://www.nowcoder.com/discuss/287870?type=all&amp;order=time&amp;pos=&amp;page=1来源：牛客网 10pts 使用了floyd求最短路emmm….除非n&lt;=300，不然还是别轻易用floyd了。 特殊测试点信息： 对于测试点1,4,5，只要最短路求的是对的即可AC，如果这几个测试点通过而其他WA掉考虑是DP部分写错了。 对于测试点2,3。可以枚举路过序列的全排（dfs一下）瞎搞搞。 对于测试点6,7,10，这三个点的答案大于1e9，请注意是否使用long long或者inf是否足够大。 对于测试点6，是可以枚举一下在哪里拐弯来特判掉的。 100pts 首先肯定要预处理一波最短路，由于图是相对比较稀疏的稀疏图，所以其实spfa或者dij区别不太大（n太小了，故意卡spfa效果并不好）但是注意一下啊，现在spfa人人喊打，尽量少用或者别用。 对于a和b中的点，预处理这些点为起点的最短路。 然后接下来就是一个非常简单的dp，dp[i][j][01]表示已经完成了第一个人的i个点位和第二个人的第j个点位，低三个维度的0表示最后停在了第一个人的点位，1表示最后停在了第二个人的点位。 然后转移方程如下： dp[i + 1][j][0] = min(dp[i + 1][j][0], dp[i][j][0] + dis[a][i][a[i + 1]]); dp[i + 1][j][0] = min(dp[i + 1][j][0], dp[i][j][1] + dis[b[j]][a[i + 1]]); dp[i][j + 1][1] = min(dp[i][j + 1][1], dp[i][j][1] + dis[b[j]][b[j + 1]]); dp[i][j + 1][1] = min(dp[i][j + 1][1], dp[i][j][0] + dis[a[i]][b[j + 1]]); Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * author: MySakure * created: 27.09.2019 18:42:04 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long#define int long longconst int maxn=1e3+5;const int inf=1e18;int self[maxn];struct Edge{ int from,to,dist; Edge(int u,int v,int d):from(u),to(v),dist(d){}};struct HeapNode{ int d,u; bool operator &lt; (const HeapNode&amp; rhs)const{ return rhs.d&lt;d; }};int d[maxn][maxn];int dp[110][110][2];int a,sa[110],b,sb[110];struct Dijkstra{ int n,m; vector&lt;Edge&gt;edges; vector&lt;int&gt;G[maxn]; bool flag[maxn]; //注意结构体内部开数组内存不能太大 //此时将int改为ll会出现内存过大的问题 void init(int n){ this-&gt;n=n; for(int i=0;i&lt;n;i++)G[i].clear(); edges.clear(); } void AddEgde(int from,int to,int dist){ edges.push_back(Edge(from,to,dist)); m=edges.size(); G[from].push_back(m-1); } void dijkstra(int s){ priority_queue&lt;HeapNode&gt;Q; for(int i=0;i&lt;=n;i++)d[s][i]=inf; d[s][s]=0; memset(flag,0,sizeof(flag)); Q.push((HeapNode){0,s}); while(!Q.empty()){ HeapNode x=Q.top();Q.pop(); int u=x.u; if(flag[u])continue; flag[u]=1; for(int i=0;i&lt;signed(G[u].size());i++){ Edge&amp; e=edges[G[u][i]]; if(d[s][e.to]&gt;d[s][u]+e.dist){ d[s][e.to]=d[s][u]+e.dist; Q.push((HeapNode){d[s][e.to],e.to}); } } } }};Dijkstra dij;int getdis(int x,int y){ //if(x==y)return self[x]; if(x==0||y==0)return inf; if(d[x][y]||d[y][x])return d[x][y]?d[x][y]:d[y][x]; dij.dijkstra(x); return d[x][y];}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); int n,m; cin&gt;&gt;n&gt;&gt;m; dij.n=n; rep(i,1,m){ int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; dij.AddEgde(u,v,w); dij.AddEgde(v,u,w); } cin&gt;&gt;a; rep(i,1,a)cin&gt;&gt;sa[i]; cin&gt;&gt;b; rep(i,1,b)cin&gt;&gt;sb[i]; rep(i,0,a) rep(j,0,b) dp[i][j][0]=dp[i][j][1]=inf; if(a)dp[1][0][0]=0; if(b)dp[0][1][1]=0; rep(i,0,a){ rep(j,0,b){ if(a==0&amp;&amp;b==0)continue; //if(sa[i]==sb[j]&amp;&amp;i)dp[i][j][1]=dp[i][j][0]=dp[i-1][j][1]; if(sa[i]==sb[j]){ dp[i][j][0]=min(dp[i][j][0],dp[i-1][j][1]); dp[i][j][0]=min(dp[i][j][0],dp[i][j-1][0]); dp[i][j][0]=min(dp[i][j][1],dp[i][j][0]); dp[i][j][1]=dp[i][j][0]; } if(i){ dp[i][j][0]=min(dp[i][j][0],dp[i-1][j][1]+getdis(sb[j],sa[i])); dp[i][j][0]=min(dp[i][j][0],dp[i-1][j][0]+getdis(sa[i-1],sa[i])); } if(j){ dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][1]+getdis(sb[j],sb[j-1])); dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][0]+getdis(sa[i],sb[j])); } } } cout&lt;&lt;min(dp[a][b][0],dp[a][b][1])&lt;&lt;endl; return 0;}","link":"/2019/09/%E5%B0%8Fdoge%E7%9A%84%E5%BF%AB%E4%B9%90%E9%98%B3%E5%85%89%E8%B7%91/"},{"title":"小w的进制转换","text":"小w的进制转换作者：四糸智乃https://www.nowcoder.com/discuss/287870?type=all&amp;order=time&amp;pos=&amp;page=1来源：牛客网 题意：问从1到n有多少个数字在二进制表示下是“反对称01串”，反对称意为对称相反。 10pts 能过样例就是10pts 30pts 写了个大暴力，每次输入n都暴力求 60pts 暴力打了一张1~100000的表，预处理输入直接输出 100pts 显然的是，如果一个数字二进制表示的字符串长度为奇数，一定不符合条件。 我们观察一下前几个符合条件的数字，既然题目与二进制有关，不妨换个视角 10 1010 1100 100110 101010 110100 111000 看出来了嘛？没看出来，没关系，我们把这些数字切一半 1 10 11 100 101 110 111 转换成对应的十进制就是1,2,3,4,5,6,7… 其实很好理解，因为“反对称”嘛就如同回文数一样，前半决定后半。第k个符合条件的数在二进制表示下就是KK’，K表示k的二进制表示字符串,K’为反对称串，可以用位运算O(1)构造。有个这个性质之后，你既可以找规律统计，又可以二分一个最大的k使得KK’小于给定的n，则此时的k就为答案。 std使用的是直接按位构造的方式。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * author: MySakure * created: 27.09.2019 18:04:44 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long long#define ull long longint t;ull n;int get(ull n){ int inx=0; while(n){ ++inx; n/=2; } return inx;}signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;t; while(t--){ cin&gt;&gt;n; int inx=get(n); ll ans=(1ll&lt;&lt;(inx/2))-1; if(inx&amp;1){ cout&lt;&lt;ans&lt;&lt;endl; continue; } ans=n/(1ll&lt;&lt;(inx/2)); ll cur=0; for(int i=inx/2;i&lt;inx;++i){ if(!(n&amp;(1ll&lt;&lt;i)))cur+=(1ll&lt;&lt;(inx-i-1)); } if(n%(1ll&lt;&lt;(inx/2))&lt;cur)ans--; cout&lt;&lt;ans&lt;&lt;endl; } return 0;}","link":"/2019/09/%E5%B0%8Fw%E7%9A%84%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"},{"title":"徐州网络赛","text":"B. so easy Code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longconst int inf=1e9;const int maxn=1e6+10;int c[maxn],a[maxn];int n,q;vector&lt;int&gt;v;int front[maxn*2],back[maxn*2];struct node{ int l,r; int ans;}t[4*maxn];int getid(int cur){return lower_bound(v.begin(),v.end(),cur)-v.begin()+1;}void build(int u,int l,int r){ t[u].l=l,t[u].r=r; if(l==r){ t[u].ans=l; return; } int mid=(l+r)&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r); t[u].ans=min(t[u&lt;&lt;1].ans,t[u&lt;&lt;1|1].ans);}void update(int u,int inx){ int l=t[u].l,r=t[u].r; if(l==r){ t[u].ans=inf; return; } int mid=(l+r)&gt;&gt;1; if(inx&lt;=mid)update(u&lt;&lt;1,inx); else update(u&lt;&lt;1|1,inx); t[u].ans=min(t[u&lt;&lt;1].ans,t[u&lt;&lt;1|1].ans);}int quare(int u,int L,int R){ int l=t[u].l,r=t[u].r; if(L==l&amp;&amp;R==r)return t[u].ans; int mid=(l+r)&gt;&gt;1; if(L&gt;mid)return quare(u&lt;&lt;1|1,L,R); else if(R&lt;=mid)return quare(u&lt;&lt;1,L,R); else return min(quare(u&lt;&lt;1,L,mid),quare(u&lt;&lt;1|1,mid+1,R));}inline bool scan_d(int &amp;num){ char in;bool IsN=false; in=getchar(); if(in==EOF) return false; while(in!='-'&amp;&amp;(in&lt;'0'||in&gt;'9')) in=getchar(); if(in=='-'){ IsN=true;num=0;} else num=in-'0'; while(in=getchar(),in&gt;='0'&amp;&amp;in&lt;='9'){ num*=10,num+=in-'0'; } if(IsN) num=-num; return true;}signed main(){ scan_d(n); scan_d(q); for(int i=1;i&lt;=q;++i){ scan_d(c[i]); scan_d(a[i]); v.push_back(a[i]); v.push_back(a[i]+1); } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end()); int n=v.size(); build(1,1,n); for(int i=1;i&lt;=q;++i){ if(c[i]==1){ update(1,getid(a[i])); } else { int ans=quare(1,getid(a[i]),n); cout&lt;&lt;(ans==inf?-1:v[ans-1])&lt;&lt;'\\n'; } } return 0;} C. Buy Watermelon12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longint w;signed main(){ ios::sync_with_stdio(NULL); cin.tie(0); cin&gt;&gt;w; if(w&amp;1){ cout&lt;&lt;\"NO\"&lt;&lt;endl; return 0; } for(int i=2;i&lt;w;i+=2){ if((w-i)%2==0){ cout&lt;&lt;\"YES\"&lt;&lt;endl; return 0; } } cout&lt;&lt;\"NO\"&lt;&lt;endl; return 0;} E. XKC’s basketball team1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 5e5 + 10;struct node { int l, r; int Max;}t[maxn&lt;&lt;2];int a[maxn], n, m;void build(int u, int l, int r) { t[u].l = l, t[u].r = r; if (l == r) { t[u].Max = a[l]; return; } int mid = (l + r) &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1|1, mid + 1, r); t[u].Max = max(t[u &lt;&lt; 1].Max, t[u &lt;&lt; 1 | 1].Max);}int quare(int u,int v) { if (t[u].Max &lt; v)return -1; int l = t[u].l, r = t[u].r; if (l == r)return l; if (t[u &lt;&lt; 1 | 1].Max &gt;= v)return quare(u &lt;&lt; 1 | 1, v); else return quare(u &lt;&lt; 1, v);}void update(int u, int inx) { int l = t[u].l, r = t[u].r; if (l == r) { t[u].Max = -1; return; } int mid = (l + r) &gt;&gt; 1; if (inx &lt;= mid)update(u &lt;&lt; 1, inx); else update(u &lt;&lt; 1 | 1, inx);}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; build(1, 1, n); for (int i = 1; i &lt;= n; ++i) { update(1, i); int ans = quare(1, a[i]+m); cout &lt;&lt; (ans==-1?-1:ans-i-1); if (i == n)cout &lt;&lt; endl; else cout &lt;&lt; \" \"; } return 0;} 事实上，这个题当时写复杂了，不需要更新操作可以，简单的判断下就行了 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 5e5 + 10;struct node { int l, r; int Max;}t[maxn&lt;&lt;2];int a[maxn], n, m;void build(int u, int l, int r) { t[u].l = l, t[u].r = r; if (l == r) { t[u].Max = a[l]; return; } int mid = (l + r) &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1|1, mid + 1, r); t[u].Max = max(t[u &lt;&lt; 1].Max, t[u &lt;&lt; 1 | 1].Max);}int quare(int u,int v) { if (t[u].Max &lt; v)return -1; int l = t[u].l, r = t[u].r; if (l == r)return l; if (t[u &lt;&lt; 1 | 1].Max &gt;= v)return quare(u &lt;&lt; 1 | 1, v); else return quare(u &lt;&lt; 1, v);}void update(int u, int inx) { int l = t[u].l, r = t[u].r; if (l == r) { t[u].Max = -1; return; } int mid = (l + r) &gt;&gt; 1; if (inx &lt;= mid)update(u &lt;&lt; 1, inx); else update(u &lt;&lt; 1 | 1, inx);}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; a[0]=2e9; for (int i = 1; i &lt;= n; ++i)cin &gt;&gt; a[i]; build(1, 0, n); for (int i = 1; i &lt;= n; ++i) { //update(1, i); int ans = quare(1, a[i]+m); cout &lt;&lt; (ans&lt;=i?-1:ans-i-1); if (i == n)cout &lt;&lt; endl; else cout &lt;&lt; \" \"; } return 0;} M. Longest subsequence​ Code: 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int maxn = 1e6 + 10;int dp[maxn][30];int n, m;char s[maxn], t[maxn];int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i)cin &gt;&gt; s[i]; for (int j = 1; j &lt;= m; ++j)cin &gt;&gt; t[j]; for (int i = n; i &gt;= 1; --i) { for (int j = 25; j &gt;= 0; --j) dp[i][j] = dp[i + 1][j]; dp[i][s[i] - 'a'] = i; } int ans = -1, inx = 0; for (int i = 1; i &lt;= m; ++i) { for (int j = t[i] - 'a'+1; j &lt;= 25; ++j) { if (dp[inx + 1][j]) { ans = max(ans, i + n - dp[inx + 1][j]); } } inx = dp[inx+1][t[i] - 'a']; //cerr &lt;&lt; \"debug \" &lt;&lt; inx &lt;&lt; endl; if (!inx)break; } if(inx&amp;&amp;n!=inx)ans = max(ans, m + n - inx); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","link":"/2019/09/%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B/"},{"title":"数列","text":"链接：https://ac.nowcoder.com/acm/contest/1083/E来源：牛客网 小乔有一个长度为n的整数数列，最开始里面所有的值都为0，小乔需要将在1…n的每一个位置填入一个大于0的正整数，得到一个新的数列，并且这个数列所有数的和不超过m，小乔对这个数列会有一个喜爱度，小乔对这个数列的喜爱度为满足2&lt;=i&lt;=n并且a[i]=a[i-1]+1的i的个数。现在给出n,m，请你制定一种填数方案，最大化小乔对数列的喜爱度。方案可能有多种，你只需要输出任意一种即可。 输入描述:1第一行两个整数n,m。1&lt;=n&lt;=1e5,n&lt;=m&lt;=1e9。 输出描述:1一行n个整数，表示位置1…n填的数。 示例1 输入复制 15 9 输出复制 11 2 1 2 3 说明1小乔对数列的喜爱度为3，没有能使喜爱度大于3的方案了，此外1 2 3 1 2也是一个合法的方案 思路：","link":"/2019/09/%E6%95%B0%E5%88%97/"},{"title":"树的重心","text":"转载来自https://blog.csdn.net/Ratina/article/details/95967532 树的重心——DFS求解2019年07月15日 15:28:19 更多 定义：树的重心也叫树的质心。对于一棵树n个节点的无根树，找到一个点，使得把树变成以该点为根的有根树时，最大子树的结点数最小。换句话说，删除这个点后最大连通块（一定是树）的结点数最小。 性质： 树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个距离和，他们的距离和一样。 把两棵树通过一条边相连，新的树的重心在原来两棵树重心的连线上。 一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。 一棵树最多有两个重心，且相邻。 重心的求法删除重心后最大连通块的结点数最小，那么就要对每个结点，以其为根，找出其所有子树的最大结点数，然后找出 子树最大结点数最小的那个结点，即是重心。 那么怎么一次DFS在O(N)的时间就找出重心呢？ 随意选择一个根结点，进行DFS，对于 某个结点u ，每次向下遍历，可以得出 u向下遍历的各个子树的结点数 ，但是如果以u作为根结点话，还有 一颗向上遍历的子树结点数 没有考虑，但是可以发现 这棵向上遍历的子树的结点数= N - 向下遍历的各子树结点数之和 -1 具体实现： 123456789101112131415161718192021222324int min_balance=INF; //删除重心后最大连通块的数量int min_node; //重心int dfs(int u) //dfs每次返回以u为根的子树的结点数量{ vis[u]=true; int sum=0; //向下遍历的各子树结点数之和 int max_subtree=0; //最大子树结点数 for(int i=head[u];i!=-1;i=e[i].next) //向下遍历 { int v=e[i].v; if(vis[v]) continue; int t=dfs(v); //得到以v为根结点的子树的结点数 sum+=t; max_subtree=max(max_subtree,t); } max_subtree=max(max_subtree,N-sum-1); //考虑向上遍历的子树的结点数 if(max_subtree&lt;min_balance) //更新重心 { min_balance=max_subtree; min_node=u; } return sum+1; //+1为结点u本身}","link":"/2019/08/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"title":"烹饪","text":"烹饪看这道题想到了需要选一些数满足他们的gcd等于1这件事，但是不会求，没想到答案用动态规划求 的 题解： 作者：codesonichttps://ac.nowcoder.com/discuss/259271?type=101&amp;order=time&amp;pos=&amp;page=1来源：牛客网 介绍一个与 gcd 有关的一个定理，裴蜀定理，内容就是：形如ax+by=cax+by=cax+by=c的不定方程有解的条件就是gcd⁡(a,b)∣c\\gcd(a, b)\\mid cgcd(a,b)∣c。 这个定理推广到任意多个未知数也是成立的。 考虑题目求的是什么 挑选出 mmm 种 食材(1≤m≤n)(1\\le m\\le n)(1≤m≤n)，让他们能够组合出任意正整数的美味值。 其实就是一个 a1×x1+a2×x2+…+am×xm=a_1\\times x_1 + a_2 \\times x_2 + \\ldots + a_m \\times x_m =a1×x1+a2×x2+…+am×xm= 任意正整数的不定方程！ 任意正整数都有的 gcd 是 1。 所以这个问题就变成了挑选若干个数，让他们的 gcd 为 1。 这个问题可以用 dpdpdp 来解决。 设 f[i][j]f[i][j]f[i][j] 表示前 iii 个数的 gcd 为 jjj 的方案数。 不难推出转移方程： $f[i][gcd⁡(j,a[i])]=f[i−1][gcd⁡(j,a[i])]+f[i−1][j]$ 最终 f[n][1] 就是答案。 12345678910111213141516171819202122232425262728/** * author: MySakure * created: 17.09.2019 15:36:57 **/#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define ll long longint dp[3010][2010];int a[3010],n;const int mod=998244353;signed main() { ios::sync_with_stdio(false); cin.tie(NULL); cin&gt;&gt;n; rep(i,1,n)cin&gt;&gt;a[i]; rep(i,1,n){ rep(j,1,2000)dp[i][j]=dp[i-1][j]%mod; dp[i][a[i]]++; rep(j,1,2000)(dp[i][__gcd(j,a[i])]+=dp[i-1][j])%=mod; } cout&lt;&lt;dp[n][1]&lt;&lt;endl; return 0;}","link":"/2019/09/%E7%83%B9%E9%A5%AA/"},{"title":"矩阵","text":"链接：https://ac.nowcoder.com/acm/contest/131/B?&amp;headNav=www&amp;headNav=acm来源：牛客网 时间限制：C/C++ 4秒，其他语言8秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述矩阵 M 包含 R 行 C 列，第 i 行第 j 列的值为 Mi,j。 请寻找一个子矩阵，使得这个子矩阵的和最大，且满足以下三个条件： 子矩阵的行数不能超过 X 行。 子矩阵的列数不能超过 Y 列。 子矩阵中 0 的个数不能超过 Z 个。 请输出满足以上条件的最大子矩阵和。 输入描述:1第一行输入五个整数 R，C，X，Y，Z。接下来 N 行，每行输入 M 个整数，第 i 行第 j 列的整数表示 Mi,j。1 ≤ R,C ≤ 500.1 ≤ X ≤ R.1 ≤ Y ≤ C.1 ≤ Z ≤ R x C.-109 ≤ Mi,j ≤ 109 输出描述:1输出满足以上条件的最大子矩阵和。 示例1 输入复制 1234565 5 3 3 40 0 10 0 03 4 0 2 3-1 3 0 -8 30 0 32 -9 33 0 45 3 0 输出复制 182 示例2 输入复制 1232 2 2 2 2-1 -1-1 -1 输出复制 10 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include &lt;cstdio&gt;#include&lt;queue&gt;using namespace std;const long long maxn = 510;long long mp[maxn][maxn], r, c, x, y, z, num[maxn], cur, s[maxn], fsum[maxn], zsum[maxn];long long ans;long long L = 1, R = 0;struct node { long long zn, l, s; node(long long a, long long b, long long c) :zn(a), l(b), s(c) {} node() :zn(0), l(0), s(0) {}};deque&lt;node&gt;q;int main() { cin&gt;&gt;r&gt;&gt;c&gt;&gt;x&gt;&gt;y&gt;&gt;z; for (long long i = 1; i &lt;= r; ++i) for (long long j = 1; j &lt;= c; ++j) cin&gt;&gt;mp[i][j]; for (long long i = 1; i &lt;= r; ++i) { for (long long k = 1; k &lt;= c; ++k)num[k] = s[k] = fsum[k] = zsum[k] = 0; for (long long j = i; j &lt; i + x &amp;&amp; j &lt;= r; ++j) { for (long long k = 1; k &lt;= c; ++k)num[k] += (mp[j][k] == 0 ? 1 : 0), s[k] += mp[j][k]; q.clear(); long long inx = 1; q.push_back(node(0,0,0)); while (inx &lt;= c) { fsum[inx] = fsum[inx - 1] + s[inx]; zsum[inx] = zsum[inx - 1] + num[inx]; while (!q.empty() &amp;&amp; fsum[inx] &lt;= q.back().s)q.pop_back(); q.push_back(node(zsum[inx], inx, fsum[inx])); while ((q.back().zn - q.front().zn &gt; z) || (q.back().l - q.front().l &gt; y))q.pop_front(); ans = max(ans, q.back().s - q.front().s); inx++; } } } cout&lt;&lt;ans&lt;&lt;endl; return 0;}","link":"/2019/08/%E7%9F%A9%E9%98%B5/"},{"title":"线性基（转载）","text":"作者：Yveh来源：CSDN原文：https://blog.csdn.net/QAQ__QAQ/article/details/53812883 概述网上好像没有什么关于线性基的资料… 定义设数集T的值域范围为[1,2n−1]。T的线性基是T的一个子集A={a1,a2,a3,…,an}}。A中元素互相xor所形成的异或集合，等价于原数集T的元素互相xor形成的异或集合。可以理解为将原数集进行了压缩。 性质1.设线性基的异或集合中不存在0。2.线性基的异或集合中每个元素的异或方案唯一，其实这个跟性质1是等价的。3.线性基二进制最高位互不相同。4.如果线性基是满的，它的异或集合为[1,2n−1]。5.线性基中元素互相异或，异或集合不变。 维护插入如果向线性基中插入数x，从高位到低位扫描它为1的二进制位。扫描到第i时，如果ai不存在，就令ai=x，否则x=x⊗ai。x的结局是，要么被扔进线性基，要么经过一系列操作过后，变成了0。 1234567891011121314bool insert(long long val){ for (int i=60;i&gt;=0;i--) if (val&amp;(1LL&lt;&lt;i)) { if (!a[i]) { a[i]=val; break; } val^=a[i]; } return val&gt;0;} 合并将一个线性基暴力插入另一个线性基即可。 12345678L_B merge(const L_B &amp;n1,const L_B &amp;n2){ L_B ret=n1; for (int i=0;i&lt;=60;i++) if (n2.d[i]) ret.insert(n2.d[i]); return ret;} 查询存在性如果要查询x是否存于异或集合中。从高位到低位扫描x的为1的二进制位。扫描到第i位的时候x=x⊗ai如果中途x变为了0，那么表示x存于线性基的异或集合中。 最大值从高位到低位扫描线性基。如果异或后可以使得答案变大，就异或到答案中去。 12345678long long query_max(){ long long ret=0; for (int i=60;i&gt;=0;i--) if ((ret^d[i])&gt;ret) ret^=d[i]; return ret;} 最小值最小值即为最低位上的线性基。 1234567long long query_min(){ for (int i=0;i&lt;=60;i++) if (d[i]) return d[i]; return 0;} k小值根据性质3。我们要将线性基改造成每一位相互独立。具体操作就是如果i&lt;j，aj的第i位是1，就将aj异或上ai。经过一系列操作之后，对于二进制的某一位i。只有ai的这一位是1，其他都是0。所以查询的时候将k二进制拆分，对于1的位，就异或上对应的线性基。最终得出的答案就是k小值。 1234567891011121314151617181920void rebuild(){ for (int i=60;i&gt;=0;i--) for (int j=i-1;j&gt;=0;j--) if (d[i]&amp;(1LL&lt;&lt;j)) d[i]^=d[j]; for (int i=0;i&lt;=60;i++) if (d[i]) p[cnt++]=d[i];}long long kthquery(long long k){ int ret=0; if (k&gt;=(1LL&lt;&lt;cnt)) return -1; for (int i=60;i&gt;=0;i--) if (k&amp;(1LL&lt;&lt;i)) ret^=p[i]; return ret;} 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768struct L_B{ long long d[61],p[61]; int cnt; L_B() { memset(d,0,sizeof(d)); memset(p,0,sizeof(p)); cnt=0; } bool insert(long long val) { for (int i=60;i&gt;=0;i--) if (val&amp;(1LL&lt;&lt;i)) { if (!d[i]) { d[i]=val; break; } val^=d[i]; } return val&gt;0; } long long query_max() { long long ret=0; for (int i=60;i&gt;=0;i--) if ((ret^d[i])&gt;ret) ret^=d[i]; return ret; } long long query_min() { for (int i=0;i&lt;=60;i++) if (d[i]) return d[i]; return 0; } void rebuild() { for (int i=60;i&gt;=0;i--) for (int j=i-1;j&gt;=0;j--) if (d[i]&amp;(1LL&lt;&lt;j)) d[i]^=d[j]; for (int i=0;i&lt;=60;i++) if (d[i]) p[cnt++]=d[i]; } long long kthquery(long long k) { int ret=0; if (k&gt;=(1LL&lt;&lt;cnt)) return -1; for (int i=60;i&gt;=0;i--) if (k&amp;(1LL&lt;&lt;i)) ret^=p[i]; return ret; }}L_B merge(const L_B &amp;n1,const L_B &amp;n2){ L_B ret=n1; for (int i=60;i&gt;=0;i--) if (n2.d[i]) ret.insert(n1.d[i]); return ret;} 例题： 筱玛爱游戏(https://ac.nowcoder.com/acm/contest/946/E) 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;long long n,bit[70],ans,tmp;bool ins(long long v){ for(int i=60;i&gt;=0;--i){ if((1ll&lt;&lt;i)&amp;v){ if(!bit[i]){ bit[i]=v; return 1; } v^=bit[i]; } } return 0;}int main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i){ cin&gt;&gt;tmp; ans+=ins(tmp); } cout&lt;&lt;(ans&amp;1?\"First\":\"Second\")&lt;&lt;endl; return 0;}","link":"/2019/07/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"title":"线性基的交","text":"链接：https://ac.nowcoder.com/acm/contest/884/B来源：牛客网 Your are given n sets.Every set contains some integers. We say a set can express an integer, only when there exists a subset of the set such that the bitwise-xor of the elements in the subset is equal to that integer. Now you need to answer m queries. Each query will give you three integers l,r,x and you should answer if for every i∈[l,r]i \\in [l,r]i∈[l,r] ,the i-th set can express x. 输入描述:1The first line contains two integers n,m.For each of the following n lines, the first integer sz stands for the size of this set and the following sz integers stand for the elements in this set. The sets are described from number 1 to n.For each of the following m lines, there're three integers l,r,x that means a query. 输出描述:1For each query, output a line.If for every i∈[l,r]i \\in [l,r]i∈[l,r] ,the i-th set can express x, you need to print “YES”, and \"NO\" otherwise. 示例1 输入复制 123451 32 1 21 1 01 1 31 1 4 输出复制 123YESYESNO 备注:11≤n,m≤500001 \\le n,m \\le 500001≤n,m≤50000 ，1≤sz≤321 \\le sz \\le 321≤sz≤32，1≤l≤r≤n1 \\le l \\le r \\le n1≤l≤r≤n ，the every integer in input ∈[0,232)\\in [0,2^{32})∈[0,232)。 STD：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned int u32;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)const int N=5e4+5,L=10,B=N/L+5;struct Base{ static const int L=32; u32 a[L]; u32&amp; operator [](int x) { return a[x]; } u32 operator [](int x)const { return a[x]; } void ins(u32 x) { per(i,L-1,0) if((x&gt;&gt;i)&amp;1) if(a[i])x^=a[i]; else {a[i]=x;break;} } bool check(u32 x) { per(i,L-1,0) if((x&gt;&gt;i)&amp;1) if(a[i])x^=a[i]; else return 0; return 1; } void init() { int sz; scanf(\"%d\",&amp;sz); while(sz--) { u32 x; scanf(\"%u\",&amp;x); ins(x); } }friend Base intersection(const Base &amp;a,const Base &amp;b){ Base ans={},c=b,d=b; rep(i,0,L-1) { u32 x=a[i]; if(!x)continue; int j=i;u32 T=0; for(;j&gt;=0;--j) if((x&gt;&gt;j)&amp;1) if(c[j]){x^=c[j];T^=d[j];} else break; if(!x)ans[i]=T; else {c[j]=x;d[j]=T;} } return ans;}};Base a[N],f[15][B];bool brute_check(int l,int r,u32 x){ rep(i,l,r) if(!a[i].check(x))return 0; return 1;}bool check(int l,int r,u32 x){// Base ans=a[l];// rep(i,l,r)ans=intersection(ans,a[i]);// return ans.check(x); int bl=(l-1)/L,br=(r-1)/L; if(bl+1&gt;=br)return brute_check(l,r,x); if(!brute_check(l,(bl+1)*L,x)||!brute_check(br*L+1,r,x))return 0; l=bl+1;r=br-1; int j=31-__builtin_clz(r-l+1); return intersection(f[j][l],f[j][r-(1&lt;&lt;j)+1]).check(x);}int main(){// freopen(\"data10.in\",\"r\",stdin);freopen(\"tmp\",\"w\",stdout); int n,m; cin&gt;&gt;n&gt;&gt;m; rep(i,1,n)a[i].init(); rep(i,0,(n-1)/L) { f[0][i]=a[i*L+1]; rep(j,i*L+2,min(n,(i+1)*L))f[0][i]=intersection(f[0][i],a[j]); } rep(i,1,14) rep(j,0,(n-1)/L-(1&lt;&lt;i)+1)f[i][j]=intersection(f[i-1][j],f[i-1][j+(1&lt;&lt;i-1)]); while(m--) { int l,r;u32 x; scanf(\"%d%d%u\",&amp;l,&amp;r,&amp;x); // assert(check(l,r,x)==brute_check(l,r,x)); if(check(l,r,x))puts(\"YES\"); else puts(\"NO\"); }} 讲解：","link":"/2019/07/%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%9A%84%E4%BA%A4/"},{"title":"羊吃草","text":"链接：https://ac.nowcoder.com/acm/contest/1083/D来源：牛客网 有一个草原可以用一个1~400的数轴表示。有n头羊和q个查询。每头羊的编号分别是1，2，3…n。第i头羊只喜爱数轴上[ai，bi]这样的一个闭区间，每一时刻每头羊只可能在自己喜爱的区间的某个点上吃草。现在给出q个查询，每个查询两个整数l，r。你需要计算出在同一时刻，最多能有多少头羊同时在这个区间内吃草。数轴上每一个整点同一时刻只能容纳一只羊，羊只会在整点吃草。 输入描述:1第一行三个数n q。第二行n个数a1 a2…an。第三行n个数b1 b2…bn。接下来q行每行两个数l，r。表示询问的区间。 输出描述:1对于每个查询，输出一个整数表示答案。 示例1 输入复制 1234565 31 1 1 2 41 1 1 3 51 52 51 3 输出复制 123322 备注:11&lt;=n，q&lt;=4001&lt;=ai&lt;=bi&lt;=4001=l&lt;=r&lt;=400 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define inf 0x3f3f3f3fconst int maxn = 1050;struct Edge{ int from, to, cap, flow; Edge(){ } Edge(int from, int to, int cap, int flow):from(from), to(to), cap(cap), flow(flow){} };struct node{ int l,r; int id;}a[450];struct Dinic{ int n, m, s, t; vector&lt;Edge&gt;edges; vector&lt;int&gt;G[maxn]; int d[maxn]; int cur[maxn]; int vis[maxn]; void init(int n, int s, int t) { this-&gt;n = n;this-&gt;s = s;this-&gt;t = t; edges.clear(); for(int i = 0;i &lt;= n;++i) G[i].clear(); } void add_edge(int from, int to, int cap) { edges.push_back( Edge(from, to, cap, 0) ); edges.push_back( Edge(to, from, 0, 0) ); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); } bool bfs(){ memset(vis, 0, sizeof(vis)); queue&lt;int&gt;Q; Q.push(s); d[s] = 0; vis[s] = true; while(!Q.empty()) { int x = Q.front(); Q.pop(); for(int i = 0;i &lt; int(G[x].size());++i) { Edge&amp; e = edges[G[x][i]]; if(!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = true; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t]; } int dfs(int x,int a) { if(x == t || a == 0)return a; int flow = 0, f; for(int&amp; i = cur[x];i &lt; int(G[x].size());++i) { Edge&amp; e = edges[G[x][i]]; if(d[x] + 1 == d[e.to] &amp;&amp; (f = dfs( e.to, min(a, e.cap-e.flow)))&gt;0) { e.flow += f; edges[G[x][i]^1].flow -= f; flow += f; a -= f; if(a == 0)break; } } return flow; } int maxflow() { int flow = 0; while(bfs()) { memset(cur, 0, sizeof(cur)); flow += dfs(s,inf); } return flow; }}gao;//刘汝佳网络流dinic板子int main(){ int n,q; cin&gt;&gt;n&gt;&gt;q; for(int i=1;i&lt;=n;++i)a[i].id=i; for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i].l; for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i].r; while(q--) { int s=0,t=1000; gao.init(1000, s, t);//初始化数组 int l,r; cin&gt;&gt;l&gt;&gt;r; for(int i=l;i&lt;=r;++i)gao.add_edge(i+n,t,1); for(int i=1;i&lt;=n;++i){ if(a[i].r&lt;l||a[i].l&gt;r)continue; int Min=max(a[i].l,l),Max=min(a[i].r,r); gao.add_edge(s,i,1); for(int j=Min;j&lt;=Max;++j){ gao.add_edge(i,n+j,1); } } printf(\"%d\\n\",gao.maxflow());//输出最大流 } return 0;}","link":"/2019/09/%E7%BE%8A%E5%90%83%E8%8D%89/"},{"title":"自己动手写printf -- 库函数printf的实现[转载]","text":"转载来源：https://blog.csdn.net/cinmyheart/article/details/24582895 大概去年夏天的时候，在《C和指针》里面一个练习题要求实现一个很简单的不包含打印浮点数功能的printf函数。但是很好奇，于是一直纠结下去，结果就是知道了printf的实现，自己也写了一个简单的。或许是夏天的原因吧，那时候暑假没回去，凌晨四点兴奋到不能睡觉。那时候刚开始写blog。没想整理一下，只是简单的把最重要的实现”工具”贴了一个blog在 http://blog.csdn.net/cinmyheart/article/details/9804189 那时候第一次看linux的内核代码，熬过来的感觉总是很舒坦的。。。现在可能还是有很多看不懂，但是不会去畏惧那些长段长段的宏定义函数了。。。各种高上大的skill啊。。。。 言归正传，实现printf。 其实printf和getchar()类似，它们都是一个”外壳“，真正实现功能的不是它本身，而是通过调用别的函数。 getchar() is equivalent to getc(stdin). printf有一家子print函数 printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf - formatted output conversion它们的声明在不同的header file里面 12345678910111213#include &lt;stdio.h&gt; int printf(const char *format, ...); int fprintf(FILE *stream, const char *format, ...); int sprintf(char *str, const char *format, ...); int snprintf(char *str, size_t size, const char *format, ...); #include &lt;stdarg.h&gt; int vprintf(const char *format, va_list ap); int vfprintf(FILE *stream, const char *format, va_list ap); int vsprintf(char *str, const char *format, va_list ap); int vsnprintf(char *str, size_t size, const char *format, va_list ap); 12snprintf(), vsnprintf(): 这两个函数是C99新加的，编译的时候 注意 -std=c99 实现之前还是“复习”一下printf比较好，就当是铺垫 有意思的是printf的declaration。 1int printf(const char *format, ...); 返回值是int，第一个参数是const字符串指针，第二个参数是个… 先看看返回值int有哪些情况 Return value Upon successful return, these functions return the number of characters printed (excluding the null byte used to end output to strings). 嗯哼。。。返回的是成功打印的字符的个数，这里不包括NUL demo: 123456789101112#include&lt;stdio.h&gt; int main(){ int counter = 0; counter = printf(\"hello world! %d\\n\",10); printf(\"counter is %d\\n\",counter); return 0;} jasonleaster@ubuntu:~$ ./a.outhello world! 10counter is 16 接着，第一个参数是一个指针，指向const字符串 Format of the format string The format string is a character string, beginning and ending in its initial shift state, if any. The format string is composed of zero or more directives: ordinary characters (not %), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments. Each conversion specification is introduced by the character %, and ends with a conversion specifier. In between there may be (in this order) zero or more flags, an optional minimum field width, an optional precision and an optional length modifier. 很少人会用下面这种用法 printf(“%*d”,10,5); 我第一次遇到的时候，可以说是“惊愕”，究竟会打印什么东西。折腾了好久，最后搞定了。总结在这里 http://blog.csdn.net/cinmyheart/article/details/10116359 Format of the format string The format string is a character string, beginning and ending in its initial shift state, if any. The format string is composed of zero or more directives: ordinary characters (not %), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments. Each conversion specification is introduced by the character %, and ends with a conversion specifier. In between there may be (in this order) zero or more flags, an optional minimum field width, an optional precision and an optional length modifier. The arguments must correspond properly (after type promotion) with the conversion specifier. By default, the arguments are used in the order given, where each ‘‘ and each conversion specifier asks for the next argument (and it is an error if insufficiently many arguments are given). One can also specify explicitly which argument is taken, at each place where an argument is required, by writing “%m$” instead of ‘%’ and “*m$” instead of ‘‘, where the decimal integer m denotes the position in the argument list of the desired argument, indexed starting from 1. Thus, ​ printf(“%*d”, width, num); and ​ printf(“%2$*1$d”, width, num); are equivalent. The second style allows repeated references to the same argument. The C99 standard does not include the style using ‘$’, which comes from the Single UNIX Specification. If the style using ‘$’ is used, it must be used throughout for all conversions taking an argument and all width and precision arguments, but it may be mixed with “%%” formats which do not consume an argument. There may be no gaps in the numbers of arguments specified using ‘$’; for example, if arguments 1 and 3 are specified, argument 2 must also be specified somewhere in the format string. 第三个参数 … 嗯，这家伙有点屌，叫做变长参数。把这个搞定，C总会有点长进的 这个stdarg.h 我在现在的GCC和现在的linux 3.0版本的内核里面找了好久，都木有，估计是封装到被的地方了。。。。 builtin_va_start(v,l) 线索就死在这个地方。。。之后就找不到builtin_va_start的定义了 还是看早起内核的实现吧 0.12内核里面的stdarg.h 12345678910111213141516171819202122232425262728#ifndef _STDARG_H#define _STDARG_H typedef char *va_list; /* Amount of space required in an argument list for an arg of type TYPE. TYPE may alternatively be an expression whose type is used. */ #define __va_rounded_size(TYPE) \\ (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int)) #ifndef __sparc__#define va_start(AP, LASTARG) \\ (AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))#else#define va_start(AP, LASTARG) \\ (__builtin_saveregs (), \\ AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG)))#endif void va_end (va_list); /* Defined in gnulib */#define va_end(AP) #define va_arg(AP, TYPE) \\ (AP += __va_rounded_size (TYPE), \\ *((TYPE *) (AP - __va_rounded_size (TYPE)))) #endif /* _STDARG_H */ va_list 是一个指向字符串的指针 分析上面的宏定义 12#define __va_rounded_size(TYPE) \\ (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int)) 这个用来得到TYPE元素类型的字节大小，若不足4字节(例如short 和char),那么认为这个元素的大小为4字节，简单的说就是检测元素的大小，不足4字节的当作4字节看待。。。 12#define va_start(AP, LASTARG) \\ (AP = ((char *) &amp;(LASTARG) + __va_rounded_size (LASTARG))) AP一般都是va_list，LASTARG则是指向参数变长函数的格式化字符串的指针. va_start的作用就很明显了。取得变长参数列表的第一个参数的地址。 va_end 则是把指针va_list 置0 (通过google知道的，这个va_end真没找到定义，代码里面就一句#define 我无能为力啊。。。) 不过知道用va_start 和va_end 就OK啦 下面先来个变长参数的demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*****************************************************************************code writer : EOFcode date : 2014.04.26e-mail:jasonleaster@gmail.comcode purpose: just a demo for varible parameter function. usage: va_sum(a number,anohter number...,0); va_sum(1,2,3,4,5,0); return 15******************************************************************************/ #include &lt;stdarg.h&gt;#include &lt;stdio.h&gt; int va_sum(int* a,...); int main(){ int number = 1; int foo = 0; foo = va_sum(&amp;number,2,3,4,5,0); return 0;} int va_sum(int* a,...){ int counter = 0; int element = 0; va_list arg; va_start(arg,a); while((element = va_arg(arg,int)) != 0) { counter += element; } va_end(arg); return counter;} 写这个demo的时候，稍微纠结了一下，还是留了个小陷阱，提示一下，最后foo的值不是15这里要特别注意变长参数函数的第一个值，必须是个指针，就是利用这个指针和栈的FILO的性质来找到后面的元素的，这个是参数变长函数最根本的原理，利用了参数传递保存在栈里面，而且是连续的！ va_arg的作用很明显 1234#define va_arg(AP, TYPE) \\ (AP += __va_rounded_size (TYPE), \\ *((TYPE *) (AP - __va_rounded_size (TYPE)))) 把移动AP指针并取4字节内容读取出来。。。。我的语言表达只能这样了。。。T-T,看官自行领悟了。。。 ​ 好吧，是时候贴出来我自己写的一个闹着玩的printf了，仅仅是好玩，实现一下很基本的功能而已，viewer有兴趣的话可以去看vsprintf.c, 看源码是个很爽的过程(如果看懂的话)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/********************************************************************code writer : EOFcode date : 2014.04.26e-mail : jasonleaster@gmail.comcopyright@jasoneleastercode purpose: I love open source and I would like to help another peopleto learn programming. This is just a demo for how to implement a \"printf\". It's not perfect just like a little duck. But it's a representation of \"printf\".If there is something wrong with my codeplease touch me by e-mail. Thank you.*********************************************************************/#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt; int my_printf(const char* string,...); int main(){ my_printf(\"hello world!\\n\"); return 0;} int my_printf(const char* string,...){ char buffer[BUFSIZ];//Be tolerant with my_printf, never try to jump ovet the band of the buffer -- buffer overflow int temp = 0; va_list arg; char* p_string = NULL; char* p_buffer = buffer; char* p_temp = NULL; int counter = 0; int number = 0; int foo = 0; va_start(arg,string); for(counter = 0,p_string = string;*(p_string) != '\\0';) { switch(*p_string) { case '%': p_string++; switch(*p_string) { case 'd': temp = va_arg(arg,int); foo = temp; while(foo) { number++; counter++; foo /= 10; } foo = temp; while(number) { *(p_buffer+number-1) = (foo%10); foo /= 10; number--; } p_buffer += number; break; case 'c': temp = va_arg(arg,int); *(p_buffer++) = temp; break; case 's': p_temp = va_arg(arg,char*); while(p_temp != NULL) { *(p_buffer++) = *(p_temp++); counter++; } break; default: break; } break; default: *(p_buffer++) = *(p_string++); counter++; } } va_end(arg); p_buffer = NULL; puts(buffer); return counter;} 真的很幼稚，建议去看vsprintf。很精彩","link":"/2019/11/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99printf-%E5%BA%93%E5%87%BD%E6%95%B0printf%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"计算机网路习题(1)","text":"P2:$(N+P-1)*L/R$ P3: 电路交换网更适合，因为“连续运行相当长的一段时间”，电路交换网为其预留的资源可以很充分的利用。 需要。因为他们可能一起占用某个链路。而这个链路的总容量小于他们的总容量。 P4: $16$ $8$ 能 P6: $d_{prop}=m/s$ $d_{trans}=L/R$ $m/s+L/R$ 在主机$A$的网卡出口 距离主机$A$出口$s*L/r$处 此时主机$B$已经接收到第一个比特 $$m/s=L/R\\m=L/Rs=120/562.510^8=5.35710^8$$ P8: $3Mbps/150kbps=20$ $ 10 %$ $C_{120}^{n}0.1^n0.9^{120-n}$ P9: $10000$ $1-\\sum_{i=0}^{n}C_{M}^{i}p^i(1-p)^{M-i}$ P10:","link":"/2019/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E4%B9%A0%E9%A2%98-1/"},{"title":"阶乘分解","text":"链接：https://ac.nowcoder.com/acm/contest/1021/B来源：牛客网 题目描述给定整数 N(1≤N≤106)(1≤N≤10^6)(1≤N≤106)，试把阶乘 N! 分解质因数，按照算术基本定理的形式输出分解结果中的 pip_ipi 和 cic_ici 即可。 输入描述:1一个整数N。 输出描述:1N! 分解质因数后的结果，共若干行，每行一对pi,cip_i, c_ipi,ci，表示含有picip_i^{c_i}pici项。按照pi从小到大的顺序输出。 示例1 输入复制 15 输出复制 1232 33 15 1 说明15!=120=23∗3∗55! = 120 = 2^3 * 3 * 55!=120=23∗3∗5 Code：123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,l,r) for(int i=l;i&lt;=r;++i)#define per(i,r,l) for(int i=r;i&gt;=l;--i)#define pb push_back#define mk make_pair#define sz size#define ll long long#define int long longconst int maxn = 1e6 + 10;int n, pris[maxn], vis[maxn], id;ll ans[maxn];void GetPri() { rep(i, 2, n) { if (!vis[i])pris[++id] = i; for (int j = i * i; j &lt;= n; j += i)vis[j] = true; }}signed main() { ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL); cin &gt;&gt; n; GetPri(); //cerr&lt;&lt;\"debug \"&lt;&lt;id&lt;&lt;endl; rep(i, 1, id) { for (int j = pris[i]; j &lt;= n; j *= pris[i]) ans[i] += n / j; } rep(i, 1, id)cout &lt;&lt; pris[i] &lt;&lt; \" \" &lt;&lt; ans[i] &lt;&lt; endl; return 0;}","link":"/2019/08/%E9%98%B6%E4%B9%98%E5%88%86%E8%A7%A3/"},{"title":"随机数","text":"随机数 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int ST[50],dp[50][50][50];int dfs(int pos,int limit,int lead,int d1,int d2){ //D1:已有0的个数，D2：已有1的个数 if(pos==-1)return d1&gt;=d2; //最后判断的时候也无比确定零的个数大于等于一的个数 if(!limit&amp;&amp;dp[pos][d1][d2]!=-1)return dp[pos][d1][d2]; if(pos+d1+1&lt;d2)return dp[pos][d1][d2]=0; int ans=0,up=limit?ST[pos]:1; ans+=dfs(pos-1,limit&amp;&amp;ST[pos]==0,lead,lead?0:d1+1,d2); if(up)ans+=dfs(pos-1,limit&amp;&amp;ST[pos]==1,0,d1,d2+1); if(!limit&amp;&amp;!lead)dp[pos][d1][d2]=ans; return ans;}int solve(int cur){ int inx=0; while(cur){ ST[inx++]=cur%2; cur/=2; } return dfs(inx-1,true,true,0,0);}signed main(){ ios::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL); int l,r; cin&gt;&gt;l&gt;&gt;r; memset(dp,-1,sizeof(dp)); cerr&lt;&lt;solve(r)&lt;&lt;endl; cerr&lt;&lt;solve(l-1)&lt;&lt;endl; cout&lt;&lt;(solve(r)-solve(l-1))&lt;&lt;endl; return 0;} 数位DP模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748typedef long long ll;int a[20];ll dp[20][state];//不同题目状态不同ll dfs(int pos,/*state变量*/,bool lead/*前导零*/,bool limit/*数位上界变量*/)//不是每个题都要判断前导零{ //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了 if(pos==-1) return 1;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */ //第二个就是记忆化(在此前可能不同题目还能有一些剪枝) if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/ int up=limit?a[pos]:9;//根据limit判断枚举的上界up;这个的例子前面用213讲过了 ll ans=0; //开始计数 for(int i=0;i&lt;=up;i++)//枚举，然后把不同情况的个数加到ans就可以了 { if() ... else if()... ans+=dfs(pos-1,/*状态转移*/,lead &amp;&amp; i==0,limit &amp;&amp; i==a[pos]) //最后两个变量传参都是这样写的 /*这里还算比较灵活，不过做几个题就觉得这里也是套路了 大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论 去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目 要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类， 前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/ } //计算完，记录状态 if(!limit &amp;&amp; !lead) dp[pos][state]=ans; /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/ return ans;}ll solve(ll x){ int pos=0; while(x)//把数位都分解出来 { a[pos++]=x%10;//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行 x/=10; } return dfs(pos-1/*从最高位开始枚举*/,/*一系列状态 */,true,true);//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛}int main(){ ll le,ri; while(~scanf(\"%lld%lld\",&amp;le,&amp;ri)) { //初始化dp数组为-1,这里还有更加优美的优化,后面讲 printf(\"%lld\\n\",solve(ri)-solve(le-1)); }}","link":"/2019/07/%E9%9A%8F%E6%9C%BA%E6%95%B0/"}],"tags":[{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"二分图","slug":"二分图","link":"/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"带权并查集","slug":"带权并查集","link":"/tags/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"离线","slug":"离线","link":"/tags/%E7%A6%BB%E7%BA%BF/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"思维","slug":"思维","link":"/tags/%E6%80%9D%E7%BB%B4/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"数论分块","slug":"数论分块","link":"/tags/%E6%95%B0%E8%AE%BA%E5%88%86%E5%9D%97/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"不大理解","slug":"不大理解","link":"/tags/%E4%B8%8D%E5%A4%A7%E7%90%86%E8%A7%A3/"},{"name":"矩阵","slug":"矩阵","link":"/tags/%E7%9F%A9%E9%98%B5/"},{"name":"广告牌问题","slug":"广告牌问题","link":"/tags/%E5%B9%BF%E5%91%8A%E7%89%8C%E9%97%AE%E9%A2%98/"},{"name":"思维转换","slug":"思维转换","link":"/tags/%E6%80%9D%E7%BB%B4%E8%BD%AC%E6%8D%A2/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"训练指南","slug":"训练指南","link":"/tags/%E8%AE%AD%E7%BB%83%E6%8C%87%E5%8D%97/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"★★★★★","slug":"★★★★★","link":"/tags/%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"构造","slug":"构造","link":"/tags/%E6%9E%84%E9%80%A0/"},{"name":"数位DP","slug":"数位DP","link":"/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"codeforces","slug":"codeforces","link":"/tags/codeforces/"},{"name":"待补","slug":"待补","link":"/tags/%E5%BE%85%E8%A1%A5/"},{"name":"dfs判断","slug":"dfs判断","link":"/tags/dfs%E5%88%A4%E6%96%AD/"},{"name":"comet","slug":"comet","link":"/tags/comet/"},{"name":"contest","slug":"contest","link":"/tags/contest/"},{"name":"Floyd","slug":"Floyd","link":"/tags/Floyd/"},{"name":"Floyd求最小环","slug":"Floyd求最小环","link":"/tags/Floyd%E6%B1%82%E6%9C%80%E5%B0%8F%E7%8E%AF/"},{"name":"思维题","slug":"思维题","link":"/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/"},{"name":"Codeforces","slug":"Codeforces","link":"/tags/Codeforces/"},{"name":"状压DP","slug":"状压DP","link":"/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"无向图求环","slug":"无向图求环","link":"/tags/%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E7%8E%AF/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"思维体操","slug":"思维体操","link":"/tags/%E6%80%9D%E7%BB%B4%E4%BD%93%E6%93%8D/"},{"name":"牛客","slug":"牛客","link":"/tags/%E7%89%9B%E5%AE%A2/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"xv6","slug":"xv6","link":"/tags/xv6/"},{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"离散化","slug":"离散化","link":"/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"},{"name":"区间gcd","slug":"区间gcd","link":"/tags/%E5%8C%BA%E9%97%B4gcd/"},{"name":"最小团","slug":"最小团","link":"/tags/%E6%9C%80%E5%B0%8F%E5%9B%A2/"},{"name":"差分","slug":"差分","link":"/tags/%E5%B7%AE%E5%88%86/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"子集DP","slug":"子集DP","link":"/tags/%E5%AD%90%E9%9B%86DP/"},{"name":"状压","slug":"状压","link":"/tags/%E7%8A%B6%E5%8E%8B/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线性基","slug":"线性基","link":"/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"name":"★★★★","slug":"★★★★","link":"/tags/%E2%98%85%E2%98%85%E2%98%85%E2%98%85/"},{"name":"树状DP","slug":"树状DP","link":"/tags/%E6%A0%91%E7%8A%B6DP/"},{"name":"分组背包","slug":"分组背包","link":"/tags/%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/"},{"name":"线段树维护最大连续子段和","slug":"线段树维护最大连续子段和","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%BB%B4%E6%8A%A4%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%AE%B5%E5%92%8C/"},{"name":"单调队列","slug":"单调队列","link":"/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"矩阵相关","slug":"矩阵相关","link":"/tags/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"类背包","slug":"类背包","link":"/tags/%E7%B1%BB%E8%83%8C%E5%8C%85/"},{"name":"纯暴力","slug":"纯暴力","link":"/tags/%E7%BA%AF%E6%9A%B4%E5%8A%9B/"},{"name":"暴力","slug":"暴力","link":"/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"枚举","slug":"枚举","link":"/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"模拟","slug":"模拟","link":"/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"恶心","slug":"恶心","link":"/tags/%E6%81%B6%E5%BF%83/"},{"name":"笛卡尔树","slug":"笛卡尔树","link":"/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"},{"name":"脚本","slug":"脚本","link":"/tags/%E8%84%9A%E6%9C%AC/"},{"name":"ojshell","slug":"ojshell","link":"/tags/ojshell/"},{"name":"后缀自动机","slug":"后缀自动机","link":"/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"},{"name":"回文树","slug":"回文树","link":"/tags/%E5%9B%9E%E6%96%87%E6%A0%91/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"网络赛","slug":"网络赛","link":"/tags/%E7%BD%91%E7%BB%9C%E8%B5%9B/"},{"name":"徐州","slug":"徐州","link":"/tags/%E5%BE%90%E5%B7%9E/"},{"name":"基础知识","slug":"基础知识","link":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"树的重心","slug":"树的重心","link":"/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"},{"name":"裴蜀定理","slug":"裴蜀定理","link":"/tags/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/"},{"name":"枚举上下界","slug":"枚举上下界","link":"/tags/%E6%9E%9A%E4%B8%BE%E4%B8%8A%E4%B8%8B%E7%95%8C/"},{"name":"线性基的交","slug":"线性基的交","link":"/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA%E7%9A%84%E4%BA%A4/"},{"name":"linux内核","slug":"linux内核","link":"/tags/linux%E5%86%85%E6%A0%B8/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"质数","slug":"质数","link":"/tags/%E8%B4%A8%E6%95%B0/"},{"name":"唯一分解定理","slug":"唯一分解定理","link":"/tags/%E5%94%AF%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/"}],"categories":[{"name":"二分图","slug":"二分图","link":"/categories/%E4%BA%8C%E5%88%86%E5%9B%BE/"},{"name":"图论","slug":"图论","link":"/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"数论","slug":"数论","link":"/categories/%E6%95%B0%E8%AE%BA/"},{"name":"动态规划","slug":"动态规划","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"常规","slug":"常规","link":"/categories/%E5%B8%B8%E8%A7%84/"},{"name":"二分查找","slug":"二分查找","link":"/categories/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"构造","slug":"构造","link":"/categories/%E6%9E%84%E9%80%A0/"},{"name":"oj","slug":"oj","link":"/categories/oj/"},{"name":"codeforces","slug":"codeforces","link":"/categories/codeforces/"},{"name":"dfs判环","slug":"dfs判环","link":"/categories/dfs%E5%88%A4%E7%8E%AF/"},{"name":"comet","slug":"comet","link":"/categories/comet/"},{"name":"Floyd","slug":"Floyd","link":"/categories/Floyd/"},{"name":"竞技","slug":"竞技","link":"/categories/%E7%AB%9E%E6%8A%80/"},{"name":"状压DP","slug":"动态规划/状压DP","link":"/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8BDP/"},{"name":"无向图求环","slug":"无向图求环","link":"/categories/%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E7%8E%AF/"},{"name":"树状数组","slug":"树状数组","link":"/categories/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"思维体操","slug":"思维体操","link":"/categories/%E6%80%9D%E7%BB%B4%E4%BD%93%E6%93%8D/"},{"name":"codeforces","slug":"oj/codeforces","link":"/categories/oj/codeforces/"},{"name":"牛客","slug":"牛客","link":"/categories/%E7%89%9B%E5%AE%A2/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"博弈论","slug":"博弈论","link":"/categories/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"区间gcd","slug":"区间gcd","link":"/categories/%E5%8C%BA%E9%97%B4gcd/"},{"name":"图论","slug":"Floyd/图论","link":"/categories/Floyd/%E5%9B%BE%E8%AE%BA/"},{"name":"差分","slug":"差分","link":"/categories/%E5%B7%AE%E5%88%86/"},{"name":"LCA","slug":"LCA","link":"/categories/LCA/"},{"name":"线段树","slug":"线段树","link":"/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"线性基","slug":"线性基","link":"/categories/%E7%BA%BF%E6%80%A7%E5%9F%BA/"},{"name":"主席树","slug":"主席树","link":"/categories/%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"name":"单调队列","slug":"单调队列","link":"/categories/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"并查集","slug":"数据结构/并查集","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"模板","slug":"模板","link":"/categories/%E6%A8%A1%E6%9D%BF/"},{"name":"暴力","slug":"暴力","link":"/categories/%E6%9A%B4%E5%8A%9B/"},{"name":"思维题","slug":"思维题","link":"/categories/%E6%80%9D%E7%BB%B4%E9%A2%98/"},{"name":"贪心","slug":"贪心","link":"/categories/%E8%B4%AA%E5%BF%83/"},{"name":"思维","slug":"思维","link":"/categories/%E6%80%9D%E7%BB%B4/"},{"name":"xv6","slug":"操作系统/xv6","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6/"},{"name":"最短路","slug":"最短路","link":"/categories/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"模拟","slug":"模拟","link":"/categories/%E6%A8%A1%E6%8B%9F/"},{"name":"网络流","slug":"网络流","link":"/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"线段树&笛卡尔树","slug":"数据结构/线段树-笛卡尔树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91-%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/"},{"name":"脚本","slug":"脚本","link":"/categories/%E8%84%9A%E6%9C%AC/"},{"name":"字符串","slug":"字符串","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"网络赛","slug":"网络赛","link":"/categories/%E7%BD%91%E7%BB%9C%E8%B5%9B/"},{"name":"变长参数","slug":"变长参数","link":"/categories/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Dinic","slug":"网络流/Dinic","link":"/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/Dinic/"},{"name":"python","slug":"脚本/python","link":"/categories/%E8%84%9A%E6%9C%AC/python/"},{"name":"linux内核","slug":"变长参数/linux内核","link":"/categories/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0/linux%E5%86%85%E6%A0%B8/"},{"name":"printf实现","slug":"变长参数/linux内核/printf实现","link":"/categories/%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0/linux%E5%86%85%E6%A0%B8/printf%E5%AE%9E%E7%8E%B0/"}]}